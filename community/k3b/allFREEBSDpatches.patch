diff -rupN k3b-2.0.2/libk3b/CMakeLists.txt k3b-2.0.2-patched/libk3b/CMakeLists.txt
--- k3b-2.0.2/libk3b/CMakeLists.txt	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/CMakeLists.txt	2013-09-16 01:28:44.000000000 +0300
@@ -230,12 +230,8 @@ target_link_libraries(k3b
   ${KCDDB_LIBRARIES}
   ${SAMPLERATE_LIBRARIES}
   k3bdevice
+  ${CMAKE_DL_LIBS}
 )
-if(NOT WIN32)
-	target_link_libraries(k3b dl)
-else(NOT WIN32)
-	target_link_libraries(k3b uuid ole32)
-endif(NOT WIN32)
   
 if(ENABLE_DVD_RIPPING)
   target_link_libraries(k3b ${DVDREAD_LIBRARIES})
diff -rupN k3b-2.0.2/libk3b/CMakeLists.txt.orig k3b-2.0.2-patched/libk3b/CMakeLists.txt.orig
--- k3b-2.0.2/libk3b/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/CMakeLists.txt.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,247 @@
+project(libk3b)
+
+include_directories(
+  ${CMAKE_CURRENT_BINARY_DIR}
+  ${CMAKE_CURRENT_BINARY_DIR}/core
+  ${CMAKE_CURRENT_BINARY_DIR}/plugin
+  ${CMAKE_CURRENT_BINARY_DIR}/tools
+  ${CMAKE_CURRENT_BINARY_DIR}/projects
+  ${CMAKE_CURRENT_BINARY_DIR}/jobs
+  )
+
+set(CMAKE_REQUIRED_LIBRARIES m)
+CHECK_FUNCTION_EXISTS(lrint HAVE_LRINT)
+CHECK_FUNCTION_EXISTS(lrintf HAVE_LRINTF)
+
+configure_file(config-libk3b.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-libk3b.h )
+
+add_subdirectory( core )
+add_subdirectory( plugin )
+add_subdirectory( tools )
+add_subdirectory( projects )
+add_subdirectory( jobs )
+
+set(k3b_jobs_SRCS
+  jobs/k3bdatatrackreader.cpp 
+  jobs/k3breadcdreader.cpp 
+  jobs/k3bcdcopyjob.cpp 
+  jobs/k3bclonejob.cpp 
+  jobs/k3baudiosessionreadingjob.cpp 
+  jobs/k3bdvdcopyjob.cpp 
+  jobs/k3baudiofileanalyzerjob.cpp
+  jobs/k3baudiocuefilewritingjob.cpp 
+  jobs/k3bbinimagewritingjob.cpp 
+  jobs/k3biso9660imagewritingjob.cpp 
+  jobs/k3bdvdformattingjob.cpp 
+  jobs/k3bblankingjob.cpp 
+  jobs/k3bclonetocreader.cpp 
+  jobs/k3bverificationjob.cpp 
+  jobs/k3bdvdbooktypejob.cpp
+  jobs/k3bmetawriter.cpp
+)
+
+########### next target ###############
+if(ENABLE_DVD_RIPPING)
+  add_subdirectory(videodvd)
+  set(k3b_jobs_SRCS
+    ${k3b_jobs_SRCS}
+    jobs/k3bvideodvdtitletranscodingjob.cpp
+    jobs/k3bvideodvdtitledetectclippingjob.cpp
+    )
+endif(ENABLE_DVD_RIPPING)
+
+set(k3b_core_SRCS 
+  core/k3bcore.cpp 
+  core/k3bglobals.cpp 
+  core/k3bdefaultexternalprograms.cpp
+  core/k3bexternalbinmanager.cpp 
+  core/k3bversion.cpp 
+  core/k3bjob.cpp 
+  core/k3bthread.cpp 
+  core/k3bthreadjob.cpp 
+  core/k3bglobalsettings.cpp 
+  core/k3bsimplejobhandler.cpp 
+  core/k3bthreadjobcommunicationevent.cpp)
+
+
+set(k3b_tools_SRCS
+  tools/k3bwavefilewriter.cpp tools/k3bbusywidget.cpp tools/k3bdeviceselectiondialog.cpp 
+  tools/k3bmd5job.cpp tools/k3btitlelabel.cpp
+  tools/k3bstringutils.cpp tools/k3bdevicecombobox.cpp 
+  tools/k3bstdguiitems.cpp tools/k3bvalidators.cpp tools/k3bthroughputestimator.cpp 
+  tools/k3biso9660.cpp tools/k3bmultichoicedialog.cpp tools/k3bdevicehandler.cpp 
+  tools/k3bcdparanoialib.cpp tools/k3blistview.cpp tools/k3bmsfedit.cpp 
+  tools/k3bcdtextvalidator.cpp tools/k3bintvalidator.cpp tools/k3bexceptions.cpp 
+  tools/k3bprogressdialog.cpp tools/k3bpushbutton.cpp 
+  tools/k3blistviewitemanimator.cpp tools/k3bthreadwidget.cpp
+  tools/k3bsignalwaiter.cpp tools/k3blibdvdcss.cpp tools/k3biso9660backend.cpp 
+  tools/k3bchecksumpipe.cpp 
+  tools/k3bintmapcombobox.cpp tools/k3bdirsizejob.cpp tools/k3brichtextlabel.cpp 
+  tools/k3bactivepipe.cpp tools/k3bfilesplitter.cpp 
+  tools/k3bfilesysteminfo.cpp
+  tools/k3bdevicemodel.cpp
+  tools/k3bmedium.cpp
+  tools/k3bmediacache.cpp 
+  tools/k3bcddb.cpp
+  tools/k3bprocess.cpp 
+  tools/qprocess/k3bqprocess.cpp
+  tools/qprocess/k3bkprocess.cpp
+  )
+  
+if(WIN32)
+	list(APPEND k3b_tools_SRCS 
+		tools/qprocess/k3bqprocess_win.cpp
+		tools/qprocess/private/qwineventnotifier_p.cpp
+		tools/qprocess/private/qfsfileengine_win.cpp
+		tools/qprocess/private/qfsfileengine.cpp
+		tools/qprocess/private/qfsfileengine_iterator.cpp
+		tools/qprocess/private/qfsfileengine_iterator_win.cpp
+)
+else(WIN32)
+  	list(APPEND k3b_tools_SRCS 
+		tools/qprocess/k3bqprocess_unix.cpp
+	)
+endif(WIN32)
+  
+set(k3b_libisofs_SRCS tools/libisofs/isofs.cpp)
+
+set(k3b_videodvd_SRCS 
+  videodvd/k3bvideodvd.cpp
+  videodvd/k3bvideodvdtime.cpp
+  videodvd/k3bvideodvdvideostream.cpp)
+
+set(k3b_plugin_SRCS
+  plugin/k3bplugin.cpp 
+  plugin/k3bpluginconfigwidget.cpp 
+  plugin/k3bpluginmanager.cpp 
+  plugin/k3baudiodecoder.cpp 
+  plugin/k3baudioencoder.cpp 
+  plugin/k3bprojectplugin.cpp
+  )
+
+set(k3b_project_SRCS
+  projects/k3babstractwriter.cpp 
+  projects/k3bgrowisofswriter.cpp 
+  projects/k3bgrowisofshandler.cpp 
+  projects/k3bdoc.cpp 
+  projects/k3bcdrdaowriter.cpp 
+  projects/k3bcdrecordwriter.cpp 
+  projects/k3binffilewriter.cpp 
+  projects/k3btocfilewriter.cpp 
+  projects/k3bimagefilereader.cpp 
+  projects/k3bcuefileparser.cpp )
+
+set(k3b_project_audiocd_SRCS
+  projects/audiocd/k3baudiojob.cpp 
+  projects/audiocd/k3baudiotrack.cpp 
+  projects/audiocd/k3baudiodoc.cpp 
+  projects/audiocd/k3baudiofile.cpp 
+  projects/audiocd/k3baudiozerodata.cpp 
+  projects/audiocd/k3baudiodatasource.cpp 
+  projects/audiocd/k3brawaudiodatasource.cpp 
+  projects/audiocd/k3baudionormalizejob.cpp 
+  projects/audiocd/k3baudiojobtempdata.cpp 
+  projects/audiocd/k3baudioimager.cpp 
+  projects/audiocd/k3baudiomaxspeedjob.cpp 
+  projects/audiocd/k3baudiocdtracksource.cpp 
+  projects/audiocd/k3baudiocdtrackdrag.cpp 
+  projects/audiocd/k3baudiodatasourceiterator.cpp
+  )
+
+set(k3b_project_datacd
+  projects/datacd/k3bdatajob.cpp 
+  projects/datacd/k3bdatadoc.cpp 
+  projects/datacd/k3bdataitem.cpp 
+  projects/datacd/k3bdiritem.cpp 
+  projects/datacd/k3bfileitem.cpp 
+  projects/datacd/k3bisoimager.cpp 
+  projects/datacd/k3bbootitem.cpp 
+  projects/datacd/k3bisooptions.cpp 
+  projects/datacd/k3bfilecompilationsizehandler.cpp 
+  projects/datacd/k3bsessionimportitem.cpp 
+  projects/datacd/k3bmkisofshandler.cpp 
+  projects/datacd/k3bdatapreparationjob.cpp 
+  projects/datacd/k3bmsinfofetcher.cpp 
+  projects/datacd/k3bdatamultisessionparameterjob.cpp
+  )
+
+set(k3b_project_mixedcd
+  projects/mixedcd/k3bmixeddoc.cpp
+  projects/mixedcd/k3bmixedjob.cpp
+  )
+
+set(k3b_project_movixcd
+  projects/movixcd/k3bmovixprogram.cpp 
+  projects/movixcd/k3bmovixdoc.cpp 
+  projects/movixcd/k3bmovixjob.cpp 
+  projects/movixcd/k3bmovixfileitem.cpp 
+  projects/movixcd/k3bmovixdocpreparer.cpp
+  )
+
+set(k3b_project_videocd
+  projects/videocd/k3bvcddoc.cpp 
+  projects/videocd/k3bvcdtrack.cpp 
+  projects/videocd/k3bvcdjob.cpp 
+  projects/videocd/k3bvcdoptions.cpp 
+  projects/videocd/k3bvcdxmlview.cpp
+  )
+
+set(k3b_project_mpeg_info
+  projects/videocd/mpeginfo/k3bmpeginfo.cpp
+  )
+
+set(k3b_project_videodvd
+  projects/videodvd/k3bvideodvddoc.cpp 
+  projects/videodvd/k3bvideodvdjob.cpp 
+  projects/videodvd/k3bvideodvdimager.cpp
+  )
+
+
+set(k3b_LIB_SRCS 
+  ${k3b_core_SRCS} 
+  ${k3b_tools_SRCS} 
+  ${k3b_plugin_SRCS}
+  ${k3b_project_SRCS} 
+  ${k3b_jobs_SRCS} 
+  ${k3b_libisofs_SRCS}
+  ${k3b_project_audiocd_SRCS} 
+  ${k3b_project_datacd} 
+  ${k3b_project_mixedcd}
+  ${k3b_project_movixcd} 
+  ${k3b_project_mpeg_info}
+  ${k3b_project_videocd}
+  ${k3b_project_videodvd}
+  )
+
+if (ENABLE_DVD_RIPPING)
+  set(k3b_LIB_SRCS ${k3b_LIB_SRCS}
+    ${k3b_videodvd_SRCS}
+    )
+endif (ENABLE_DVD_RIPPING)
+
+kde4_add_library(k3b SHARED ${k3b_LIB_SRCS})
+
+target_link_libraries(k3b
+  ${KDE4_KDECORE_LIBS}
+  ${KDE4_KUTILS_LIBS}
+  ${KDE4_SOLID_LIBS}
+  ${KDE4_KDE3SUPPORT_LIBS}
+  ${KDE4_KPTY_LIBS}
+  ${KCDDB_LIBRARIES}
+  ${SAMPLERATE_LIBRARIES}
+  k3bdevice
+)
+if(NOT WIN32)
+	target_link_libraries(k3b dl)
+else(NOT WIN32)
+	target_link_libraries(k3b uuid ole32)
+endif(NOT WIN32)
+  
+if(ENABLE_DVD_RIPPING)
+  target_link_libraries(k3b ${DVDREAD_LIBRARIES})
+endif(ENABLE_DVD_RIPPING)
+
+set_target_properties(k3b PROPERTIES OUTPUT_NAME k3blib)
+
+set_target_properties(k3b PROPERTIES VERSION ${K3B_LIB_VERSION_MAJOR}.${K3B_LIB_VERSION_MINOR}.${K3B_LIB_VERSION_RELEASE} SOVERSION ${K3B_LIB_VERSION_MAJOR})
+install(TARGETS k3b ${INSTALL_TARGETS_DEFAULT_ARGS} )
diff -rupN k3b-2.0.2/libk3b/core/k3bglobals.cpp k3b-2.0.2-patched/libk3b/core/k3bglobals.cpp
--- k3b-2.0.2/libk3b/core/k3bglobals.cpp	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/core/k3bglobals.cpp	2013-09-16 01:26:13.000000000 +0300
@@ -322,6 +322,13 @@ QString K3b::externalBinDeviceParameter(
 }
 
 
+QString K3b::externalBinGenericDeviceParameter( K3b::Device::Device* dev, const K3b::ExternalBin* bin )
+{
+    Q_UNUSED( bin );
+    return dev->genericDeviceName();
+}
+
+
 K3b::WritingApp K3b::writingAppFromString( const QString& s )
 {
     if( s.toLower() == "cdrdao" )
diff -rupN k3b-2.0.2/libk3b/core/k3bglobals.cpp.orig k3b-2.0.2-patched/libk3b/core/k3bglobals.cpp.orig
--- k3b-2.0.2/libk3b/core/k3bglobals.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/core/k3bglobals.cpp.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,611 @@
+/*
+ *
+ * Copyright (C) 2003-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include <config-k3b.h>
+
+#include "k3bglobals.h"
+#include "k3bglobalsettings.h"
+#include "k3bversion.h"
+#include "k3bdevice.h"
+#include "k3bdevicemanager.h"
+#include "k3bdeviceglobals.h"
+#include "k3bexternalbinmanager.h"
+#include "k3bcore.h"
+#include "k3bmediacache.h"
+#include "k3bmsf.h"
+
+#include <kdeversion.h>
+#include <kglobal.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <kapplication.h>
+#include <kdebug.h>
+#include <kio/job.h>
+#include <kio/netaccess.h>
+#include <kurl.h>
+#include <kprocess.h>
+#include <KDiskFreeSpaceInfo>
+
+#include <kmountpoint.h>
+#include <Solid/Device>
+#include <Solid/StorageAccess>
+#include <Solid/OpticalDrive>
+
+#include <qdatastream.h>
+#include <qdir.h>
+#include <qfile.h>
+
+#include <cmath>
+#include <sys/utsname.h>
+
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
+#  include <sys/param.h>
+#  include <sys/mount.h>
+#  include <sys/endian.h>
+#  define bswap_16(x) bswap16(x)
+#  define bswap_32(x) bswap32(x)
+#  define bswap_64(x) bswap64(x)
+#else
+#  include <byteswap.h>
+#endif
+
+#ifdef Q_OS_WIN32
+#include <windows.h>
+#endif
+
+
+qint16 K3b::swapByteOrder( const qint16& i )
+{
+    return bswap_16( i );
+    //((i << 8) & 0xff00) | ((i >> 8 ) & 0xff);
+}
+
+
+qint32 K3b::swapByteOrder( const qint32& i )
+{
+    //return ((i << 24) & 0xff000000) | ((i << 8) & 0xff0000) | ((i >> 8) & 0xff00) | ((i >> 24) & 0xff );
+    return bswap_32( i );
+}
+
+
+qint64 K3b::swapByteOrder( const qint64& i )
+{
+    return bswap_64( i );
+}
+
+
+QString K3b::findUniqueFilePrefix( const QString& _prefix, const QString& path )
+{
+    QString url;
+    if( path.isEmpty() || !QFile::exists(path) )
+        url = defaultTempPath();
+    else
+        url = prepareDir( path );
+
+    QString prefix = _prefix;
+    if( prefix.isEmpty() )
+        prefix = "k3b_";
+
+    // now create the unique prefix
+    QDir dir( url );
+    QStringList entries = dir.entryList( QDir::NoFilter, QDir::Name );
+    int i = 0;
+    for( QStringList::iterator it = entries.begin();
+         it != entries.end(); ++it ) {
+        if( (*it).startsWith( prefix + QString::number(i) ) ) {
+            i++;
+            it = entries.begin();
+        }
+    }
+
+    return url + prefix + QString::number(i);
+}
+
+
+QString K3b::findTempFile( const QString& ending, const QString& d )
+{
+    return findUniqueFilePrefix( "k3b_", d ) + ( ending.isEmpty() ? QString() : (QString::fromLatin1(".") + ending) );
+}
+
+
+QString K3b::defaultTempPath()
+{
+    return prepareDir( k3bcore->globalSettings()->defaultTempPath() );
+}
+
+
+QString K3b::prepareDir( const QString& dir )
+{
+    if(dir.isEmpty())
+        return QString();
+    else if ( !dir.endsWith( '/' ) )
+        return dir + '/';
+    else
+        return dir;
+}
+
+
+QString K3b::parentDir( const QString& path )
+{
+    QString parent = path;
+    if( path.isEmpty())
+        return QString();
+    if( path[path.length()-1] == '/' )
+        parent.truncate( parent.length()-1 );
+
+    int pos = parent.lastIndexOf( '/' );
+    if( pos >= 0 )
+        parent.truncate( pos+1 );
+    else // relative path, do anything...
+        parent = "/";
+
+    return parent;
+}
+
+
+QString K3b::fixupPath( const QString& path )
+{
+    QString s;
+    bool lastWasSlash = false;
+    for( int i = 0; i < path.length(); ++i ) {
+        if( path[i] == '/' ) {
+            if( !lastWasSlash ) {
+                lastWasSlash = true;
+                s.append( "/" );
+            }
+        }
+        else {
+            lastWasSlash = false;
+            s.append( path[i] );
+        }
+    }
+
+    return s;
+}
+
+
+K3b::Version K3b::kernelVersion()
+{
+    // initialize kernel version
+    K3b::Version v;
+    utsname unameinfo;
+    if( ::uname(&unameinfo) == 0 ) {
+        v = QString::fromLocal8Bit( unameinfo.release );
+        kDebug() << "kernel version: " << v;
+    }
+    else
+        kError() << "could not determine kernel version." ;
+    return v;
+}
+
+
+K3b::Version K3b::simpleKernelVersion()
+{
+    return kernelVersion().simplify();
+}
+
+
+QString K3b::systemName()
+{
+    QString v;
+    utsname unameinfo;
+    if( ::uname(&unameinfo) == 0 ) {
+        v = QString::fromLocal8Bit( unameinfo.sysname );
+    }
+    else
+        kError() << "could not determine system name." ;
+    return v;
+}
+
+
+bool K3b::kbFreeOnFs( const QString& path, unsigned long& size, unsigned long& avail )
+{
+    KDiskFreeSpaceInfo fs = KDiskFreeSpaceInfo::freeSpaceInfo( path );
+    if ( fs.isValid() ) {
+        size = fs.size()/1024;
+        avail = fs.available()/1024;
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+KIO::filesize_t K3b::filesize( const KUrl& url )
+{
+    KIO::filesize_t fSize = 0;
+    if( url.isLocalFile() ) {
+        QFileInfo fi( url.toLocalFile() );
+        fSize = fi.size();
+    }
+    else {
+        KIO::UDSEntry uds;
+        KIO::NetAccess::stat( url, uds, 0 );
+        fSize = uds.numberValue( KIO::UDSEntry::UDS_SIZE );
+    }
+
+    return fSize;
+}
+
+
+KIO::filesize_t K3b::imageFilesize( const KUrl& url )
+{
+    KIO::filesize_t size = K3b::filesize( url );
+    int cnt = 0;
+    while( KIO::NetAccess::exists( url.url() + '.' + QString::number(cnt).rightJustified( 3, '0' ), KIO::NetAccess::SourceSide, 0 ) )
+        size += K3b::filesize( url.url() + '.' + QString::number(cnt++).rightJustified( 3, '0' ) );
+    return size;
+}
+
+
+QString K3b::cutFilename( const QString& name, int len )
+{
+    if( name.length() > len ) {
+        QString ret = name;
+
+        // determine extension (we think of an extension to be at most 5 chars in length)
+        int pos = name.indexOf( '.', -6 );
+        if( pos > 0 )
+            len -= (name.length() - pos);
+
+        ret.truncate( len );
+
+        if( pos > 0 )
+            ret.append( name.mid( pos ) );
+
+        return ret;
+    }
+    else
+        return name;
+}
+
+
+QString K3b::removeFilenameExtension( const QString& name )
+{
+    QString v = name;
+    int dotpos = v.lastIndexOf( '.' );
+    if( dotpos > 0 )
+        v.truncate( dotpos );
+    return v;
+}
+
+
+QString K3b::appendNumberToFilename( const QString& name, int num, unsigned int maxlen )
+{
+    // determine extension (we think of an extension to be at most 5 chars in length)
+    QString result = name;
+    QString ext;
+    int pos = name.indexOf( '.', -6 );
+    if( pos > 0 ) {
+        ext = name.mid(pos);
+        result.truncate( pos );
+    }
+
+    ext.prepend( QString::number(num) );
+    result.truncate( maxlen - ext.length() );
+
+    return result + ext;
+}
+
+
+bool K3b::plainAtapiSupport()
+{
+    // FIXME: what about BSD?
+    return ( K3b::simpleKernelVersion() >= K3b::Version( 2, 5, 40 ) );
+}
+
+
+bool K3b::hackedAtapiSupport()
+{
+    // IMPROVEME!!!
+    // FIXME: since when does the kernel support this?
+    return ( K3b::simpleKernelVersion() >= K3b::Version( 2, 4, 0 ) );
+}
+
+
+QString K3b::externalBinDeviceParameter( K3b::Device::Device* dev, const K3b::ExternalBin* bin )
+{
+    Q_UNUSED( bin );
+    return dev->blockDeviceName();
+}
+
+
+K3b::WritingApp K3b::writingAppFromString( const QString& s )
+{
+    if( s.toLower() == "cdrdao" )
+        return K3b::WritingAppCdrdao;
+    else if( s.toLower() == "cdrecord" )
+        return K3b::WritingAppCdrecord;
+    else if( s.toLower() == "growisofs" )
+        return K3b::WritingAppGrowisofs;
+    else if( s.toLower() == "dvd+rw-format" )
+        return K3b::WritingAppDvdRwFormat;
+    else
+        return K3b::WritingAppAuto;
+}
+
+
+QString K3b::writingAppToString( K3b::WritingApp app )
+{
+    switch( app ) {
+    case WritingAppCdrecord:
+        return "cdrecord";
+    case WritingAppCdrdao:
+        return "cdrdao";
+    case WritingAppGrowisofs:
+        return "growisofs";
+    case WritingAppDvdRwFormat:
+        return "dvd+rw-format";
+    default:
+        return "auto";
+    }
+}
+
+
+QString K3b::writingModeString( K3b::WritingModes modes )
+{
+    if( modes == WritingModeAuto )
+        return i18n("Auto");
+    else
+        return K3b::Device::writingModeString( ( int )modes );
+}
+
+
+QString K3b::resolveLink( const QString& file )
+{
+    QFileInfo f( file );
+    return f.canonicalFilePath();
+}
+
+
+KUrl K3b::convertToLocalUrl( const KUrl& url )
+{
+    if( !url.isLocalFile() ) {
+        return KIO::NetAccess::mostLocalUrl( url, 0 );
+    }
+
+    return url;
+}
+
+
+KUrl::List K3b::convertToLocalUrls( const KUrl::List& urls )
+{
+    KUrl::List r;
+    for( KUrl::List::const_iterator it = urls.constBegin(); it != urls.constEnd(); ++it )
+        r.append( convertToLocalUrl( *it ) );
+    return r;
+}
+
+
+qint16 K3b::fromLe16( char* data )
+{
+#ifdef WORDS_BIGENDIAN // __BYTE_ORDER == __BIG_ENDIAN
+    return swapByteOrder( *((qint16*)data) );
+#else
+    return *((qint16*)data);
+#endif
+}
+
+
+qint32 K3b::fromLe32( char* data )
+{
+#ifdef WORDS_BIGENDIAN // __BYTE_ORDER == __BIG_ENDIAN
+    return swapByteOrder( *((qint32*)data) );
+#else
+    return *((qint32*)data);
+#endif
+}
+
+
+qint64 K3b::fromLe64( char* data )
+{
+#ifdef WORDS_BIGENDIAN // __BYTE_ORDER == __BIG_ENDIAN
+    return swapByteOrder( *((qint64*)data) );
+#else
+    return *((qint64*)data);
+#endif
+}
+
+
+QString K3b::findExe( const QString& name )
+{
+    // first we search the path
+    QString bin = KStandardDirs::findExe( name );
+
+    // then go on with our own little list
+    if( bin.isEmpty() )
+        bin = KStandardDirs::findExe( name, k3bcore->externalBinManager()->searchPath().join(":") );
+
+    return bin;
+}
+
+
+bool K3b::isMounted( K3b::Device::Device* dev )
+{
+    if( !dev )
+        return false;
+    else
+        return( KMountPoint::currentMountPoints().findByDevice( dev->blockDeviceName() ).data() != 0 );
+}
+
+
+bool K3b::unmount( K3b::Device::Device* dev )
+{
+    if( !dev )
+        return false;
+
+    Solid::StorageAccess *sa = dev->solidStorage();
+    if ( sa && sa->teardown() ){
+        return true;
+    }
+
+    QString mntDev = dev->blockDeviceName();
+
+    // first try to unmount it the standard way
+    if( KIO::NetAccess::synchronousRun( KIO::unmount( mntDev ), 0 ) )
+        return true;
+
+    QString mntPath;
+    if ( KMountPoint::Ptr mp = KMountPoint::currentMountPoints().findByDevice( dev->blockDeviceName() ) ) {
+        mntPath = mp->mountPoint();
+    }
+    if ( mntPath.isEmpty() ) {
+        mntPath = dev->blockDeviceName();
+    }
+
+    QString umountBin = K3b::findExe( "umount" );
+    if( !umountBin.isEmpty() ) {
+        KProcess p;
+        p << umountBin;
+        p << "-l"; // lazy unmount
+        p << mntPath;
+        p.start();
+        if (p.waitForFinished(-1))
+          return true;
+    }
+
+    // now try pmount
+    QString pumountBin = K3b::findExe( "pumount" );
+    if( !pumountBin.isEmpty() ) {
+        KProcess p;
+        p << pumountBin;
+        p << "-l"; // lazy unmount
+        p << mntPath;
+        p.start();
+        return p.waitForFinished(-1);
+    }
+    else {
+        return false;
+    }
+}
+
+
+bool K3b::mount( K3b::Device::Device* dev )
+{
+    if( !dev )
+        return false;
+
+    QString mntDev = dev->blockDeviceName();
+
+    // first try to mount it the standard way
+    if( KIO::NetAccess::synchronousRun( KIO::mount( true, QByteArray(), mntDev, QString() ), 0 ) )
+        return true;
+
+    Solid::StorageAccess* sa = dev->solidStorage();
+    if ( sa && sa->setup() ) {
+        return true;
+    }
+
+    // now try pmount
+    QString pmountBin = K3b::findExe( "pmount" );
+    if( !pmountBin.isEmpty() ) {
+        KProcess p;
+        p << pmountBin;
+        p << mntDev;
+        p.start();
+        return p.waitForFinished(-1);
+    }
+
+    // and the most simple one
+    QString mountBin = K3b::findExe( "mount" );
+    if( !mountBin.isEmpty() ) {
+        KProcess p;
+        p << mountBin;
+        p << mntDev;
+        p.start();
+        return p.waitForFinished(-1);
+    }
+
+    return false;
+}
+
+
+bool K3b::eject( K3b::Device::Device* dev )
+{
+    if( K3b::isMounted( dev ) )
+        K3b::unmount( dev );
+
+    if ( dev->solidDevice().as<Solid::OpticalDrive>()->eject() ||
+         dev->eject() ) {
+        // to be on the safe side, especially with respect to the EmptyDiscWaiter
+        // we reset the device in the cache.
+        k3bcore->mediaCache()->resetDevice( dev );
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+K3b::Device::SpeedMultiplicator K3b::speedMultiplicatorForMediaType( K3b::Device::MediaType mediaType )
+{
+    if ( mediaType & K3b::Device::MEDIA_DVD_ALL ) {
+        return K3b::Device::SPEED_FACTOR_DVD;
+    }
+    else if ( mediaType & K3b::Device::MEDIA_BD_ALL ) {
+        return K3b::Device::SPEED_FACTOR_BD;
+    }
+    else {
+        return K3b::Device::SPEED_FACTOR_CD;
+    }
+}
+
+
+QString K3b::formatWritingSpeedFactor( int speed, K3b::Device::MediaType mediaType, SpeedFormat speedFormat )
+{
+    const int speedFactor = speedMultiplicatorForMediaType( mediaType );
+    int normalizedSpeed = speed;
+    int diff = normalizedSpeed%speedFactor;
+    if ( diff < 5 )
+        normalizedSpeed = speed-diff;
+    else if ( diff > speedFactor-5 )
+        normalizedSpeed = speed+speedFactor-diff;
+
+    // speed may be a float number. example: DVD+R(W): 2.4x
+    if ( mediaType & K3b::Device::MEDIA_DVD_ALL &&
+         normalizedSpeed%speedFactor > 0 &&
+         speedFormat != SpeedFormatInteger ) {
+         return QString::number( ( float )normalizedSpeed/( float )speedFactor, 'f', 1 );
+    }
+    else {
+        return QString::number( normalizedSpeed/speedFactor );
+    }
+}
+
+
+bool K3b::IsOverburnAllowed( const K3b::Msf& projectSize, const K3b::Msf& capacity )
+{
+    return IsOverburnAllowed( projectSize, capacity, Msf() );
+}
+
+
+bool K3b::IsOverburnAllowed( const Msf& projectSize, const Msf& capacity, const Msf& usedCapacity )
+{
+    return( k3bcore->globalSettings()->overburn() &&
+        (projectSize + usedCapacity) <= ( capacity.lba() - usedCapacity.lba() + capacity.lba() * 10 / 100 ) ); // 10% tolerance in overburn mode
+}
+
+
+QDebug& K3b::operator<<( QDebug& dbg, K3b::WritingMode mode )
+{
+    return dbg << K3b::Device::WritingMode( mode );
+}
+
+
+QDebug& K3b::operator<<( QDebug& dbg, K3b::WritingModes modes )
+{
+    return dbg << K3b::Device::WritingModes( ( int )modes );
+}
diff -rupN k3b-2.0.2/libk3b/core/k3bglobals.h k3b-2.0.2-patched/libk3b/core/k3bglobals.h
--- k3b-2.0.2/libk3b/core/k3bglobals.h	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/core/k3bglobals.h	2013-09-16 01:26:18.000000000 +0300
@@ -231,6 +231,7 @@ namespace K3b {
      * Takes care of SCSI and ATAPI.
      */
     LIBK3B_EXPORT QString externalBinDeviceParameter( Device::Device* dev, const ExternalBin* );
+    LIBK3B_EXPORT QString externalBinGenericDeviceParameter( Device::Device* dev, const ExternalBin* );
 
     /**
      * Tries to convert urls from local protocols != "file" to file (for now supports media:/)
diff -rupN k3b-2.0.2/libk3b/core/k3bglobals.h.orig k3b-2.0.2-patched/libk3b/core/k3bglobals.h.orig
--- k3b-2.0.2/libk3b/core/k3bglobals.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/core/k3bglobals.h.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,328 @@
+/*
+ *
+ * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+
+#ifndef _K3B_GLOBALS_H_
+#define _K3B_GLOBALS_H_
+
+#include <config-k3b.h>
+
+#include <QtCore/QFile>
+#include <QtCore/QString>
+#include <kio/global.h>
+#include <KUrl>
+
+#include "k3bdevicetypes.h"
+#include "k3b_export.h"
+
+#include <sys/stat.h>
+
+#ifdef HAVE_STAT64
+#define k3b_struct_stat struct stat64
+#define k3b_stat        ::stat64
+#define k3b_lstat       ::lstat64
+#else
+#define k3b_struct_stat struct stat
+#define k3b_stat        ::stat
+#define k3b_lstat       ::lstat
+#endif
+
+
+namespace K3b {
+    class ExternalBin;
+    class Msf;
+    class Version;
+    namespace Device {
+        class Device;
+    }
+
+    enum MediaSize {
+        MediaSizeCd74Min = 74*60*75,
+        MediaSizeCd80Min = 80*60*75,
+        MediaSizeCd100Min = 100*60*75,
+
+        MediaSizeDvd4Gb = 2295104,
+        MediaSizeDvd8Gb = 4173824,
+
+        // FIXME: get the proper BD sizes
+        MediaSizeBluRay25Gb = 13107200,
+        MediaSizeBluRay50Gb = 26214400
+    };
+
+    enum WritingApp {
+        WritingAppAuto = 0,
+        WritingAppCdrecord = 1,
+        WritingAppCdrdao = 2,
+        WritingAppGrowisofs = 4,
+        WritingAppDvdRwFormat = 8
+    };
+    Q_DECLARE_FLAGS( WritingApps, WritingApp )
+
+    LIBK3B_EXPORT WritingApp writingAppFromString( const QString& );
+    LIBK3B_EXPORT QString writingAppToString( WritingApp );
+
+    /**
+     * The data mode which determines the size of the user data in data
+     * CD sectors.
+     */
+    enum DataMode {
+        DataModeAuto, /**< let %K3b determine the best mode */
+        DataMode1,    /**< refers to the default Yellow book mode1 */
+        DataMode2     /**< refers to CDROM XA mode2 form1 */
+    };
+
+    /**
+     * The sector size denotes the number of bytes K3b provides per sector.
+     * This is based on the sizes cdrecord's -data, -xa, and -xamix parameters
+     * demand.
+     */
+    enum SectorSize {
+        SectorSizeAuto = 0,
+        SectorSizeAudio = 2352,
+        SectorSizeData2048 = 2048,
+        SectorSizeData2048Subheader = 2056,
+        SectorSizeData2324 = 2324,
+        SectorSizeData2324Subheader = 2332,
+        SectorSizeRaw = 2448
+    };
+
+    /**
+     * WritingModeAuto  - let K3b determine the best mode
+     * WritingModeTao   - Track at once
+     * WritingModeSao   - Disk at once (or session at once)
+     * WritingModeRaw   - Raw mode
+     *
+     * may be or'ed together (except for WritingModeAuto of course)
+     */
+    enum WritingMode {
+        WritingModeAuto = 0,
+        WritingModeTao = Device::WRITINGMODE_TAO,
+        WritingModeSao = Device::WRITINGMODE_SAO,
+        WritingModeRaw = Device::WRITINGMODE_RAW,
+        WritingModeIncrementalSequential = Device::WRITINGMODE_INCR_SEQ,  // Incremental Sequential
+        WritingModeRestrictedOverwrite = Device::WRITINGMODE_RES_OVWR // Restricted Overwrite
+    };
+    Q_DECLARE_FLAGS( WritingModes, WritingMode )
+
+    /**
+     * Unified mode for erasing/formatting of CD-RW/DVD-RW/BD-RW
+     */
+    enum FormattingMode {
+        FormattingComplete = 0,
+        FormattingQuick = 1
+    };
+
+    LIBK3B_EXPORT QString writingModeString( WritingModes );
+
+    LIBK3B_EXPORT qint16 swapByteOrder( const qint16& i );
+    LIBK3B_EXPORT qint32 swapByteOrder( const qint32& i );
+    LIBK3B_EXPORT qint64 swapByteOrder( const qint64& i );
+
+    /**
+     * This checks the free space on the filesystem path is in.
+     * We use this since we encountered problems with the KDE version.
+     * @returns true on success.
+     *
+     * \deprecated Use KDiskFreeSpaceInfo
+     */
+    LIBK3B_EXPORT bool kbFreeOnFs( const QString& path, unsigned long& size, unsigned long& avail );
+
+    /**
+     * Cut a filename preserving the extension
+     */
+    LIBK3B_EXPORT QString cutFilename( const QString& name, int len );
+
+    LIBK3B_EXPORT QString removeFilenameExtension( const QString& name );
+
+    /**
+     * Append a number to a filename preserving the extension.
+     * The resulting name's length will not exceed @p maxlen
+     */
+    LIBK3B_EXPORT QString appendNumberToFilename( const QString& name, int num, unsigned int maxlen );
+
+    LIBK3B_EXPORT QString findUniqueFilePrefix( const QString& _prefix = QString(), const QString& path = QString() );
+
+    /**
+     * Find a unique filename in directory d (if d is empty the method uses the defaultTempPath)
+     */
+    LIBK3B_EXPORT QString findTempFile( const QString& ending = QString(), const QString& d = QString() );
+
+    /**
+     * Wrapper around KStandardDirs::findExe which searches the PATH and some additional
+     * directories to find system tools which are normally only in root's PATH.
+     */
+    LIBK3B_EXPORT QString findExe( const QString& name );
+
+    /**
+     * get the default K3b temp path to store image files
+     *
+     * \sa GlobalSettings::defaultTempPath
+     */
+    LIBK3B_EXPORT QString defaultTempPath();
+
+    /**
+     * makes sure a path ends with a "/"
+     */
+    LIBK3B_EXPORT QString prepareDir( const QString& dir );
+
+    /**
+     * returns the parent dir of a path.
+     * CAUTION: this does only work well with absolut paths.
+     *
+     * Example: /usr/share/doc -> /usr/share/
+     */
+    LIBK3B_EXPORT QString parentDir( const QString& path );
+
+    /**
+     * For now this just replaces multiple occurrences of / with a single /
+     */
+    LIBK3B_EXPORT QString fixupPath( const QString& );
+
+    /**
+     * resolves a symlinks completely. Meaning it also handles links to links to links...
+     */
+    LIBK3B_EXPORT QString resolveLink( const QString& );
+
+    LIBK3B_EXPORT Version kernelVersion();
+
+    /**
+     * Kernel version stripped of all suffixes
+     */
+    LIBK3B_EXPORT Version simpleKernelVersion();
+
+    LIBK3B_EXPORT QString systemName();
+
+    LIBK3B_EXPORT KIO::filesize_t filesize( const KUrl& );
+
+    /**
+     * Calculate the total size of an image file. This also includes
+     * images splitted by a FileSplitter.
+     *
+     * \returns the total size of the image file at url
+     */
+    LIBK3B_EXPORT KIO::filesize_t imageFilesize( const KUrl& url );
+
+    /**
+     * true if the kernel supports ATAPI devices without SCSI emulation.
+     * use in combination with the ExternalProgram feature "plain-atapi"
+     */
+    LIBK3B_EXPORT bool plainAtapiSupport();
+
+    /**
+     * true if the kernel supports ATAPI devices without SCSI emulation
+     * via the ATAPI: pseudo stuff
+     * use in combination with the ExternalProgram feature "hacked-atapi"
+     */
+    LIBK3B_EXPORT bool hackedAtapiSupport();
+
+    /**
+     * Used to create a parameter for cdrecord, cdrdao or readcd.
+     * Takes care of SCSI and ATAPI.
+     */
+    LIBK3B_EXPORT QString externalBinDeviceParameter( Device::Device* dev, const ExternalBin* );
+
+    /**
+     * Tries to convert urls from local protocols != "file" to file (for now supports media:/)
+     */
+    LIBK3B_EXPORT KUrl convertToLocalUrl( const KUrl& url );
+    LIBK3B_EXPORT KUrl::List convertToLocalUrls( const KUrl::List& l );
+
+    LIBK3B_EXPORT qint16 fromLe16( char* );
+    LIBK3B_EXPORT qint32 fromLe32( char* );
+    LIBK3B_EXPORT qint64 fromLe64( char* );
+
+    LIBK3B_EXPORT bool isMounted( Device::Device* );
+
+    /**
+     * Tries to unmount the device ignoring its actual mounting state.
+     * This method uses both KIO::unmount and pumount if available.
+     */
+    LIBK3B_EXPORT bool unmount( Device::Device* );
+
+    /**
+     * Tries to mount the medium. Since K3b does not gather any information
+     * about mount points the only methods used are pmount and HAL::mount
+     */
+    LIBK3B_EXPORT bool mount( Device::Device* );
+
+    /**
+     * Ejects the medium in the device or simply opens the tray.
+     * This method improves over Device::Device::eject in that it
+     * unmounts before ejecting and introduces HAL support.
+     *
+     * It also makes sure the MediaCache is up to date. This is very
+     * important in case one uses the EmptyDiscWaiter directly after
+     * ejecting. If the MediaCache would not be updated, it might still
+     * contain the old media information.
+     *
+     * \sa MediaCache::reset
+     */
+    LIBK3B_EXPORT bool eject( Device::Device* );
+
+    /**
+     * Get the speed multiplicator for a media type.
+     * \sa K3b::Device::SpeedMultiplicator
+     */
+    LIBK3B_EXPORT K3b::Device::SpeedMultiplicator speedMultiplicatorForMediaType( K3b::Device::MediaType mediaType );
+
+    /**
+     * Describes format of writing speed produced by formatWritingSpeedFactor function.
+     * \sa K3b::formatWritingSpeedFactor
+     */
+    enum SpeedFormat {
+        SpeedFormatInteger, /**< Format as integer number */
+        SpeedFormatReal     /**< Format as real number (integer or fraction) */
+    };
+
+    /**
+     * Create a string representation of the speed factor to be used in command line
+     * commands like cdrecord and growisofs.
+     *
+     * \param speed The speed in KB/s
+     * \param mediaType The media type that is going to be written. This is used to
+     * determine the multiplicator factor.
+     * \param speedFormat specifies format of speed value. E.g. cdrecord only accepts
+     * integral speed values, in that case SpeedFormatInteger can be used.
+     *
+     * This method takes small variances into account and rounds them properly. Also
+     * the "weird" burn speeds like 2.4 are handled.
+     */
+    LIBK3B_EXPORT QString
+    formatWritingSpeedFactor( int speed, K3b::Device::MediaType mediaType, SpeedFormat speedFormat = SpeedFormatReal );
+
+    /**
+     * Checks if overburn can be performed taking into consideration
+     * project size and 'overburn' setting in GlobalSettings.
+     * \param projectSize Size of project to be written
+     * \param capacity Declared capacity of a medium
+     */
+    LIBK3B_EXPORT bool IsOverburnAllowed( const Msf& projectSize, const Msf& capacity );
+
+    /**
+     * Checks if overburn can be performed taking into consideration
+     * project size, size of data already written to disk and 'overburn' setting in GlobalSettings.
+     * \param projectSize Size of project to be written
+     * \param capacity Declared capacity of a medium
+     * \param usedCapacity Size of the used part of a medium
+     */
+    LIBK3B_EXPORT bool IsOverburnAllowed( const Msf& projectSize, const Msf& capacity, const Msf& usedCapacity );
+
+    QDebug& operator<<( QDebug& dbg, WritingMode );
+    QDebug& operator<<( QDebug& dbg, WritingModes );
+}
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(K3b::WritingApps)
+Q_DECLARE_OPERATORS_FOR_FLAGS(K3b::WritingModes)
+
+#endif
diff -rupN k3b-2.0.2/libk3b/projects/k3bcdrecordwriter.cpp k3b-2.0.2-patched/libk3b/projects/k3bcdrecordwriter.cpp
--- k3b-2.0.2/libk3b/projects/k3bcdrecordwriter.cpp	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/projects/k3bcdrecordwriter.cpp	2013-09-16 01:26:26.000000000 +0300
@@ -228,7 +228,11 @@ bool K3b::CdrecordWriter::prepareProcess
         d->process << "gracetime=2";  // 2 is the lowest allowed value (Joerg, why do you do this to us?)
 
     // Again we assume the device to be set!
+#if defined(Q_OS_FREEBSD)
+    d->process << QString("dev=%1").arg(K3b::externalBinGenericDeviceParameter(burnDevice(), d->cdrecordBinObject));
+#else
     d->process << QString("dev=%1").arg(K3b::externalBinDeviceParameter(burnDevice(), d->cdrecordBinObject));
+#endif
 
     d->usedSpeedFactor = K3b::speedMultiplicatorForMediaType( d->burnedMediaType );
     d->usedSpeed = burnSpeed();
diff -rupN k3b-2.0.2/libk3b/projects/k3bcdrecordwriter.cpp.orig k3b-2.0.2-patched/libk3b/projects/k3bcdrecordwriter.cpp.orig
--- k3b-2.0.2/libk3b/projects/k3bcdrecordwriter.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/projects/k3bcdrecordwriter.cpp.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,953 @@
+/*
+ *
+ * Copyright (C) 2003-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include <config-k3b.h>
+
+#include "k3bcdrecordwriter.h"
+
+#include "k3bcore.h"
+#include "k3bexternalbinmanager.h"
+#include "k3bprocess.h"
+#include "k3bdevice.h"
+#include "k3bdeviceglobals.h"
+#include "k3bdevicemanager.h"
+#include "k3bdevicehandler.h"
+#include "k3bglobals.h"
+#include "k3bthroughputestimator.h"
+#include "k3bglobalsettings.h"
+
+#include <qstring.h>
+#include <qstringlist.h>
+#include <qregexp.h>
+#include <qfile.h>
+
+#include <klocale.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <ktemporaryfile.h>
+
+
+Q_DECLARE_METATYPE( QProcess::ExitStatus )
+
+
+class K3b::CdrecordWriter::Private
+{
+public:
+    Private()
+        : cdTextFile(0) {
+    }
+
+    const ExternalBin* cdrecordBinObject;
+    Process process;
+
+    WritingMode writingMode;
+    FormattingMode formattingMode;
+    bool totalTracksParsed;
+    bool clone;
+    bool cue;
+    bool multi;
+    bool force;
+    bool formatting;
+
+    QString cueFile;
+    QStringList arguments;
+
+    int currentTrack;
+    int totalTracks;
+    int totalSize;
+    int alreadyWritten;
+
+    int lastFifoValue;
+
+    int cdrecordError;
+    bool writingStarted;
+
+    QByteArray rawCdText;
+
+    K3b::ThroughputEstimator* speedEst;
+    bool canceled;
+    bool usingBurnfree;
+    int usedSpeed;
+
+    struct Track {
+        int size;
+        bool audio;
+    };
+
+    QList<Track> tracks;
+
+    QTemporaryFile* cdTextFile;
+
+    Device::MediaType burnedMediaType;
+    K3b::Device::SpeedMultiplicator usedSpeedFactor;
+};
+
+
+K3b::CdrecordWriter::CdrecordWriter( K3b::Device::Device* dev, K3b::JobHandler* hdl,
+                                      QObject* parent )
+    : K3b::AbstractWriter( dev, hdl, parent )
+{
+    d = new Private();
+    d->speedEst = new K3b::ThroughputEstimator( this );
+    connect( d->speedEst, SIGNAL(throughput(int)),
+             this, SLOT(slotThroughput(int)) );
+
+    d->writingMode = K3b::WritingModeTao;
+    d->formattingMode = K3b::FormattingQuick;
+    d->clone = false;
+    d->cue = false;
+    d->multi = false;
+    d->force = false;
+    d->formatting = false;
+
+    d->process.setSplitStdout(true);
+    d->process.setSuppressEmptyLines(true);
+    d->process.setFlags( K3bQProcess::RawStdin );
+    connect( &d->process, SIGNAL(stdoutLine(const QString&)), this, SLOT(slotStdLine(const QString&)) );
+
+    // we use a queued connection to give the process object time to wrap up and return to a correct state
+    qRegisterMetaType<QProcess::ExitStatus>();
+    connect( &d->process, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(slotProcessExited(int, QProcess::ExitStatus)), Qt::QueuedConnection );
+}
+
+
+K3b::CdrecordWriter::~CdrecordWriter()
+{
+    delete d->cdTextFile;
+    delete d;
+}
+
+
+bool K3b::CdrecordWriter::active() const
+{
+    return d->process.isRunning();
+}
+
+
+QIODevice* K3b::CdrecordWriter::ioDevice() const
+{
+    return &d->process;
+}
+
+
+bool K3b::CdrecordWriter::closeFd()
+{
+    if ( d->process.isRunning() ) {
+        d->process.closeWriteChannel();
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+void K3b::CdrecordWriter::setDao( bool b )
+{
+    d->writingMode = ( b ? K3b::WritingModeSao : K3b::WritingModeTao );
+}
+
+
+void K3b::CdrecordWriter::setCueFile( const QString& s)
+{
+    d->cue = true;
+    d->cueFile = s;
+
+    // cuefile only works in DAO mode
+    setWritingMode( K3b::WritingModeSao );
+}
+
+
+void K3b::CdrecordWriter::setClone( bool b )
+{
+    d->clone = b;
+}
+
+
+void K3b::CdrecordWriter::setRawCdText( const QByteArray& a )
+{
+    d->rawCdText = a;
+}
+
+
+void K3b::CdrecordWriter::setWritingMode( K3b::WritingMode mode )
+{
+    d->writingMode = mode;
+}
+
+
+void K3b::CdrecordWriter::setFormattingMode( FormattingMode mode )
+{
+    d->formattingMode = mode;
+    d->formatting = true;
+}
+
+
+void K3b::CdrecordWriter::setMulti( bool b )
+{
+    d->multi = b;
+}
+
+
+void K3b::CdrecordWriter::setForce( bool b )
+{
+    d->force = b;
+}
+
+
+bool K3b::CdrecordWriter::prepareProcess()
+{
+    d->cdrecordBinObject = k3bcore->externalBinManager()->binObject("cdrecord");
+
+    if( !d->cdrecordBinObject ) {
+        emit infoMessage( i18n("Could not find %1 executable.", QLatin1String("cdrecord")), MessageError );
+        return false;
+    }
+
+    d->process.clearProgram();
+
+    d->burnedMediaType = burnDevice()->mediaType();
+
+    d->process << d->cdrecordBinObject;
+
+    // display progress
+    d->process << "-v";
+
+    if( d->cdrecordBinObject->hasFeature( "gracetime") )
+        d->process << "gracetime=2";  // 2 is the lowest allowed value (Joerg, why do you do this to us?)
+
+    // Again we assume the device to be set!
+    d->process << QString("dev=%1").arg(K3b::externalBinDeviceParameter(burnDevice(), d->cdrecordBinObject));
+
+    d->usedSpeedFactor = K3b::speedMultiplicatorForMediaType( d->burnedMediaType );
+    d->usedSpeed = burnSpeed();
+    if( d->usedSpeed == 0 ) {
+        // try to determine the writeSpeed
+        // if it fails determineMaximalWriteSpeed() will return 0 and
+        // the choice is left to cdrecord
+        d->usedSpeed = burnDevice()->determineMaximalWriteSpeed();
+    }
+
+    if( d->usedSpeed != 0 )
+        d->process << QString("speed=%1").arg( formatWritingSpeedFactor( d->usedSpeed, d->burnedMediaType, SpeedFormatInteger ) );
+
+
+    if ( K3b::Device::isBdMedia( d->burnedMediaType ) ) {
+        if ( !d->cdrecordBinObject->hasFeature( "blu-ray" ) ) {
+            emit infoMessage( i18n( "Cdrecord version %1 does not support Blu-ray writing." ,d->cdrecordBinObject->version ), MessageError );
+            // FIXME: add a way to fail the whole thing here
+        }
+        d->process << "-sao";
+    }
+    else if ( K3b::Device::isDvdMedia( d->burnedMediaType ) ) {
+        // cdrecord only supports SAO for DVD
+        d->process << "-sao";
+
+
+#ifdef __GNUC__
+#warning Enable layer jump mode: add it to K3b::WritingMode and to the GUI
+#endif
+        // if( d->writingMode == Device::WRITINGMODE_LAYER_JUMP ) {
+//             d->process << "-driveropts=layerbreak";
+//         }
+    }
+    else if( K3b::Device::isCdMedia( d->burnedMediaType ) ) {
+        if( d->writingMode == K3b::WritingModeSao || d->cue ) {
+            if( burnDevice()->dao() )
+                d->process << "-sao";
+            else {
+                if( d->cdrecordBinObject->hasFeature( "tao" ) )
+                    d->process << "-tao";
+                emit infoMessage( i18n("Writer does not support disk at once (DAO) recording"), MessageWarning );
+            }
+        }
+        else if( d->writingMode == K3b::WritingModeRaw ) {
+            if( burnDevice()->supportsWritingMode( K3b::Device::WRITINGMODE_RAW_R96R ) )
+                d->process << "-raw96r";
+            else if( burnDevice()->supportsWritingMode( K3b::Device::WRITINGMODE_RAW_R16 ) )
+                d->process << "-raw16";
+            else if( burnDevice()->supportsWritingMode( K3b::Device::WRITINGMODE_RAW_R96P ) )
+                d->process << "-raw96p";
+            else {
+                emit infoMessage( i18n("Writer does not support raw writing."), MessageWarning );
+                if( d->cdrecordBinObject->hasFeature( "tao" ) )
+                    d->process << "-tao";
+            }
+        }
+        else if( d->cdrecordBinObject->hasFeature( "tao" ) )
+            d->process << "-tao";
+    }
+    else {
+        emit infoMessage( i18n( "Cdrecord does not support writing %1 media." , K3b::Device::mediaTypeString( d->burnedMediaType ) ), MessageError );
+        // FIXME: add a way to fail the whole thing here
+    }
+
+    if( simulate() )
+        d->process << "-dummy";
+
+    d->usingBurnfree = false;
+    if( k3bcore->globalSettings()->burnfree() ) {
+        if( burnDevice()->burnproof() ) {
+
+            d->usingBurnfree = true;
+
+            // with cdrecord 1.11a02 burnproof was renamed to burnfree
+            if( d->cdrecordBinObject->hasFeature( "burnproof" ) )
+                d->process << "driveropts=burnproof";
+            else
+                d->process << "driveropts=burnfree";
+        }
+        else
+            emit infoMessage( i18n("Writer does not support buffer underrun free recording (Burnfree)"), MessageWarning );
+    }
+
+    if( k3bcore->globalSettings()->force() || d->force ) {
+        d->process << "-force";
+        emit infoMessage( i18n("'Force unsafe operations' enabled."), MessageWarning );
+    }
+
+    if( d->cue ) {
+        d->process.setWorkingDirectory( d->cueFile );
+        d->process << QString("cuefile=%1").arg( d->cueFile );
+    }
+
+    if( d->clone )
+        d->process << "-clone";
+
+    if( d->multi )
+        d->process << "-multi";
+
+    if( d->formatting ) {
+        switch( d->formattingMode ) {
+            case FormattingComplete:
+                d->process << "blank=all";
+                break;
+            case FormattingQuick:
+                d->process << "blank=fast";
+                break;
+        }
+    }
+
+    if( d->rawCdText.size() > 0 ) {
+        delete d->cdTextFile;
+        // yes, we do want to use QTemporaryFile and not KTemporaryFile because cdrecord
+        // might be started suid root and the KDE tmp might be on an nfs mounted partition
+        // (Mandriva for example uses ~/tmp)
+        d->cdTextFile = new QTemporaryFile();
+        if ( !d->cdTextFile->open() ||
+             d->cdTextFile->write( d->rawCdText ) != d->rawCdText.size() ||
+            !d->cdTextFile->flush() ) {
+            emit infoMessage( i18n( "Failed to write temporary file '%1'", d->cdTextFile->fileName() ), MessageError );
+            return false;
+        }
+        d->process << "textfile=" + d->cdTextFile->fileName();
+    }
+
+    bool manualBufferSize = k3bcore->globalSettings()->useManualBufferSize();
+    if( manualBufferSize ) {
+        d->process << QString("fs=%1m").arg( k3bcore->globalSettings()->bufferSize() );
+    }
+
+    bool overburn = k3bcore->globalSettings()->overburn();
+    if( overburn ) {
+        if( d->cdrecordBinObject->hasFeature("overburn") ) {
+            if ( k3bcore->globalSettings()->force() )
+                d->process << "-ignsize";
+            else
+                d->process << "-overburn";
+        }
+        else {
+            emit infoMessage( i18n("Cdrecord %1 does not support overburning.",d->cdrecordBinObject->version), MessageWarning );
+        }
+    }
+
+    // additional user parameters from config
+    const QStringList& params = d->cdrecordBinObject->userParameters();
+    for( QStringList::const_iterator it = params.constBegin(); it != params.constEnd(); ++it )
+        d->process << *it;
+
+    // add the user parameters
+    for( QStringList::const_iterator it = d->arguments.constBegin(); it != d->arguments.constEnd(); ++it )
+        d->process << *it;
+
+    return true;
+}
+
+
+K3b::CdrecordWriter* K3b::CdrecordWriter::addArgument( const QString& arg )
+{
+    d->arguments.append( arg );
+    return this;
+}
+
+
+void K3b::CdrecordWriter::clearArguments()
+{
+    d->arguments.clear();
+}
+
+
+void K3b::CdrecordWriter::start()
+{
+    jobStarted();
+
+    d->canceled = false;
+    d->speedEst->reset();
+    d->writingStarted = false;
+
+    if ( !prepareProcess() ) {
+        jobFinished(false);
+        return;
+    }
+
+    emit debuggingOutput( QLatin1String( "Used versions" ), QLatin1String( "cdrecord: " ) + d->cdrecordBinObject->version );
+
+    if( !d->cdrecordBinObject->copyright.isEmpty() )
+        emit infoMessage( i18n("Using %1 %2 - Copyright (C) %3"
+                               ,(d->cdrecordBinObject->hasFeature( "wodim" ) ? "Wodim" : "Cdrecord" )
+                               ,d->cdrecordBinObject->version
+                               ,d->cdrecordBinObject->copyright), MessageInfo );
+
+
+    kDebug() << "***** " << d->cdrecordBinObject->name() << " parameters:\n";
+    QString s = d->process.joinedArgs();
+    kDebug() << s << flush;
+    emit debuggingOutput( d->cdrecordBinObject->name() + " command:", s);
+
+    d->currentTrack = 0;
+    d->cdrecordError = UNKNOWN;
+    d->totalTracksParsed = false;
+    d->alreadyWritten = 0;
+    d->tracks.clear();
+    d->totalSize = 0;
+
+    emit newSubTask( i18n("Preparing write process...") );
+
+    // FIXME: check the return value
+    if( K3b::isMounted( burnDevice() ) ) {
+        emit infoMessage( i18n("Unmounting medium"), MessageInfo );
+        K3b::unmount( burnDevice() );
+    }
+
+    // block the device (including certain checks)
+    k3bcore->blockDevice( burnDevice() );
+
+    // lock the device for good in this process since it will
+    // be opened in the cdrecord process
+    burnDevice()->close();
+    burnDevice()->usageLock();
+
+    if( !d->process.start( KProcess::MergedChannels ) ) {
+        // something went wrong when starting the program
+        // it "should" be the executable
+        kDebug() << "(K3b::CdrecordWriter) could not start " << d->cdrecordBinObject->name();
+        emit infoMessage( i18n("Could not start %1.",d->cdrecordBinObject->name()), K3b::Job::MessageError );
+        jobFinished(false);
+    }
+    else {
+        const QString formattedSpeed = formatWritingSpeedFactor( d->usedSpeed, d->burnedMediaType, SpeedFormatInteger );
+        const QString formattedMode = writingModeString( d->writingMode );
+        // FIXME: these messages should also take DVD into account.
+        if( simulate() ) {
+            emit newTask( i18n("Simulating") );
+            if ( d->burnedMediaType & Device::MEDIA_DVD_PLUS_ALL )
+                // xgettext: no-c-format
+                emit infoMessage( i18n("Starting simulation at %1x speed...", formattedSpeed ), Job::MessageInfo );
+            else
+                emit infoMessage( i18n("Starting %1 simulation at %2x speed...", formattedMode, formattedSpeed ), Job::MessageInfo );
+        }
+        else {
+            emit newTask( i18n("Writing") );
+            if ( d->burnedMediaType & Device::MEDIA_DVD_PLUS_ALL )
+                // xgettext: no-c-format
+                emit infoMessage( i18n("Starting writing at %1x speed...", formattedSpeed ), Job::MessageInfo );
+            else
+                emit infoMessage( i18n("Starting %1 writing at %2x speed...", formattedMode, formattedSpeed ), Job::MessageInfo );
+        }
+    }
+}
+
+
+void K3b::CdrecordWriter::cancel()
+{
+    if( active() ) {
+        d->canceled = true;
+        if( d->process.isRunning() )
+            d->process.terminate();
+    }
+}
+
+
+void K3b::CdrecordWriter::slotStdLine( const QString& line )
+{
+    static QRegExp s_burnfreeCounterRx( "^BURN\\-Free\\swas\\s(\\d+)\\stimes\\sused" );
+    static QRegExp s_burnfreeCounterRxPredict( "^Total\\sof\\s(\\d+)\\s\\spossible\\sbuffer\\sunderruns\\spredicted" );
+
+    // tracknumber: cap(1)
+    // done: cap(2)
+    // complete: cap(3)
+    // fifo: cap(4)  (it seems as if some patched cdrecord versions do not emit the fifo info but only the buf... :(
+    // buffer: cap(5)
+    static QRegExp s_progressRx( "Track\\s(\\d\\d)\\:\\s*(\\d*)\\sof\\s*(\\d*)\\sMB\\swritten\\s(?:\\(fifo\\s*(\\d*)\\%\\)\\s*)?(?:\\[buf\\s*(\\d*)\\%\\])?.*" );
+
+    emit debuggingOutput( d->cdrecordBinObject->name(), line );
+
+    //
+    // Progress and toc parsing
+    //
+
+    if( line.startsWith( "Track " ) ) {
+        if( !d->totalTracksParsed ) {
+            // this is not the progress display but the list of tracks that will get written
+            // we always extract the tracknumber to get the highest at last
+            bool ok;
+            int tt = line.mid( 6, 2 ).toInt(&ok);
+
+            if( ok ) {
+                struct Private::Track track;
+                track.audio  = ( line.mid( 10, 5 ) == "audio" );
+
+                d->totalTracks = tt;
+
+                int sizeStart = line.indexOf( QRegExp("\\d"), 10 );
+                int sizeEnd = line.indexOf( "MB", sizeStart );
+                track.size = line.mid( sizeStart, sizeEnd-sizeStart ).toInt(&ok);
+
+                if( ok ) {
+                    d->tracks.append(track);
+                    d->totalSize += track.size;
+                }
+                else
+                    kDebug() << "(K3b::CdrecordWriter) track number parse error: "
+                             << line.mid( sizeStart, sizeEnd-sizeStart );
+            }
+            else
+                kDebug() << "(K3b::CdrecordWriter) track number parse error: "
+                         << line.mid( 6, 2 );
+        }
+
+        else if( s_progressRx.exactMatch( line ) ) {
+            //      int num = s_progressRx.cap(1).toInt();
+            int made = s_progressRx.cap(2).toInt();
+            int size = s_progressRx.cap(3).toInt();
+            int fifo = s_progressRx.cap(4).toInt();
+
+            emit buffer( fifo );
+            d->lastFifoValue = fifo;
+
+            if( s_progressRx.numCaptures() > 4 )
+                emit deviceBuffer( s_progressRx.cap(5).toInt() );
+
+            //
+            // cdrecord's output sucks a bit.
+            // we get track sizes that differ from the sizes in the progress
+            // info since these are dependant on the writing mode.
+            // so we just use the track sizes and do a bit of math...
+            //
+
+            if( d->tracks.count() > d->currentTrack-1 && size > 0 ) {
+                double convV = (double)d->tracks[d->currentTrack-1].size/(double)size;
+                made = (int)((double)made * convV);
+                size = d->tracks[d->currentTrack-1].size;
+            }
+            else {
+                kError() << "(K3b::CdrecordWriter) Did not parse all tracks sizes!" << endl;
+            }
+
+            if( !d->writingStarted ) {
+                d->writingStarted = true;
+                emit newSubTask( i18n("Writing data") );
+            }
+
+            if( size > 0 ) {
+                emit processedSubSize( made, size );
+                emit subPercent( 100*made/size );
+            }
+
+            if( d->totalSize > 0 ) {
+                emit processedSize( d->alreadyWritten+made, d->totalSize );
+                emit percent( 100*(d->alreadyWritten+made)/d->totalSize );
+            }
+
+            d->speedEst->dataWritten( (d->alreadyWritten+made)*1024 );
+        }
+    }
+
+    //
+    // Cdrecord starts all error and warning messages with it's path
+    // With Debian's script it starts with cdrecord (or /usr/bin/cdrecord or whatever! I hate this script!)
+    //
+
+    else if( line.startsWith( "cdrecord" ) ||
+             line.startsWith( d->cdrecordBinObject->path ) ||
+             line.startsWith( d->cdrecordBinObject->path.left(d->cdrecordBinObject->path.length()-5) ) ) {
+        // get rid of the path and the following colon and space
+        QString errStr = line.mid( line.indexOf(':') + 2 );
+
+        if( errStr.startsWith( "Drive does not support SAO" ) ) {
+            emit infoMessage( i18n("DAO (Disk At Once) recording not supported with this writer"), K3b::Job::MessageError );
+            emit infoMessage( i18n("Please choose TAO (Track At Once) and try again"), K3b::Job::MessageError );
+        }
+        else if( errStr.startsWith( "Drive does not support RAW" ) ) {
+            emit infoMessage( i18n("RAW recording not supported with this writer"), K3b::Job::MessageError );
+        }
+        else if( errStr.startsWith("Input/output error.") ) {
+            emit infoMessage( i18n("Input/output error. Not necessarily serious."), MessageWarning );
+        }
+        else if( errStr.startsWith("shmget failed") ) {
+            d->cdrecordError = SHMGET_FAILED;
+        }
+        else if( errStr.startsWith("OPC failed") ) {
+            d->cdrecordError = OPC_FAILED;
+        }
+        else if( errStr.startsWith( "Drive needs to reload the media" ) ) {
+            emit infoMessage( i18n("Reloading of medium required"), K3b::Job::MessageInfo );
+        }
+        else if( errStr.startsWith( "The current problem looks like a buffer underrun" ) ) {
+            if( d->cdrecordError == UNKNOWN ) // it is almost never a buffer underrun these days.
+                d->cdrecordError = BUFFER_UNDERRUN;
+        }
+        else if( errStr.startsWith("MessageWarning: Data may not fit") ) {
+            bool overburn = k3bcore->globalSettings()->overburn();
+            if( overburn && d->cdrecordBinObject->hasFeature("overburn") )
+                emit infoMessage( i18n("Trying to write more than the official disk capacity"), K3b::Job::MessageWarning );
+            d->cdrecordError = OVERSIZE;
+        }
+        else if( errStr.startsWith("Bad Option") ) {
+            d->cdrecordError = BAD_OPTION;
+            // parse option
+            int pos = line.indexOf( "Bad Option" ) + 12;
+            int len = line.length() - pos - 1;
+            emit infoMessage( i18n("No valid %1 option: %2",d->cdrecordBinObject->name(),line.mid(pos, len)),
+                              MessageError );
+        }
+        else if( errStr.startsWith("Cannot set speed/dummy") ) {
+            d->cdrecordError = CANNOT_SET_SPEED;
+        }
+        else if( errStr.startsWith("Cannot open new session") ) {
+            d->cdrecordError = CANNOT_OPEN_NEW_SESSION;
+        }
+        else if( errStr.startsWith("Cannot send CUE sheet") ) {
+            d->cdrecordError = CANNOT_SEND_CUE_SHEET;
+        }
+        else if( errStr.startsWith( "Trying to use ultra high speed" ) ||
+                 errStr.startsWith( "Trying to use high speed" ) ||
+                 errStr.startsWith( "Probably trying to use ultra high speed" ) ||
+                 errStr.startsWith( "You did use a high speed medium on an improper writer" ) ||
+                 errStr.startsWith( "You did use a ultra high speed medium on an improper writer" ) ) {
+            d->cdrecordError = HIGH_SPEED_MEDIUM;
+        }
+        else if( errStr.startsWith( "You may have used an ultra low speed medium" ) ) {
+            d->cdrecordError = LOW_SPEED_MEDIUM;
+        }
+        else if( errStr.startsWith( "Permission denied. Cannot open" ) ||
+                 errStr.startsWith( "Operation not permitted." ) ) {
+            d->cdrecordError = PERMISSION_DENIED;
+        }
+        else if( errStr.startsWith( "Can only copy session # 1") ) {
+            emit infoMessage( i18n("Only session 1 will be cloned."), MessageWarning );
+        }
+        else if( errStr == "Cannot fixate disk." ) {
+            emit infoMessage( i18n("Unable to fixate the disk."), MessageError );
+            if( d->cdrecordError == UNKNOWN )
+                d->cdrecordError = CANNOT_FIXATE_DISK;
+        }
+        else if( errStr == "A write error occurred." ) {
+            d->cdrecordError = WRITE_ERROR;
+        }
+        else if( errStr.startsWith( "Try again with cdrecord blank=all." ) ) {
+            d->cdrecordError = BLANK_FAILED;
+        }
+        else if( errStr.startsWith( "faio_wait_on_buffer for reader timed out" ) ) {
+            d->cdrecordError = SHORT_READ;
+        }
+    }
+
+    //
+    // All other messages
+    //
+
+    else if( line.contains( "at speed" ) ) {
+        // parse the speed and inform the user if cdrdao switched it down
+        const int pos = line.indexOf( "at speed" );
+        const int pos2 = line.indexOf( "in", pos+9 );
+        const int speed( double( K3b::speedMultiplicatorForMediaType( d->burnedMediaType ) ) * line.mid( pos+9, pos2-pos-10 ).toDouble() );  // cdrecord-dvd >= 2.01a25 uses 8.0 and stuff
+        if( speed > 0 && double( qAbs( speed - d->usedSpeed ) ) > 0.5*double( K3b::speedMultiplicatorForMediaType( d->burnedMediaType ) ) ) {
+            // xgettext: no-c-format
+            emit infoMessage( i18n("Medium or burner does not support writing at %1x speed", formatWritingSpeedFactor( d->usedSpeed, d->burnedMediaType ) ),
+                              K3b::Job::MessageWarning );
+            if( speed > d->usedSpeed )
+                // xgettext: no-c-format
+                emit infoMessage( i18n("Switching burn speed up to %1x", formatWritingSpeedFactor( speed, d->burnedMediaType ) ), K3b::Job::MessageWarning );
+            else
+                // xgettext: no-c-format
+                emit infoMessage( i18n("Switching burn speed down to %1x", formatWritingSpeedFactor( speed, d->burnedMediaType ) ), K3b::Job::MessageWarning );
+        }
+    }
+    else if( line.startsWith( "Starting new" ) ) {
+        d->totalTracksParsed = true;
+        if( d->currentTrack > 0 ) {// nothing has been written at the start of track 1
+            if( d->tracks.count() > d->currentTrack-1 )
+                d->alreadyWritten += d->tracks[d->currentTrack-1].size;
+            else
+                kError() << "(K3b::CdrecordWriter) Did not parse all tracks sizes!";
+        }
+        else
+            emit infoMessage( i18n("Starting disc write"), MessageInfo );
+
+        d->currentTrack++;
+
+        if( d->currentTrack > d->tracks.count() ) {
+            kDebug() << "(K3b::CdrecordWriter) need to add dummy track struct.";
+            struct Private::Track t;
+            t.size = 1;
+            t.audio = false;
+            d->tracks.append(t);
+        }
+
+        kDebug() << "(K3b::CdrecordWriter) writing track " << d->currentTrack << " of " << d->totalTracks << " tracks.";
+        emit nextTrack( d->currentTrack, d->totalTracks );
+    }
+    else if( line.startsWith( "Fixating" ) ) {
+        emit newSubTask( i18n("Closing Session") );
+    }
+    else if( line.startsWith( "Writing lead-in" ) ) {
+        d->totalTracksParsed = true;
+        emit newSubTask( i18n("Writing Leadin") );
+    }
+    else if( line.startsWith( "Writing Leadout") ) {
+        emit newSubTask( i18n("Writing Leadout") );
+    }
+    else if( line.startsWith( "Writing pregap" ) ) {
+        emit newSubTask( i18n("Writing pregap") );
+    }
+    else if( line.startsWith( "Performing OPC" ) ) {
+        emit infoMessage( i18n("Performing Optimum Power Calibration"), K3b::Job::MessageInfo );
+    }
+    else if( line.startsWith( "Sending" ) ) {
+        emit infoMessage( i18n("Sending CUE sheet"), K3b::Job::MessageInfo );
+    }
+    else if( line.startsWith( "Turning BURN-Free on" ) || line.startsWith( "BURN-Free is ON") ) {
+        emit infoMessage( i18n("Enabled Burnfree"), K3b::Job::MessageInfo );
+    }
+    else if( line.startsWith( "Turning BURN-Free off" ) ) {
+        emit infoMessage( i18n("Disabled Burnfree"), K3b::Job::MessageWarning );
+    }
+    else if( line.startsWith( "Re-load disk and hit" ) ) {
+        // this happens on some notebooks where cdrecord is not able to close the
+        // tray itself, so we need to ask the user to do so
+        blockingInformation( i18n("Please reload the medium and press 'ok'"),
+                             i18n("Unable to close the tray") );
+
+        // now send a <CR> to cdrecord
+        // hopefully this will do it since I have no possibility to test it!
+        d->process.write( "\n", 1 );
+    }
+    else if( s_burnfreeCounterRx.indexIn( line ) ) {
+        bool ok;
+        int num = s_burnfreeCounterRx.cap(1).toInt(&ok);
+        if( ok )
+            emit infoMessage( i18np("Burnfree was used once.", "Burnfree was used %1 times.", num), MessageInfo );
+    }
+    else if( s_burnfreeCounterRxPredict.indexIn( line ) ) {
+        bool ok;
+        int num = s_burnfreeCounterRxPredict.cap(1).toInt(&ok);
+        if( ok )
+            emit infoMessage( i18np("Buffer was low once.", "Buffer was low %1 times.", num), MessageInfo );
+    }
+    else if( line.contains("Medium Error") ) {
+        d->cdrecordError = MEDIUM_ERROR;
+    }
+    else if( line.startsWith( "Error trying to open" ) && line.contains( "(Device or resource busy)" ) ) {
+        d->cdrecordError = DEVICE_BUSY;
+    }
+    else {
+        // debugging
+        kDebug() << "(" << d->cdrecordBinObject->name() << ") " << line;
+    }
+}
+
+
+void K3b::CdrecordWriter::slotProcessExited( int exitCode, QProcess::ExitStatus exitStatus )
+{
+    // remove temporary cdtext file
+    delete d->cdTextFile;
+    d->cdTextFile = 0;
+
+    // release the device within this process
+    burnDevice()->usageUnlock();
+
+    // unblock the device
+    k3bcore->unblockDevice( burnDevice() );
+
+    if( d->canceled ) {
+        // this will unblock and eject the drive and emit the finished/canceled signals
+        K3b::AbstractWriter::cancel();
+        return;
+    }
+
+
+    if( exitStatus == QProcess::NormalExit ) {
+        switch( exitCode ) {
+        case 0:
+        {
+            if( d->formatting )
+                emit infoMessage( i18n("Erasing successfully completed"), K3b::Job::MessageSuccess );
+            else if( simulate() )
+                emit infoMessage( i18n("Simulation successfully completed"), K3b::Job::MessageSuccess );
+            else
+                emit infoMessage( i18n("Writing successfully completed"), K3b::Job::MessageSuccess );
+
+            if( !d->formatting ) {
+                int s = d->speedEst->average();
+                emit infoMessage( ki18n("Average overall write speed: %1 KB/s (%2x)" )
+                                  .subs( s ).subs( ( double )s/( double )d->usedSpeedFactor, 0, 'g', 2 ).toString(),
+                                  MessageInfo );
+            }
+
+            jobFinished( true );
+        }
+        break;
+
+        default:
+            kDebug() << "(K3b::CdrecordWriter) error: " << exitCode;
+
+            if( d->cdrecordError == UNKNOWN && d->lastFifoValue <= 3 )
+                d->cdrecordError = BUFFER_UNDERRUN;
+
+            switch( d->cdrecordError ) {
+            case OVERSIZE:
+                if( k3bcore->globalSettings()->overburn() &&
+                    d->cdrecordBinObject->hasFeature("overburn") )
+                    emit infoMessage( i18n("Data did not fit on disk."), MessageError );
+                else {
+                    emit infoMessage( i18n("Data does not fit on disk."), MessageError );
+                    if( d->cdrecordBinObject->hasFeature("overburn") )
+                        emit infoMessage( i18n("Enable overburning in the advanced K3b settings to burn anyway."), MessageInfo );
+                }
+                break;
+            case BAD_OPTION:
+                // error message has already been emitted earlier since we needed the actual line
+                break;
+            case SHMGET_FAILED:
+                emit infoMessage( i18n("%1 could not reserve shared memory segment of requested size.",d->cdrecordBinObject->name()), MessageError );
+                emit infoMessage( i18n("Probably you chose a too large buffer size."), MessageError );
+                break;
+            case OPC_FAILED:
+                emit infoMessage( i18n("OPC failed. Probably the writer does not like the medium."), MessageError );
+                break;
+            case CANNOT_SET_SPEED:
+                emit infoMessage( i18n("Unable to set write speed to %1.",formatWritingSpeedFactor( d->usedSpeed, d->burnedMediaType, SpeedFormatInteger ) ), MessageError );
+                emit infoMessage( i18n("Probably this is lower than your writer's lowest writing speed."), MessageError );
+                break;
+            case CANNOT_SEND_CUE_SHEET:
+                emit infoMessage( i18n("Unable to send CUE sheet."), MessageError );
+                if( d->writingMode == K3b::WritingModeSao )
+                    emit infoMessage( i18n("Sometimes using TAO writing mode solves this issue."), MessageError );
+                break;
+            case CANNOT_OPEN_NEW_SESSION:
+                emit infoMessage( i18n("Unable to open new session."), MessageError );
+                emit infoMessage( i18n("Probably a problem with the medium."), MessageError );
+                break;
+            case CANNOT_FIXATE_DISK:
+                emit infoMessage( i18n("The disk might still be readable."), MessageError );
+                if( d->writingMode == K3b::WritingModeTao && burnDevice()->dao() )
+                    emit infoMessage( i18n("Try DAO writing mode."), MessageError );
+                break;
+            case PERMISSION_DENIED:
+                emit infoMessage( i18n("%1 has no permission to open the device.",QString("cdrecord")), MessageError );
+#ifdef BUILD_K3BSETUP
+                emit infoMessage( i18n("You may use K3bsetup to solve this problem."), MessageError );
+#endif
+                break;
+            case BUFFER_UNDERRUN:
+                emit infoMessage( i18n("Probably a buffer underrun occurred."), MessageError );
+                if( !d->usingBurnfree && burnDevice()->burnproof() )
+                    emit infoMessage( i18n("Please enable Burnfree or choose a lower burning speed."), MessageError );
+                else
+                    emit infoMessage( i18n("Please choose a lower burning speed."), MessageError );
+                break;
+            case HIGH_SPEED_MEDIUM:
+                emit infoMessage( i18n("Found a high-speed medium not suitable for the writer being used."), MessageError );
+                emit infoMessage( i18n("Use the 'force unsafe operations' option to ignore this."), MessageError );
+                break;
+            case LOW_SPEED_MEDIUM:
+                emit infoMessage( i18n("Found a low-speed medium not suitable for the writer being used."), MessageError );
+                emit infoMessage( i18n("Use the 'force unsafe operations' option to ignore this."), MessageError );
+                break;
+            case MEDIUM_ERROR:
+                emit infoMessage( i18n("Most likely the burning failed due to low-quality media."), MessageError );
+                break;
+            case DEVICE_BUSY:
+                emit infoMessage( i18n("Another application is blocking the device (most likely automounting)."), MessageError );
+                break;
+            case WRITE_ERROR:
+                emit infoMessage( i18n("A write error occurred."), MessageError );
+                if( d->writingMode == K3b::WritingModeSao )
+                    emit infoMessage( i18n("Sometimes using TAO writing mode solves this issue."), MessageError );
+                break;
+            case BLANK_FAILED:
+                emit infoMessage( i18n("Some drives do not support all erase types."), MessageError );
+                emit infoMessage( i18n("Try again using 'Complete' erasing."), MessageError );
+                break;
+            case SHORT_READ:
+                emit infoMessage( QLatin1String("Internal error: short read. Please report!"), MessageError );
+                break;
+            case UNKNOWN:
+                if( (exitCode == 12) && K3b::kernelVersion() >= K3b::Version( 2, 6, 8 ) && d->cdrecordBinObject->hasFeature( "suidroot" ) ) {
+                    emit infoMessage( i18n("Since kernel version 2.6.8 cdrecord cannot use SCSI transport when running suid root anymore."), MessageError );
+                    emit infoMessage( i18n("You may use K3b::Setup to solve this problem or remove the suid bit manually."), MessageError );
+                }
+                else if( !wasSourceUnreadable() ) {
+                    emit infoMessage( i18n("%1 returned an unknown error (code %2).",
+                                           d->cdrecordBinObject->name(), exitCode),
+                                      K3b::Job::MessageError );
+
+                    if( (exitCode >= 254) && d->writingMode == K3b::WritingModeSao ) {
+                        emit infoMessage( i18n("Sometimes using TAO writing mode solves this issue."), MessageError );
+                    }
+                    else {
+                        emit infoMessage( i18n("If you are running an unpatched cdrecord version..."), MessageError );
+                        emit infoMessage( i18n("...and this error also occurs with high quality media..."), MessageError );
+                        emit infoMessage( i18n("...and the K3b FAQ does not help you..."), MessageError );
+                        emit infoMessage( i18n("...please include the debugging output in your problem report."), MessageError );
+                    }
+                }
+                break;
+            }
+            jobFinished( false );
+        }
+    }
+    else {
+        emit infoMessage( i18n("%1 crashed.", d->cdrecordBinObject->name()),
+                          MessageError );
+        jobFinished( false );
+    }
+}
+
+
+void K3b::CdrecordWriter::slotThroughput( int t )
+{
+    emit writeSpeed( t, d->tracks.count() > d->currentTrack && !d->tracks[d->currentTrack-1].audio
+                     ? K3b::Device::SPEED_FACTOR_CD_MODE1
+                     : d->usedSpeedFactor );
+}
+
+
+qint64 K3b::CdrecordWriter::write( const char* data, qint64 maxSize )
+{
+    return d->process.write( data, maxSize );
+}
+
+#include "k3bcdrecordwriter.moc"
diff -rupN k3b-2.0.2/libk3b/tools/k3blibdvdcss.cpp k3b-2.0.2-patched/libk3b/tools/k3blibdvdcss.cpp
--- k3b-2.0.2/libk3b/tools/k3blibdvdcss.cpp	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/tools/k3blibdvdcss.cpp	2013-09-16 01:26:34.000000000 +0300
@@ -61,7 +61,7 @@ inline void dlclose(void *a)
 #ifdef Q_OS_WIN32
 #define LIBDVDCSS_NAME "dvdcss.dll"
 #else
-#define LIBDVDCSS_NAME "libdvdcss.so.2"
+#define LIBDVDCSS_NAME "libdvdcss.so.3"
 #endif
 
 void* K3b::LibDvdCss::s_libDvdCss = 0;
diff -rupN k3b-2.0.2/libk3b/tools/k3blibdvdcss.cpp.orig k3b-2.0.2-patched/libk3b/tools/k3blibdvdcss.cpp.orig
--- k3b-2.0.2/libk3b/tools/k3blibdvdcss.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3b/tools/k3blibdvdcss.cpp.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,340 @@
+/*
+ *
+ * Copyright (C) 2004-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include <config-k3b.h>
+
+#include "k3blibdvdcss.h"
+
+#include "k3bdevice.h"
+#include "k3biso9660.h"
+#include "k3biso9660backend.h"
+
+#include <qfile.h>
+#include <qpair.h>
+
+// TODO replace dlopen/dlsym/dlclose by platform independent QLibrary
+#ifdef Q_OS_WIN32
+
+#include <QLibrary>
+
+inline void *dlopen(char *fileName, int b)
+{
+	static QLibrary lib;
+	lib.setFileName(fileName);
+	if (lib.isLoaded())
+		return &lib;
+	if (lib.load())
+		return &lib;
+	return 0;
+}
+
+inline void *dlsym(void *a, char *b)
+{
+	QLibrary *lib = (QLibrary *)a;
+	return lib->resolve(b);
+}
+
+inline void dlclose(void *a)
+{
+	QLibrary *lib = (QLibrary *)a;
+	lib->unload();
+}
+
+#define RTLD_GLOBAL 0
+#define RTLD_NOW 0
+#define RTLD_LAZY 0
+#else
+#include <dlfcn.h>
+#endif
+
+#ifdef Q_OS_WIN32
+#define LIBDVDCSS_NAME "dvdcss.dll"
+#else
+#define LIBDVDCSS_NAME "libdvdcss.so.2"
+#endif
+
+void* K3b::LibDvdCss::s_libDvdCss = 0;
+int K3b::LibDvdCss::s_counter = 0;
+
+
+extern "C" {
+    struct dvdcss_s;
+    typedef struct dvdcss_s* dvdcss_t;
+
+    dvdcss_t (*k3b_dvdcss_open)(char*);
+    int (*k3b_dvdcss_close)( dvdcss_t );
+    int (*k3b_dvdcss_seek)( dvdcss_t, int, int );
+    int (*k3b_dvdcss_read)( dvdcss_t, void*, int, int );
+}
+
+
+
+class K3b::LibDvdCss::Private
+{
+public:
+    Private()
+        :dvd(0) {
+    }
+
+    dvdcss_t dvd;
+    K3b::Device::Device* device;
+    QVector< QPair<int,int> > titleOffsets;
+    int currentSector;
+    bool currentSectorInTitle;
+};
+
+K3b::LibDvdCss::LibDvdCss()
+{
+    d = new Private();
+    s_counter++;
+}
+
+
+K3b::LibDvdCss::~LibDvdCss()
+{
+    close();
+    delete d;
+    s_counter--;
+    if( s_counter == 0 ) {
+        dlclose( s_libDvdCss );
+        s_libDvdCss = 0;
+    }
+}
+
+
+bool K3b::LibDvdCss::open( K3b::Device::Device* dev )
+{
+    d->device = dev;
+    dev->close();
+    d->dvd = k3b_dvdcss_open( const_cast<char*>( QFile::encodeName(dev->blockDeviceName()).data() ) );
+    d->currentSector = 0;
+    d->currentSectorInTitle = false;
+    return ( d->dvd != 0 );
+}
+
+
+void K3b::LibDvdCss::close()
+{
+    if( d->dvd )
+        k3b_dvdcss_close( d->dvd );
+    d->dvd = 0;
+}
+
+
+int K3b::LibDvdCss::seek( int sector, int flags )
+{
+    return k3b_dvdcss_seek( d->dvd, sector, flags );
+}
+
+
+int K3b::LibDvdCss::read( void* buffer, int sectors, int flags )
+{
+    return k3b_dvdcss_read( d->dvd, buffer, sectors, flags );
+}
+
+
+int K3b::LibDvdCss::readWrapped( void* buffer, int firstSector, int sectors )
+{
+    // 1. are we in a title?
+    // 2. does a new title start in the read sector area?
+    //    - see below, set title if firstSector is the first sector of a new title
+    // 3. does a title end in the read sector area?
+    //    3.1 does a previous title end
+    //    3.2 does the title from 2. already end
+
+    // we need to seek to the first sector. Otherwise we get faulty data.
+    bool needToSeek = ( firstSector != d->currentSector || firstSector == 0 );
+    bool inTitle = false;
+    bool startOfTitle = false;
+
+    //
+    // Make sure we never read encrypted and unencrypted data at once since libdvdcss
+    // only decrypts the whole area of read sectors or nothing at all.
+    //
+    for( int i = 0; i < d->titleOffsets.count(); ++i ) {
+        int titleStart = d->titleOffsets[i].first;
+        int titleEnd = titleStart + d->titleOffsets[i].second - 1;
+
+        // update key when entrering a new title
+        // FIXME: we also need this if we seek into a new title (not only the start of the title)
+        if( titleStart == firstSector )
+            startOfTitle = needToSeek = inTitle = true;
+
+        // check if a new title or non-title area starts inside the read sector range
+        if( firstSector < titleStart && firstSector+sectors > titleStart ) {
+            kDebug() << "(K3b::LibDvdCss) title start inside of sector range ("
+                     << firstSector << "-" << (firstSector+sectors-1)
+                     << "). only reading " << (titleStart - firstSector) << " sectors up to title offset "
+                     << (titleStart-1);
+            sectors = titleStart - firstSector;
+        }
+
+        if( firstSector < titleEnd && firstSector+sectors > titleEnd ) {
+            kDebug() << "(K3b::LibDvdCss) title end inside of sector range ("
+                     << firstSector << "-" << (firstSector+sectors-1)
+                     << "). only reading " << (titleEnd - firstSector + 1) << " sectors up to title offset "
+                     << titleEnd;
+            sectors = titleEnd - firstSector + 1;
+            inTitle = true;
+        }
+
+        // is our read range part of one title
+        if( firstSector >= titleStart && firstSector+sectors-1 <= titleEnd )
+            inTitle = true;
+    }
+
+    if( needToSeek ) {
+        int flags = DVDCSS_NOFLAGS;
+        if( startOfTitle )
+            flags = DVDCSS_SEEK_KEY;
+        else if( inTitle )
+            flags = DVDCSS_SEEK_MPEG;
+
+        kDebug() << "(K3b::LibDvdCss) need to seek from " << d->currentSector << " to " << firstSector << " with " << flags;
+
+        d->currentSector = seek( firstSector, flags );
+        if( d->currentSector != firstSector ) {
+            kDebug() << "(K3b::LibDvdCss) seek failed: " << d->currentSector;
+            return -1;
+        }
+
+        kDebug() << "(K3b::LibDvdCss) seek done: " << d->currentSector;
+    }
+
+
+    int flags = DVDCSS_NOFLAGS;
+    if( inTitle )
+        flags = DVDCSS_READ_DECRYPT;
+
+    int ret = read( buffer, sectors, flags );
+    if( ret >= 0 )
+        d->currentSector += ret;
+    else
+        d->currentSector = 0; // force a seek the next time
+
+    return ret;
+}
+
+
+bool K3b::LibDvdCss::crackAllKeys()
+{
+    //
+    // Loop over all titles and crack the keys (inspired by libdvdread)
+    //
+    kDebug() << "(K3b::LibDvdCss) cracking all keys.";
+
+    d->titleOffsets.clear();
+
+    K3b::Iso9660 iso( new K3b::Iso9660DeviceBackend( d->device ) );
+    iso.setPlainIso9660( true );
+    if( !iso.open() ) {
+        kDebug() << "(K3b::LibDvdCss) could not open iso9660 fs.";
+        return false;
+    }
+
+#ifdef K3B_DEBUG
+    iso.debug();
+#endif
+
+    const K3b::Iso9660Directory* dir = iso.firstIsoDirEntry();
+
+    int title = 0;
+    for( ; title < 100; ++title ) {
+        QString filename;
+
+        // first we get the menu vob
+        if( title == 0 )
+            filename.sprintf( "VIDEO_TS/VIDEO_TS.VOB" );
+        else
+            filename.sprintf( "VIDEO_TS/VTS_%02d_%d.VOB", title, 0 );
+
+        const K3b::Iso9660File* file = dynamic_cast<const K3b::Iso9660File*>( dir->entry( filename ) );
+        if( file && file->size() > 0 ) {
+            d->titleOffsets.append( qMakePair( (int)file->startSector(), (int)(file->size() / 2048U) ) );
+            kDebug() << "(K3b::LibDvdCss) Get key for /" << filename << " at " << file->startSector();
+            if( seek( (int)file->startSector(), DVDCSS_SEEK_KEY ) < 0 ) {
+                kDebug() << "(K3b::LibDvdCss) failed to crash key for " << filename << " at " << file->startSector();
+            }
+        }
+
+        if( title > 0 ) {
+            QPair<int,int> p;
+            int vob = 1;
+            for( ; vob < 100; ++vob ) {
+                filename.sprintf( "VIDEO_TS/VTS_%02d_%d.VOB", title, vob );
+                file = dynamic_cast<const K3b::Iso9660File*>( dir->entry( filename ) );
+                if( file ) {
+                    if( file->size() % 2048 )
+                        kError() << "(K3b::LibDvdCss) FILESIZE % 2048 != 0!!!" << endl;
+                    if( vob == 1 ) {
+                        p.first = file->startSector();
+                        p.second = file->size() / 2048;
+                        kDebug() << "(K3b::LibDvdCss) Get key for /" << filename << " at " << file->startSector();
+                        if( seek( (int)file->startSector(), DVDCSS_SEEK_KEY ) < 0 ) {
+                            kDebug() << "(K3b::LibDvdCss) failed to crash key for " << filename << " at " << file->startSector();
+                        }
+                    }
+                    else {
+                        p.second += file->size() / 2048;
+                    }
+                }
+                else {
+                    // last vob
+                    break;
+                }
+            }
+            --vob;
+
+            // last title
+            if( vob == 0 )
+                break;
+
+            kDebug() << "(K3b::LibDvdCss) Title " << title << " " << vob << " vobs with length " << p.second;
+            d->titleOffsets.append( p );
+        }
+    }
+
+    --title;
+
+    kDebug() << "(K3b::LibDvdCss) found " << title << " titles.";
+
+    return (title > 0);
+}
+
+
+K3b::LibDvdCss* K3b::LibDvdCss::create()
+{
+    if( s_libDvdCss == 0 ) {
+        s_libDvdCss = dlopen( LIBDVDCSS_NAME, RTLD_LAZY|RTLD_GLOBAL );
+        if( s_libDvdCss ) {
+            k3b_dvdcss_open = (dvdcss_t (*)(char*))dlsym( s_libDvdCss, "dvdcss_open" );
+            k3b_dvdcss_close = (int (*)( dvdcss_t ))dlsym( s_libDvdCss, "dvdcss_close" );
+            k3b_dvdcss_seek = (int (*)( dvdcss_t, int, int ))dlsym( s_libDvdCss, "dvdcss_seek" );
+            k3b_dvdcss_read = (int (*)( dvdcss_t, void*, int, int ))dlsym( s_libDvdCss, "dvdcss_read" );
+
+            if( !k3b_dvdcss_open || !k3b_dvdcss_close || !k3b_dvdcss_seek || !k3b_dvdcss_read ) {
+                kDebug() << "(K3b::LibDvdCss) unable to resolve libdvdcss.";
+                dlclose( s_libDvdCss );
+                s_libDvdCss = 0;
+            }
+        }
+        else
+            kDebug() << "(K3b::LibDvdCss) unable to load libdvdcss.";
+    }
+
+    if( s_libDvdCss )
+        return new K3b::LibDvdCss();
+    else
+        return 0;
+}
diff -rupN k3b-2.0.2/libk3bdevice/CMakeLists.txt k3b-2.0.2-patched/libk3bdevice/CMakeLists.txt
--- k3b-2.0.2/libk3bdevice/CMakeLists.txt	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/CMakeLists.txt	2013-09-16 01:30:32.000000000 +0300
@@ -27,6 +27,7 @@ kde4_add_library(k3bdevice SHARED ${k3bd
 target_link_libraries(k3bdevice
   ${KDE4_KDECORE_LIBS}
   ${KDE4_SOLID_LIBS}
+  cam
 )
 
 if (CMAKE_SYSTEM_NAME MATCHES "kFreeBSD")
diff -rupN k3b-2.0.2/libk3bdevice/CMakeLists.txt.orig k3b-2.0.2-patched/libk3bdevice/CMakeLists.txt.orig
--- k3b-2.0.2/libk3bdevice/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/CMakeLists.txt.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,55 @@
+project(libk3bdevice)
+
+########### next target ###############
+
+set(k3bdevice_LIB_SRCS 
+   k3bdevice.cpp 
+   k3bdevice_mmc.cpp 
+   k3bscsicommand.cpp 
+   k3btrack.cpp 
+   k3btoc.cpp 
+   k3bdevicemanager.cpp 
+   k3bmsf.cpp 
+   k3bdiskinfo.cpp 
+   k3bdeviceglobals.cpp 
+   k3bcrc.cpp 
+   k3bcdtext.cpp )
+
+
+if(ENABLE_HAL_SUPPORT)
+  set(k3bdevice_LIB_SRCS 
+    ${k3bdevice_LIB_SRCS}
+    k3bhalconnection.cpp)
+endif(ENABLE_HAL_SUPPORT)
+
+kde4_add_library(k3bdevice SHARED ${k3bdevice_LIB_SRCS})
+
+target_link_libraries(k3bdevice
+  ${KDE4_KDECORE_LIBS}
+  ${KDE4_SOLID_LIBS}
+)
+
+if (CMAKE_SYSTEM_NAME MATCHES "kFreeBSD")
+  target_link_libraries(k3bdevice cam)
+endif (CMAKE_SYSTEM_NAME MATCHES "kFreeBSD")
+
+set_target_properties(k3bdevice PROPERTIES VERSION ${K3B_LIB_VERSION_MAJOR}.${K3B_LIB_VERSION_MINOR}.${K3B_LIB_VERSION_RELEASE} SOVERSION ${K3B_LIB_VERSION_MAJOR})
+install(TARGETS k3bdevice ${INSTALL_TARGETS_DEFAULT_ARGS} )
+
+
+########### install files ###############
+
+install( FILES
+  k3bdevicemanager.h
+  k3bdevice.h
+  k3btoc.h
+  k3btrack.h
+  k3bdeviceglobals.h
+  k3bdiskinfo.h
+  k3bcdtext.h
+  k3bmsf.h
+  k3bdevicetypes.h
+  k3bdevice_export.h
+  DESTINATION ${INCLUDE_INSTALL_DIR} COMPONENT Devel )
+
+
diff -rupN k3b-2.0.2/libk3bdevice/k3bdevice.cpp k3b-2.0.2-patched/libk3bdevice/k3bdevice.cpp
--- k3b-2.0.2/libk3bdevice/k3bdevice.cpp	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bdevice.cpp	2013-09-16 01:29:42.000000000 +0300
@@ -309,6 +309,12 @@ QString K3b::Device::Device::blockDevice
 }
 
 
+QString K3b::Device::Device::genericDeviceName() const
+{
+    return d->genericDevice;
+}
+
+
 int K3b::Device::Device::maxWriteSpeed() const
 {
     return d->maxWriteSpeed;
@@ -363,6 +369,14 @@ bool K3b::Device::Device::init( bool bCh
     if( !open() )
         return false;
 
+#if defined(Q_OS_FREEBSD)
+    if( d->deviceHandle ) {
+        d->genericDevice = QString("%1").arg(d->deviceHandle->path_id)
+            + QString(",%1").arg(d->deviceHandle->target_id)
+            + QString(",%1").arg(d->deviceHandle->target_lun);
+    }
+#endif
+
     //
     // inquiry
     // use a 36 bytes buffer since not all devices return the full inquiry struct
diff -rupN k3b-2.0.2/libk3bdevice/k3bdevice.cpp.orig k3b-2.0.2-patched/libk3bdevice/k3bdevice.cpp.orig
--- k3b-2.0.2/libk3bdevice/k3bdevice.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bdevice.cpp.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,3794 @@
+/*
+ *
+ * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include "k3bdevice.h"
+#include "k3bdeviceglobals.h"
+#include "k3btrack.h"
+#include "k3btoc.h"
+#include "k3bdiskinfo.h"
+#include "k3bdiskinfo_p.h"
+#include "k3bmmc.h"
+#include "k3bscsicommand.h"
+#include "k3bcrc.h"
+
+#include "config-k3b.h"
+
+#include <qstringlist.h>
+#include <qfile.h>
+#include <qglobal.h>
+#include <qmutex.h>
+
+#include <kdebug.h>
+
+#include <Solid/Device>
+#include <Solid/OpticalDrive>
+#include <Solid/Block>
+#include <Solid/StorageAccess>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <math.h>
+#include <stdarg.h>
+#include <limits.h>
+
+
+#ifdef Q_OS_LINUX
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,70)
+typedef unsigned char u8;
+#endif
+
+#undef __STRICT_ANSI__
+#include <linux/cdrom.h>
+#define __STRICT_ANSI__
+
+#endif // Q_OS_LINUX
+
+#ifdef Q_OS_FREEBSD
+#include <stdio.h>
+#include <camlib.h>
+#define CD_FRAMESIZE_RAW 2352
+#endif
+
+#ifdef Q_OS_NETBSD
+#include <sys/cdio.h>
+#endif
+
+#ifdef HAVE_RESMGR
+extern "C" {
+#include <resmgr.h>
+}
+#endif
+
+#ifdef Q_OS_FREEBSD
+#define HANDLE_DEFAULT_VALUE 0
+#endif
+#ifdef Q_OS_WIN32
+#define HANDLE_DEFAULT_VALUE INVALID_HANDLE_VALUE
+#endif
+#ifdef Q_OS_LINUX
+#define HANDLE_DEFAULT_VALUE -1
+#endif
+#ifdef Q_OS_NETBSD
+#define HANDLE_DEFAULT_VALUE -1
+#endif
+
+//
+// Very evil hacking: force the speed values to be acurate
+// as long as "they" do not introduce other "broken" DVD
+// speeds like 2.4 this works fine
+//
+namespace {
+    int fixupDvdWritingSpeed( int speed )
+    {
+        //
+        // Some writers report their speeds in 1000 bytes per second instead of 1024.
+        //
+        if( speed % K3b::Device::SPEED_FACTOR_DVD == 0 )
+            return speed;
+
+        else if( speed % 1352 == 0 )
+            return speed*K3b::Device::SPEED_FACTOR_DVD/1352;
+
+        // has to be 2.4x speed
+        else
+            return 3324;
+    }
+}
+
+class K3b::Device::Device::Private
+{
+public:
+    Private()
+        : supportedProfiles(0),
+          deviceHandle(HANDLE_DEFAULT_VALUE),
+          openedReadWrite(false),
+          burnfree(false) {
+    }
+
+    Solid::Device solidDevice;
+
+    QString vendor;
+    QString description;
+    QString version;
+    int maxReadSpeed;
+    int maxWriteSpeed;
+    int currentWriteSpeed;
+
+    bool dvdMinusTestwrite;
+
+    int bufferSize;
+
+    WritingModes writeModes;
+
+    QString blockDevice;
+    QString genericDevice;
+
+    MediaTypes readCapabilities;
+    MediaTypes writeCapabilities;
+    MediaTypes supportedProfiles;
+    Handle deviceHandle;
+    bool openedReadWrite;
+    bool burnfree;
+
+    QMutex mutex;
+    QMutex openCloseMutex;
+};
+
+#ifdef Q_OS_FREEBSD
+K3b::Device::Device::Handle K3b::Device::openDevice( const char* name, bool write )
+{
+    K3b::Device::Device::Handle handle = cam_open_device (name, O_RDWR);
+        kDebug() << "(K3b::Device::openDevice) open device " << name
+                 << ((handle)?" succeeded.":" failed.") << endl;
+    return handle;
+}
+#endif
+
+
+#if defined(Q_OS_LINUX) || defined(Q_OS_NETBSD)
+K3b::Device::Device::Handle K3b::Device::openDevice( const char* name, bool write )
+{
+    K3b::Device::Device::Handle fd = HANDLE_DEFAULT_VALUE;
+    int flags = O_NONBLOCK;
+    if( write )
+        flags |= O_RDWR;
+    else
+        flags |= O_RDONLY;
+
+#ifdef HAVE_RESMGR
+    // first try resmgr
+    fd = ::rsm_open_device( name, flags );
+    //  kDebug() << "(K3b::Device::Device) resmgr open: " << fd;
+#endif
+
+    if( fd < 0 )
+        fd = ::open( name, flags );
+
+    if( fd < 0 ) {
+        kDebug() << "(K3b::Device::Device) could not open device "
+                 << name << ( write ? " for writing" : " for reading" ) << endl;
+        kDebug() << "                    (" << QString::fromLocal8Bit( ::strerror(errno) ) << ")";
+        fd = HANDLE_DEFAULT_VALUE;
+
+        // at least open it read-only (which is sufficient for kernels < 2.6.8 anyway)
+        if( write )
+            return openDevice( name, false );
+    }
+
+    return fd;
+}
+#endif
+
+#ifdef Q_OS_WIN32
+#define NAME_COUNT  25
+
+K3b::Device::Device::Handle K3b::Device::openDevice( const char* name, bool write )
+{
+    bool status = false;
+    K3b::Device::Device::Handle deviceHandle = HANDLE_DEFAULT_VALUE;
+    char string[NAME_COUNT + 1];
+    // check if name is already a device name
+    if (name[0] == '\\')
+        strncpy(string, name, NAME_COUNT);
+    else
+        _snprintf(string, NAME_COUNT, "\\\\.\\%s", name);
+    deviceHandle = CreateFileA(string,
+        GENERIC_READ | GENERIC_WRITE , // at least inquiry needs write access
+        FILE_SHARE_READ | (write ? FILE_SHARE_WRITE : 0),
+        NULL,
+        OPEN_EXISTING,
+        0,
+        NULL);
+
+    if( deviceHandle == INVALID_HANDLE_VALUE )
+        deviceHandle = CreateFileA(string,
+            GENERIC_READ,
+            FILE_SHARE_READ,
+            NULL,
+            OPEN_EXISTING,
+            0,
+            NULL);
+
+    if (deviceHandle == INVALID_HANDLE_VALUE) {
+        int errorCode = GetLastError();
+        kDebug() << "Error opening " << string << "Error:" << errorCode << endl;
+        return HANDLE_DEFAULT_VALUE;
+    }
+
+    return deviceHandle;
+}
+#endif
+
+
+K3b::Device::Device::Device( const Solid::Device& dev )
+{
+    d = new Private;
+    d->solidDevice = dev;
+    d->blockDevice = dev.as<Solid::Block>()->device();
+    d->writeModes = 0;
+    d->maxWriteSpeed = 0;
+    d->maxReadSpeed = 0;
+    d->burnfree = false;
+    d->dvdMinusTestwrite = true;
+    d->bufferSize = 0;
+}
+
+
+K3b::Device::Device::~Device()
+{
+    close();
+    delete d;
+}
+
+
+QString K3b::Device::Device::vendor() const
+{
+    return d->vendor;
+}
+
+
+QString K3b::Device::Device::description() const
+{
+    return d->description;
+}
+
+
+QString K3b::Device::Device::version() const
+{
+    return d->version;
+}
+
+
+bool K3b::Device::Device::dvdMinusTestwrite() const
+{
+    return d->dvdMinusTestwrite;
+}
+
+
+int K3b::Device::Device::maxReadSpeed() const
+{
+    return d->maxReadSpeed;
+}
+
+
+int K3b::Device::Device::currentWriteSpeed() const
+{
+    return d->currentWriteSpeed;
+}
+
+
+int K3b::Device::Device::bufferSize() const
+{
+    return d->bufferSize;
+}
+
+
+QString K3b::Device::Device::blockDeviceName() const
+{
+    return d->blockDevice;
+}
+
+
+int K3b::Device::Device::maxWriteSpeed() const
+{
+    return d->maxWriteSpeed;
+}
+
+
+void K3b::Device::Device::setCurrentWriteSpeed( int s )
+{
+    d->currentWriteSpeed = s;
+}
+
+
+void K3b::Device::Device::setMaxReadSpeed( int s )
+{
+    d->maxReadSpeed = s;
+}
+
+
+void K3b::Device::Device::setMaxWriteSpeed( int s )
+{
+    d->maxWriteSpeed = s;
+}
+
+
+Solid::Device K3b::Device::Device::solidDevice() const
+{
+    return d->solidDevice;
+}
+
+
+Solid::StorageAccess* K3b::Device::Device::solidStorage() const
+{
+     QList<Solid::Device> storages = Solid::Device::listFromType( Solid::DeviceInterface::StorageAccess, d->solidDevice.udi() );
+     if( storages.isEmpty() )
+         return 0;
+     else
+         return storages.first().as<Solid::StorageAccess>();
+}
+
+
+bool K3b::Device::Device::init( bool bCheckWritingModes )
+{
+    kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": init()";
+
+    //
+    // they all should read CD-ROM.
+    //
+    d->readCapabilities = MEDIA_CD_ROM;
+    d->writeCapabilities = 0;
+    d->supportedProfiles = 0;
+
+    if( !open() )
+        return false;
+
+    //
+    // inquiry
+    // use a 36 bytes buffer since not all devices return the full inquiry struct
+    //
+    ScsiCommand cmd( this );
+    unsigned char buf[36];
+    cmd.clear();
+    ::memset( buf, 0, sizeof(buf) );
+    struct inquiry* inq = (struct inquiry*)buf;
+    cmd[0] = MMC_INQUIRY;
+    cmd[4] = sizeof(buf);
+    cmd[5] = 0;
+    if( cmd.transport( TR_DIR_READ, buf, sizeof(buf) ) ) {
+        kError() << "(K3b::Device::Device) Unable to do inquiry." << endl;
+        close();
+        return false;
+    }
+    else {
+        d->vendor = QString::fromLatin1( (char*)(inq->vendor), 8 ).trimmed();
+        d->description = QString::fromLatin1( (char*)(inq->product), 16 ).trimmed();
+        d->version = QString::fromLatin1( (char*)(inq->revision), 4 ).trimmed();
+    }
+
+    if( d->vendor.isEmpty() )
+        d->vendor = "UNKNOWN";
+    if( d->description.isEmpty() )
+        d->description = "UNKNOWN";
+
+    //
+    // We probe all features of the device. Since not all devices support the GET CONFIGURATION command
+    // we also query the mode page 2A and use the cdrom.h stuff to get as much information as possible
+    //
+    checkFeatures();
+
+    //
+    // Check the supported write modes (WRITINGMODE_TAO, WRITINGMODE_SAO, WRITINGMODE_RAW) by trying to set them
+    // We do this before checking mode page 2A in case some readers allow changin
+    // the write parameter page
+    //
+    if( bCheckWritingModes )
+        checkWritingModes();
+
+    //
+    // Most current drives support the 2A mode page
+    // Here we can get some more information (cdrecord -prcap does exactly this)
+    //
+    checkFor2AFeatures();
+
+    d->maxWriteSpeed = determineMaximalWriteSpeed();
+
+    //
+    // Check Just-Link via Ricoh mode page 0x30
+    //
+    if( !d->burnfree )
+        checkForJustLink();
+
+    //
+    // Support for some very old drives
+    //
+    checkForAncientWriters();
+
+    //
+    // If it can be written it can also be read
+    //
+    d->readCapabilities |= d->writeCapabilities;
+
+    close();
+
+    return furtherInit();
+}
+
+
+bool K3b::Device::Device::furtherInit()
+{
+#ifdef Q_OS_LINUX
+
+    //
+    // Since all CDR drives at least support WRITINGMODE_TAO, all CDRW drives should support
+    // mode page 2a and all DVD writer should support mode page 2a or the GET CONFIGURATION
+    // command this is redundant and may be removed for BSD ports or even completely
+    //
+    // We just keep it here because of the "should" in the sentence above. If someone can tell me
+    // that the linux driver does nothing more we can remove it completely.
+    //
+    open();
+    int drivetype = ::ioctl( handle(), CDROM_GET_CAPABILITY, CDSL_CURRENT );
+    if( drivetype < 0 ) {
+        kDebug() << "Error while retrieving capabilities.";
+        close();
+        return false;
+    }
+
+    d->readCapabilities |= MEDIA_CD_ROM;
+
+    if( drivetype & CDC_CD_R )
+        d->writeCapabilities |= MEDIA_CD_R;
+    if( drivetype & CDC_CD_RW )
+        d->writeCapabilities |= MEDIA_CD_RW;
+    if( drivetype & CDC_DVD_R )
+        d->writeCapabilities |= MEDIA_DVD_R;
+    if( drivetype & CDC_DVD )
+        d->readCapabilities |= MEDIA_DVD_ROM;
+
+    close();
+
+#endif // Q_OS_LINUX
+#ifdef Q_OS_WIN32
+    kDebug() << __FUNCTION__ << "to be implemented";
+#endif
+    return true;
+}
+
+
+void K3b::Device::Device::checkForAncientWriters()
+{
+    // TODO: add a boolean which determines if this device is non-MMC so we may warn the user at K3b startup about it
+
+    //
+    // There are a lot writers out there which behave like the TEAC R5XS
+    //
+    if( ( vendor().startsWith("TEAC") && ( description().startsWith("CD-R50S") ||
+                                           description().startsWith("CD-R55S") ) )
+        ||
+        ( vendor().startsWith("SAF") && ( description().startsWith("CD-R2006PLUS") ||
+                                          description().startsWith("CD-RW226") ||
+                                          description().startsWith("CD-R4012") ) )
+        ||
+        ( vendor().startsWith("JVC") && ( description().startsWith("XR-W2001") ||
+                                          description().startsWith("XR-W2010") ||
+                                          description().startsWith("R2626") ) )
+        ||
+        ( vendor().startsWith("PINNACLE") && ( description().startsWith("RCD-1000") ||
+                                               description().startsWith("RCD5020") ||
+                                               description().startsWith("RCD5040") ||
+                                               description().startsWith("RCD 4X4") ) )
+        ||
+        ( vendor().startsWith("Traxdata") && description().startsWith("CDR4120") ) ) {
+        d->writeModes = WRITINGMODE_TAO;
+        d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+        d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+        d->maxWriteSpeed = 4;
+        d->maxReadSpeed = 12;
+        d->bufferSize = 1024;
+        d->burnfree = false;
+    }
+    else if( vendor().startsWith("TEAC") ) {
+        if( description().startsWith("CD-R56S") ) {
+            d->writeModes |= WRITINGMODE_TAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 6;
+            d->maxReadSpeed = 24;
+            d->bufferSize = 1302;
+            d->burnfree = false;
+        }
+        if( description().startsWith("CD-R58S") ) {
+            d->writeModes |= WRITINGMODE_TAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 8;
+            d->maxReadSpeed = 24;
+            d->bufferSize = 4096;
+            d->burnfree = false;
+        }
+    }
+    else if( vendor().startsWith("MATSHITA") ) {
+        if( description().startsWith("CD-R   CW-7501") ) {
+            d->writeModes = WRITINGMODE_TAO|WRITINGMODE_SAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 2;
+            d->maxReadSpeed = 4;
+            d->bufferSize = 1024;
+            d->burnfree = false;
+        }
+        if( description().startsWith("CD-R   CW-7502") ) {
+            d->writeModes = WRITINGMODE_TAO|WRITINGMODE_SAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 4;
+            d->maxReadSpeed = 8;
+            d->bufferSize = 1024;
+            d->burnfree = false;
+        }
+        else if( description().startsWith("CD-R56S") ) {
+            d->writeModes |= WRITINGMODE_TAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 6;
+            d->maxReadSpeed = 24;
+            d->bufferSize = 1302;
+            d->burnfree = false;
+        }
+    }
+    else if( vendor().startsWith("HP") ) {
+        if( description().startsWith("CD-Writer 6020") ) {
+            d->writeModes = WRITINGMODE_TAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 2;
+            d->maxReadSpeed = 6;
+            d->bufferSize = 1024;
+            d->burnfree = false;
+        }
+    }
+    else if( vendor().startsWith( "PHILIPS" ) ) {
+        if( description().startsWith( "CDD2600" ) ) {
+            d->writeModes = WRITINGMODE_TAO|WRITINGMODE_SAO;
+            d->readCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->writeCapabilities = MEDIA_CD_ROM|MEDIA_CD_R;
+            d->maxWriteSpeed = 2;
+            d->maxReadSpeed = 6;
+            d->bufferSize = 1024;
+            d->burnfree = false;
+        }
+    }
+}
+
+
+bool K3b::Device::Device::dao() const
+{
+    return d->writeModes & WRITINGMODE_SAO;
+}
+
+
+bool K3b::Device::Device::supportsRawWriting() const
+{
+    return( writingModes() & (WRITINGMODE_RAW|WRITINGMODE_RAW_R16|WRITINGMODE_RAW_R96P|WRITINGMODE_RAW_R96R) );
+}
+
+
+bool K3b::Device::Device::writesCd() const
+{
+    return ( d->writeCapabilities & MEDIA_CD_R ) && ( d->writeModes & WRITINGMODE_TAO );
+}
+
+
+bool K3b::Device::Device::burner() const
+{
+    return ( writesCd() || writesDvd() );
+}
+
+
+bool K3b::Device::Device::writesCdrw() const
+{
+    return d->writeCapabilities & MEDIA_CD_RW;
+}
+
+
+bool K3b::Device::Device::writesDvd() const
+{
+    return ( writesDvdPlus() || writesDvdMinus() );
+}
+
+
+bool K3b::Device::Device::writesDvdPlus() const
+{
+    return d->writeCapabilities & (MEDIA_DVD_PLUS_R|MEDIA_DVD_PLUS_RW);
+}
+
+
+bool K3b::Device::Device::writesDvdMinus() const
+{
+    return d->writeCapabilities & (MEDIA_DVD_R|MEDIA_DVD_RW);
+}
+
+
+bool K3b::Device::Device::readsDvd() const
+{
+    return d->readCapabilities & MEDIA_DVD_ROM;
+}
+
+
+K3b::Device::DeviceTypes K3b::Device::Device::type() const
+{
+    DeviceTypes r = 0;
+    if( readCapabilities() & MEDIA_CD_ROM )
+        r |= DEVICE_CD_ROM;
+    if( writeCapabilities() & MEDIA_CD_R )
+        r |= DEVICE_CD_R;
+    if( writeCapabilities() & MEDIA_CD_RW )
+        r |= DEVICE_CD_RW;
+    if( readCapabilities() & MEDIA_DVD_ROM )
+        r |= DEVICE_DVD_ROM;
+    if( writeCapabilities() & MEDIA_DVD_RAM )
+        r |= DEVICE_DVD_RAM;
+    if( writeCapabilities() & MEDIA_DVD_R )
+        r |= DEVICE_DVD_R;
+    if( writeCapabilities() & MEDIA_DVD_RW )
+        r |= DEVICE_DVD_RW;
+    if( writeCapabilities() & MEDIA_DVD_R_DL )
+        r |= DEVICE_DVD_R_DL;
+    if( writeCapabilities() & MEDIA_DVD_PLUS_R )
+        r |= DEVICE_DVD_PLUS_R;
+    if( writeCapabilities() & MEDIA_DVD_PLUS_RW )
+        r |= DEVICE_DVD_PLUS_RW;
+    if( writeCapabilities() & MEDIA_DVD_PLUS_R_DL )
+        r |= DEVICE_DVD_PLUS_R_DL;
+    if( readCapabilities() & MEDIA_HD_DVD_ROM )
+        r |= DEVICE_HD_DVD_ROM;
+    if( writeCapabilities() & MEDIA_HD_DVD_R )
+        r |= DEVICE_HD_DVD_R;
+    if( writeCapabilities() & MEDIA_HD_DVD_RAM )
+        r |= DEVICE_HD_DVD_RAM;
+    if( readCapabilities() & MEDIA_BD_ROM )
+        r |= DEVICE_BD_ROM;
+    if( writeCapabilities() & MEDIA_BD_R )
+        r |= DEVICE_BD_R;
+    if( writeCapabilities() & MEDIA_BD_RE )
+        r |= DEVICE_BD_RE;
+
+    return r;
+}
+
+
+K3b::Device::MediaTypes K3b::Device::Device::readCapabilities() const
+{
+    return d->readCapabilities;
+}
+
+
+K3b::Device::MediaTypes K3b::Device::Device::writeCapabilities() const
+{
+    return d->writeCapabilities;
+}
+
+
+K3b::Device::WritingModes K3b::Device::Device::writingModes() const
+{
+    return d->writeModes;
+}
+
+
+bool K3b::Device::Device::burnproof() const
+{
+    return burnfree();
+}
+
+
+bool K3b::Device::Device::burnfree() const
+{
+    return d->burnfree;
+}
+
+
+bool K3b::Device::Device::isDVD() const
+{
+    if( readsDvd() )
+        return( mediaType() & MEDIA_DVD_ALL );
+    else
+        return false;
+}
+
+
+int K3b::Device::Device::isEmpty() const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    int ret = STATE_UNKNOWN;
+    if( !open() )
+        return STATE_UNKNOWN;
+
+    if( !testUnitReady() )
+        return STATE_NO_MEDIA;
+
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+
+    if( readDiscInformation( &data, dataLen ) ) {
+        disc_info_t* inf = (disc_info_t*)data;
+        switch( inf->status ) {
+        case 0:
+            ret = STATE_EMPTY;
+            break;
+        case 1:
+            ret = STATE_INCOMPLETE;
+            break;
+        case 2:
+            ret = STATE_COMPLETE;
+            break;
+        default:
+            ret = STATE_UNKNOWN;
+            break;
+        }
+
+        delete [] data;
+    }
+
+    if( needToClose )
+        close();
+
+    return ret;
+}
+
+
+int K3b::Device::Device::numSessions() const
+{
+    //
+    // Session Info
+    // ============
+    // Byte 0-1: Data Length
+    // Byte   2: First Complete Session Number (Hex) - always 1
+    // Byte   3: Last Complete Session Number (Hex)
+    //
+
+    int ret = -1;
+
+    unsigned char* data = 0;
+    unsigned int len = 0;
+
+    int m = mediaType();
+    if( m & MEDIA_CD_ALL ) {
+        //
+        // Althought disk_info should get the real value without ide-scsi
+        // I keep getting wrong values (the value is too high. I think the leadout
+        // gets counted as session sometimes :()
+        //
+        if( readTocPmaAtip( &data, len, 1, 0, 0 ) ) {
+            ret = data[3];
+
+            delete [] data;
+        }
+        else {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": could not get session info !";
+        }
+    }
+    else if ( m & ( MEDIA_DVD_PLUS_RW|MEDIA_DVD_RW_OVWR|MEDIA_BD_RE ) ) {
+        // fabricate value
+        int e = isEmpty();
+        return ( e == STATE_COMPLETE || e == STATE_COMPLETE ? 1 : 0 );
+    }
+    else {
+        if( readDiscInformation( &data, len ) ) {
+            ret = (int)( data[9]<<8 | data[4] );
+
+            // do only count complete sessions
+            if( (data[2]>>2) != 3 )
+                ret--;
+
+            delete [] data;
+        }
+    }
+
+    return ret;
+}
+
+
+K3b::Device::Track::DataMode K3b::Device::Device::getDataMode( const K3b::Msf& sector ) const
+{
+    bool needToClose = !isOpen();
+
+    Track::DataMode ret = Track::UNKNOWN;
+
+    if( !open() )
+        return ret;
+
+    // we use readCdMsf here since it's defined mandatory in MMC1 and
+    // we only use this method for CDs anyway
+    unsigned char data[2352];
+    bool readSuccess = readCdMsf( data, 2352,
+                                  0,      // all sector types
+                                  false,  // no dap
+                                  sector,
+                                  sector+1,
+                                  true, // SYNC
+                                  true, // HEADER
+                                  true, // SUBHEADER
+                                  true, // USER DATA
+                                  true, // EDC/ECC
+                                  0,    // no c2 info
+                                  0 );
+
+    if( readSuccess ) {
+        if ( data[15] == 0x1 )
+            ret = Track::MODE1;
+        else if ( data[15] == 0x2 )
+            ret = Track::MODE2;
+        if ( ret == Track::MODE2 ) {
+            if ( data[16] == data[20] &&
+                 data[17] == data[21] &&
+                 data[18] == data[22] &&
+                 data[19] == data[23] ) {
+                if ( data[18] & 0x20 )
+                    ret = Track::XA_FORM2;
+                else
+                    ret = Track::XA_FORM1;
+            }
+        }
+    }
+
+    if( needToClose )
+        close();
+
+    return ret;
+}
+
+
+
+K3b::Device::Track::DataMode K3b::Device::Device::getTrackDataMode( const K3b::Device::Track& track ) const
+{
+    return getDataMode( track.firstSector() );
+}
+
+
+K3b::Device::Toc K3b::Device::Device::readToc() const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    Toc toc;
+
+    if( !open() )
+        return toc;
+
+    int mt = mediaType();
+
+    //
+    // Use the profile if available because DVD-ROM units need to treat DVD+-R(W) media as DVD-ROM
+    // if supported at all
+    //
+    if( currentProfile() == MEDIA_DVD_ROM )
+        mt = MEDIA_DVD_ROM;
+
+    if( mt & (MEDIA_DVD_MINUS_ALL|MEDIA_DVD_PLUS_RW|MEDIA_DVD_ROM) ) {
+        if( !readFormattedToc( toc, mt ) ) {
+            K3b::Msf size;
+            if( readCapacity( size ) ) {
+                Track track;
+                track.setFirstSector( 0 );
+                track.setLastSector( size.lba() );
+                track.setSession( 1 );
+                track.setType( Track::TYPE_DATA );
+                track.setMode( Track::DVD );
+                track.setCopyPermitted( mt != MEDIA_DVD_ROM );
+                track.setPreEmphasis( mt != MEDIA_DVD_ROM );
+
+                toc.append( track );
+            }
+            else
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                         << "READ CAPACITY for toc failed." << endl;
+        }
+    }
+
+    else if( mt & (MEDIA_DVD_PLUS_R|MEDIA_DVD_PLUS_R_DL) ) {
+        //
+        // a DVD+R disk may have multiple sessions
+        // every session may contain up to 16 fragments
+        // if the disk is open there is one open session
+        // every closed session is viewed as a track whereas
+        // every fragment of the open session is viewed as a track
+        //
+        // We may use
+        // READ DISK INFORMATION
+        // READ TRACK INFORMATION: track number FFh, however, does not refer to the invisible track
+        // READ TOC/PMA/ATIP: form 0 refers to all closed sessions
+        //                    form 1 refers to the last closed session
+        //
+        readFormattedToc( toc, mt );
+    }
+
+    else if( mt & MEDIA_BD_ALL ) {
+        readFormattedToc( toc, mt );
+    }
+
+    else if( mt == MEDIA_DVD_RAM ) {
+        kDebug() << "(K3b::Device::readDvdToc) no dvdram support";
+    }
+
+
+    else if( mt & MEDIA_CD_ALL ) {
+        bool success = readRawToc( toc );
+        if( !success ) {
+            success = readFormattedToc( toc, mt );
+
+#ifdef Q_OS_LINUX
+            if( !success ) {
+                kDebug() << "(K3b::Device::Device) MMC READ TOC failed. falling back to cdrom.h.";
+                readTocLinux(toc);
+            }
+#endif
+
+            if( success )
+                fixupToc( toc );
+        }
+    }
+
+    if( needToClose )
+        close();
+
+    return toc;
+}
+
+
+void K3b::Device::Device::readIsrcMcn( K3b::Device::Toc& toc ) const
+{
+    // read MCN and ISRC of all tracks
+    QByteArray mcn;
+    if( readMcn( mcn ) ) {
+        toc.setMcn( mcn );
+        kDebug() << "(K3b::Device::Device) found MCN: " << mcn;
+    }
+    else
+        kDebug() << "(K3b::Device::Device) no MCN found.";
+
+    for( int i = 1; i <= toc.count(); ++i ) {
+        QByteArray isrc;
+        if( toc[i-1].type() == Track::TYPE_AUDIO ) {
+            if( readIsrc( i, isrc ) ) {
+                kDebug() << "(K3b::Device::Device) found ISRC for track " << i << ": " << isrc;
+                toc[i-1].setIsrc( isrc );
+            }
+            else
+                kDebug() << "(K3b::Device::Device) no ISRC found for track " << i;
+        }
+    }
+}
+
+
+bool K3b::Device::Device::readFormattedToc( K3b::Device::Toc& toc, int mt ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    bool success = false;
+
+    toc.clear();
+
+    int lastTrack = 0;
+
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+    if( !(mt & MEDIA_CD_ALL) ) {
+        //
+        // on DVD-R(W) multisession disks only two sessions are represented as tracks in the readTocPmaAtip
+        // response (fabricated TOC). Thus, we use readDiscInformation for DVD media to get the proper number of tracks
+        //
+        if( readDiscInformation( &data, dataLen ) ) {
+            lastTrack = (int)( data[11]<<8 | data[6] );
+
+            delete [] data;
+
+            if( readTrackInformation( &data, dataLen, 1, lastTrack ) ) {
+                track_info_t* trackInfo = (track_info_t*)data;
+
+                if( trackInfo->blank ) {
+                    lastTrack--;
+                }
+
+                delete [] data;
+
+                success = true;
+            }
+            else
+                return false;
+        }
+        else
+            return false;
+    }
+    else {
+        if( readTocPmaAtip( &data, dataLen, 0, 0, 1 ) ) {
+
+            if( dataLen < 4 ) {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": formatted toc data too small.";
+            }
+            else if( dataLen != ( (unsigned int)sizeof(toc_track_descriptor) * ((unsigned int)data[3]+1) ) + 4 ) {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": invalid formatted toc data length: "
+                         << (dataLen-2) << endl;
+            }
+            else {
+                lastTrack = data[3];
+                toc_track_descriptor* td = (toc_track_descriptor*)&data[4];
+                for( int i = 0; i < lastTrack; ++i ) {
+
+                    Track track;
+                    unsigned int control = 0;
+
+                    //
+                    // In case READ TRACK INFORMATION fails:
+                    // no session number info
+                    // no track length and thus possibly incorrect last sector for
+                    // multisession disks
+                    //
+                    track.setFirstSector( from4Byte( td[i].start_adr ) );
+                    track.setLastSector( from4Byte( td[i+1].start_adr ) - 1 );
+                    control = td[i].control;
+
+                    track.setType( (control & 0x4) ? Track::TYPE_DATA : Track::TYPE_AUDIO );
+                    track.setMode( getTrackDataMode( track ) );
+                    track.setCopyPermitted( control & 0x2 );
+                    track.setPreEmphasis( control & 0x1 );
+
+                    toc.append( track );
+                }
+
+                success = true;
+            }
+
+            delete [] data;
+        }
+    }
+
+
+    //
+    // Try to get information for all the tracks
+    //
+    for( int i = 0; i < lastTrack; ++i ) {
+        if( toc.count() < i+1 )
+            toc.append( Track() );
+
+        unsigned char* trackData = 0;
+        unsigned int trackDataLen = 0;
+        if( readTrackInformation( &trackData, trackDataLen, 1, i+1 ) ) {
+            track_info_t* trackInfo = (track_info_t*)trackData;
+
+            toc[i].setFirstSector( from4Byte( trackInfo->track_start ) );
+
+            if( i > 0 && toc[i-1].lastSector() == 0 )
+                toc[i-1].setLastSector( toc[i].firstSector() - 1 );
+
+            // There are drives that return 0 track length here!
+            // Some drives even return an invalid length here. :(
+            if( from4Byte( trackInfo->track_size ) > 0 )
+                toc[i].setLastSector( toc[i].firstSector() + from4Byte( trackInfo->track_size ) - 1 );
+
+            if( trackInfo->nwa_v ) {
+                toc[i].setNextWritableAddress( from4Byte( trackInfo->next_writable ) );
+                toc[i].setFreeBlocks( from4Byte( trackInfo->free_blocks ) );
+            }
+
+            toc[i].setSession( (int)((trackInfo->session_number_m<<8 & 0xf0) |
+                                     (trackInfo->session_number_l & 0x0f)) );  //FIXME: is this BCD?
+
+            int control = trackInfo->track_mode;
+
+            if( mt & MEDIA_CD_ALL ) {
+                toc[i].setType( (control & 0x4) ? Track::TYPE_DATA : Track::TYPE_AUDIO );
+                toc[i].setMode( getTrackDataMode( toc[i] ) );
+            }
+            else {
+                toc[i].setType( Track::TYPE_DATA );
+                toc[i].setMode( Track::DVD );
+            }
+            toc[i].setCopyPermitted( control & 0x2 );
+            toc[i].setPreEmphasis( control & 0x1 );
+
+            delete [] trackData;
+        }
+        else if( !(mt & MEDIA_CD_ALL) ) {
+            success = false;
+        }
+    }
+
+    // this can only happen with DVD media
+    if( !toc.isEmpty() && toc.last().lastSector() == 0 ) {
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " no track length for the last non-empty track.";
+        unsigned char* trackData = 0;
+        unsigned int trackDataLen = 0;
+        if( readTrackInformation( &trackData, trackDataLen, 1, lastTrack+1 ) ) {
+            track_info_t* trackInfo = (track_info_t*)trackData;
+
+            toc.last().setLastSector( from4Byte( trackInfo->track_start ) - 1 );
+
+            delete [] trackData;
+        }
+    }
+
+
+    if( needToClose )
+        close();
+
+    return success;
+}
+
+
+bool K3b::Device::Device::readRawToc( K3b::Device::Toc& toc ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    bool success = false;
+
+    toc.clear();
+
+    if( open() ) {
+        //
+        // Read Raw TOC (format: 0010b)
+        //
+        // For POINT from 01h-63h we get all the tracks
+        // POINT a1h gices us the last track number in the session in PMIN
+        // POINT a2h gives the start of the session lead-out in PMIN,PSEC,PFRAME
+        //
+
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+
+        if( readTocPmaAtip( &data, dataLen, 2, false, 1 ) ) {
+            if( dataLen > 4 ) {
+                success = true;
+
+                toc_raw_track_descriptor* tr = (toc_raw_track_descriptor*)&data[4];
+
+                //
+                // debug the raw toc data
+                //
+                kDebug() << "Session |  ADR   | CONTROL|  TNO   | POINT  |  Min   |  Sec   | Frame  |  Zero  |  PMIN  |  PSEC  | PFRAME |";
+                for( unsigned int i = 0; i < (dataLen-4)/(int)sizeof(toc_raw_track_descriptor); ++i ) {
+                    QString s;
+                    s += QString( " %1 |" ).arg( (int)tr[i].session_number, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].adr, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].control, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].tno, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].point, 6, 16 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].min, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].sec, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].frame, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].zero, 6, 16 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].p_min, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].p_sec, 6 );
+                    s += QString( " %1 |" ).arg( (int)tr[i].p_frame, 6 );
+                    kDebug() << s;
+                }
+
+                //
+                // First we try to determine if the raw toc data uses BCD values
+                //
+                int isBcd = rawTocDataWithBcdValues( data, dataLen );
+                if( isBcd == -1 ) {
+                    delete [] data;
+                    return false;
+                }
+
+                K3b::Msf sessionLeadOut;
+
+                for( unsigned int i = 0; i < (dataLen-4)/(unsigned int)sizeof(toc_raw_track_descriptor); ++i ) {
+                    if( tr[i].adr == 1 && tr[i].point <= 0x63 ) {
+                        // track
+                        Track track;
+                        track.setSession( tr[i].session_number );
+
+                        // :( We use 00:00:00 == 0 lba)
+                        if( isBcd )
+                            track.setFirstSector( K3b::Msf( K3b::Device::fromBcd(tr[i].p_min),
+                                                            K3b::Device::fromBcd(tr[i].p_sec),
+                                                            K3b::Device::fromBcd(tr[i].p_frame) ) - 150 );
+                        else
+                            track.setFirstSector( K3b::Msf( tr[i].p_min, tr[i].p_sec, tr[i].p_frame ) - 150 );
+
+                        track.setType( tr[i].control & 0x4 ? Track::TYPE_DATA : Track::TYPE_AUDIO );
+                        track.setMode( track.type() == Track::TYPE_DATA ? getTrackDataMode(track) : Track::UNKNOWN );
+                        track.setCopyPermitted( tr[i].control & 0x2 );
+                        track.setPreEmphasis( tr[i].control & 0x1 );
+
+                        //
+                        // only do this within a session because otherwise we already set the last sector with the session leadout
+                        //
+                        if( !toc.isEmpty() )
+                            if( toc[toc.count()-1].session() == track.session() )
+                                toc[toc.count()-1].setLastSector( track.firstSector() - 1 );
+
+                        toc.append(track);
+                    }
+                    else if( tr[i].point == 0xa2 ) {
+                        //
+                        // since the session is always reported before the tracks this is where we do this:
+                        // set the previous session's last tracks's last sector to the first sector of the
+                        // session leadout (which was reported before the tracks)
+                        //
+                        // This only happens on multisession CDs
+                        //
+                        if( !toc.isEmpty() )
+                            toc[toc.count()-1].setLastSector( sessionLeadOut - 1 );
+
+                        // this is save since the descriptors are reported in ascending order of the session number
+                        // :( We use 00:00:00 == 0 lba)
+                        if( isBcd )
+                            sessionLeadOut = K3b::Msf( K3b::Device::fromBcd(tr[i].p_min),
+                                                       K3b::Device::fromBcd(tr[i].p_sec),
+                                                       K3b::Device::fromBcd(tr[i].p_frame) ) - 150;
+                        else
+                            sessionLeadOut = K3b::Msf( tr[i].p_min, tr[i].p_sec, tr[i].p_frame ) - 150;
+                    }
+                }
+
+                kDebug() << blockDeviceName() << ": setting last sector of last track to " << (sessionLeadOut-1).lba();
+
+                // set the last track's last sector
+                if( !toc.isEmpty() )
+                    toc[toc.count()-1].setLastSector( sessionLeadOut - 1 );
+            }
+            else
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " empty raw toc.";
+
+            delete [] data;
+        }
+    }
+
+    if( needToClose )
+        close();
+
+    return success;
+}
+
+
+int K3b::Device::Device::rawTocDataWithBcdValues( unsigned char* data, unsigned int dataLen ) const
+{
+    toc_raw_track_descriptor* tr = (toc_raw_track_descriptor*)&data[4];
+
+    bool notBcd = false;
+    bool notHex = false;
+
+    //
+    // in most cases this will already tell us if a drive does not provide bcd numbers
+    // (which should be all newer MMC drives)
+    //
+    for( unsigned int i = 0; i < (dataLen-4)/(unsigned int)sizeof(toc_raw_track_descriptor); ++i ) {
+        if( tr[i].adr == 1 && tr[i].point <= 0xa2) {
+            if( !K3b::Device::isValidBcd(tr[i].p_min) ||
+                !K3b::Device::isValidBcd(tr[i].p_sec) ||
+                !K3b::Device::isValidBcd(tr[i].p_frame) ) {
+                notBcd = true;
+                break;
+            }
+
+            // we only need to check sec and frame since min needs to be <= 99
+            // and bcd values are never bigger than 99.
+            else if( (int)K3b::Device::fromBcd(tr[i].p_sec) >= 60 ||
+                     (int)K3b::Device::fromBcd(tr[i].p_frame) >= 75 ) {
+                notBcd = true;
+                break;
+            }
+        }
+    }
+
+
+    //
+    // all values are valid bcd values but we still don't know for sure if they are really
+    // used as bcd. So we also check the HEX values.
+    //
+    for( unsigned int i = 0; i < (dataLen-4)/(unsigned int)sizeof(toc_raw_track_descriptor); ++i ) {
+        if( tr[i].adr == 1 && tr[i].point <= 0xa2 ) {
+            if( (int)tr[i].p_min > 99 ||
+                (int)tr[i].p_sec >= 60 ||
+                (int)tr[i].p_frame >= 75 ) {
+                notHex = true;
+                break;
+            }
+        }
+    }
+
+
+    //
+    // If all values are valid bcd and valid hex we check the start sectors of the tracks.
+    //
+    if( !notHex || !notBcd ) {
+        K3b::Msf sessionLeadOutHex, sessionLeadOutBcd;
+        K3b::Msf lastTrackHex, lastTrackBcd;
+
+        for( unsigned int i = 0; i < (dataLen-4)/(unsigned int)sizeof(toc_raw_track_descriptor); ++i ) {
+
+            if( tr[i].adr == 1 ) {
+                if( tr[i].point < 0x64 ) {
+
+                    // check hex values
+                    if( K3b::Msf( tr[i].p_min, tr[i].p_sec, tr[i].p_frame ) <
+                        lastTrackHex )
+                        notHex = true;
+
+                    // check bcd values
+                    if( K3b::Msf( K3b::Device::fromBcd(tr[i].p_min), K3b::Device::fromBcd(tr[i].p_sec), K3b::Device::fromBcd(tr[i].p_frame) ) <
+                        lastTrackBcd )
+                        notBcd = true;
+
+                    lastTrackBcd = K3b::Msf( K3b::Device::fromBcd(tr[i].p_min), K3b::Device::fromBcd(tr[i].p_sec), K3b::Device::fromBcd(tr[i].p_frame) );
+                    lastTrackHex = K3b::Msf( tr[i].p_min, tr[i].p_sec, tr[i].p_frame );
+                }
+                else if( tr[i].point == 0xa2 ) {
+                    if( sessionLeadOutHex < lastTrackHex )
+                        notHex = true;
+                    if( sessionLeadOutBcd < lastTrackBcd )
+                        notBcd = true;
+
+                    sessionLeadOutHex = K3b::Msf( tr[i].p_min, tr[i].p_sec, tr[i].p_frame );
+                    sessionLeadOutBcd = K3b::Msf( K3b::Device::fromBcd(tr[i].p_min), K3b::Device::fromBcd(tr[i].p_sec), K3b::Device::fromBcd(tr[i].p_frame) );
+                }
+            }
+        }
+
+        // check the last track
+        if( sessionLeadOutHex < lastTrackHex )
+            notHex = true;
+        if( sessionLeadOutBcd < lastTrackBcd )
+            notBcd = true;
+    }
+
+
+    if( !notBcd && !notHex ) {
+        kDebug() << "(K3b::Device::Device) need to compare raw toc to formatted toc. :(";
+        //
+        // All values are valid bcd and valid HEX values so we compare with the formatted toc.
+        // This slows us down a lot but in most cases this should not be reached anyway.
+        //
+        // TODO: also check the bcd values
+        //
+        K3b::Device::Toc formattedToc;
+        if( readFormattedToc( formattedToc, MEDIA_CD_ROM ) ) {
+            for( unsigned int i = 0; i < (dataLen-4)/(unsigned int)sizeof(toc_raw_track_descriptor); ++i ) {
+                if( tr[i].adr == 1 && tr[i].point < 0x64 ) {
+                    unsigned int track = (int)tr[i].point;
+
+                    // FIXME: do bcd drive also encode the track number in bcd? If so test it, too.
+
+                    if( ( int )track > formattedToc.count() ) {
+                        notHex = true;
+                        break;
+                    }
+
+                    K3b::Msf posHex( tr[i].p_min,
+                                     tr[i].p_sec,
+                                     tr[i].p_frame );
+                    K3b::Msf posBcd( K3b::Device::fromBcd(tr[i].p_min),
+                                     K3b::Device::fromBcd(tr[i].p_sec),
+                                     K3b::Device::fromBcd(tr[i].p_frame) );
+                    posHex -= 150;
+                    posBcd -= 150;
+                    if( posHex != formattedToc[track-1].firstSector() )
+                        notHex = true;
+                    if( posBcd != formattedToc[track-1].firstSector() )
+                        notBcd = true;
+                }
+            }
+        }
+    }
+
+    if( notBcd )
+        kDebug() << "(K3b::Device::Device) found invalid bcd values. No bcd toc.";
+    if( notHex )
+        kDebug() << "(K3b::Device::Device) found invalid hex values. No hex toc.";
+
+    if( notBcd == notHex ) {
+        kDebug() << "(K3b::Device::Device) unable to determine if hex (" << notHex << ") or bcd (" << notBcd << ").";
+        if( !notHex ) {
+            kDebug() << "Assuming hex encoding in favor of newer drives and the more reliable raw toc.";
+            return 0;
+        }
+        return -1;
+    }
+    else if( notBcd )
+        return 0;
+    else
+        return 1;
+}
+
+
+K3b::Device::CdText K3b::Device::Device::readCdText() const
+{
+    return CdText( readRawCdText() );
+}
+
+
+QByteArray K3b::Device::Device::readRawCdText( bool* success ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    QByteArray textData;
+
+    if ( success )
+        *success = false;
+
+    if( open() ) {
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+
+        if( readTocPmaAtip( &data, dataLen, 5, false, 0 ) ) {
+            // we need more than the header and a multiple of 18 bytes to have valid CD-TEXT
+            if( dataLen > 4 && dataLen%18 == 4 ) {
+                textData.append( QByteArray( reinterpret_cast<char*>(data), dataLen ) );
+                if ( success )
+                    *success = true;
+            }
+            else {
+                kDebug() << "invalid CD-TEXT length: " << dataLen;
+            }
+
+            delete [] data;
+        }
+
+        if( needToClose )
+            close();
+    }
+
+    return textData;
+}
+
+
+#ifdef Q_OS_LINUX
+// fallback
+bool K3b::Device::Device::readTocLinux( K3b::Device::Toc& toc ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    bool success = true;
+
+    toc.clear();
+
+    struct cdrom_tochdr tochdr;
+    struct cdrom_tocentry tocentry;
+
+    usageLock();
+    if( open() ) {
+        //
+        // CDROMREADTOCHDR ioctl returns:
+        // cdth_trk0: First Track Number
+        // cdth_trk1: Last Track Number
+        //
+        if( ::ioctl( d->deviceHandle, CDROMREADTOCHDR, &tochdr ) ) {
+            kDebug() << "(K3b::Device::Device) could not get toc header !";
+            success = false;
+        }
+        else {
+            Track lastTrack;
+            for (int i = tochdr.cdth_trk0; i <= tochdr.cdth_trk1 + 1; i++) {
+                ::memset(&tocentry,0,sizeof (struct cdrom_tocentry));
+                // get Lead-Out Information too
+                tocentry.cdte_track = (i<=tochdr.cdth_trk1) ? i : CDROM_LEADOUT;
+                tocentry.cdte_format = CDROM_LBA;
+                //
+                // CDROMREADTOCENTRY ioctl returns:
+                // cdte_addr.lba: Start Sector Number (LBA Format requested)
+                // cdte_ctrl:     4 ctrl bits
+                //                   00x0b: 2 audio Channels(no pre-emphasis)
+                //                   00x1b: 2 audio Channels(pre-emphasis)
+                //                   10x0b: audio Channels(no pre-emphasis),reserved in cd-rw
+                //                   10x1b: audio Channels(pre-emphasis),reserved in cd-rw
+                //                   01x0b: data track, recorded uninterrupted
+                //                   01x1b: data track, recorded incremental
+                //                   11xxb: reserved
+                //                   xx0xb: digital copy prohibited
+                //                   xx1xb: digital copy permitted
+                // cdte_addr:     4 addr bits (type of Q-Subchannel data)
+                //                   0000b: no Information
+                //                   0001b: current position data
+                //                   0010b: MCN
+                //                   0011b: ISRC
+                //                   0100b-1111b:  reserved
+                // cdte_datamode:  0: Data Mode1
+                //                 1: CD-I
+                //                 2: CD-XA Mode2
+                //
+
+                if( ::ioctl( d->deviceHandle, CDROMREADTOCENTRY, &tocentry ) ) {
+                    kDebug() << "(K3b::Device::Device) error reading tocentry " << i;
+                    success = false;
+                    break;
+                }
+
+                int startSec = tocentry.cdte_addr.lba;
+                int control  = tocentry.cdte_ctrl & 0x0f;
+                int mode     = tocentry.cdte_datamode;
+                if( i > tochdr.cdth_trk0 ) {
+                    Track track( lastTrack.firstSector(), startSec-1, lastTrack.type(), lastTrack.mode() );
+                    track.setPreEmphasis( control & 0x1 );
+                    track.setCopyPermitted( control & 0x2 );
+                    toc.append( track );
+                }
+                Track::TrackType trackType = Track::TYPE_UNKNOWN;
+                Track::DataMode trackMode = Track::UNKNOWN;
+                if( (control & 0x04 ) && (tocentry.cdte_track != CDROM_LEADOUT) ) {
+                    trackType = Track::TYPE_DATA;
+                    if( mode == 1 )
+                        trackMode = Track::MODE1;
+                    else if( mode == 2 )
+                        trackMode = Track::MODE2;
+
+                    Track::DataMode tm = getDataMode(startSec);
+                    if( tm != Track::UNKNOWN )
+                        trackMode = tm;
+                }
+                else
+                    trackType = Track::TYPE_AUDIO;
+
+                lastTrack = Track( startSec, startSec, trackType, trackMode );
+            }
+        }
+
+        if( needToClose )
+            close();
+    }
+    else
+        success = false;
+
+    usageUnlock();
+
+    return success;
+}
+#endif // Q_OS_LINUX
+
+
+bool K3b::Device::Device::fixupToc( K3b::Device::Toc& toc ) const
+{
+    bool success = false;
+
+    //
+    // This is a very lame method of fixing the TOC of an Advanced Audio CD
+    // (a CD with two sessions: one with audio tracks and one with the data track)
+    // If a drive does not support reading raw toc or reading track info we only
+    // get every track's first sector. But between sessions there is a gap which is used
+    // for ms stuff. In this case it's 11400 sectors in size. When ripping ausio we would
+    // include these 11400 sectors which would result in a strange ending audio file.
+    //
+    if( numSessions() > 1 || toc.contentType() == MIXED ) {
+        kDebug() << "(K3b::Device::Device) fixup multisession toc...";
+
+        //
+        // we need to update the last sector of every last track in every session
+        // for now we only update the track before the last session...
+        // This is the most often case: Advanced Audio CD
+        //
+
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+        if( readTocPmaAtip( &data, dataLen, 1, false, 0 ) ) {
+
+            //
+            // data[6]    - first track number in last complete session
+            // data[8-11] - start address of first track in last session
+            //
+
+            toc[(unsigned int)data[6]-2].setLastSector( from4Byte( &data[8] ) - 11400 - 1 );
+
+            delete [] data;
+            success = true;
+        }
+        else
+            kDebug() << "(K3b::Device::Device) FIXUP TOC failed.";
+    }
+
+    return success;
+}
+
+
+bool K3b::Device::Device::block( bool b ) const
+{
+    //
+    // For some reason the Scsi Command does not work here.
+    // So we use the ioctl on Linux systems
+    //
+#if defined(Q_OS_LINUX)
+    bool success = false;
+    bool needToClose = !isOpen();
+    usageLock();
+    if( open() ) {
+        success = ( ::ioctl( d->deviceHandle, CDROM_LOCKDOOR, b ? 1 : 0 ) == 0 );
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#elif defined(Q_OS_NETBSD)
+    bool success = false;
+    bool needToClose = !isOpen();
+    int arg = b ? 1 : 0;
+    usageLock();
+    if( open() ) {
+        success = ( ::ioctl( d->deviceHandle, DIOCLOCK, &arg ) == 0 );
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#endif
+
+    ScsiCommand cmd( this );
+    cmd[0] = MMC_PREVENT_ALLOW_MEDIUM_REMOVAL;
+    cmd[5] = 0; // Necessary to set the proper command length
+    if( b )
+        cmd[4] = 0x01;
+    int r = cmd.transport( TR_DIR_WRITE );
+
+    if( r )
+        kDebug() << "(K3b::Device::Device) MMC ALLOW MEDIA REMOVAL failed.";
+
+    return ( r == 0 );
+}
+
+bool K3b::Device::Device::rewritable() const
+{
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+
+    if( readDiscInformation( &data, dataLen ) ) {
+        disc_info_t* inf = (disc_info_t*)data;
+        bool e = inf->erasable;
+
+        delete [] data;
+
+        return e;
+    }
+    else
+        return false;
+}
+
+
+bool K3b::Device::Device::eject() const
+{
+#ifdef Q_OS_NETBSD
+    bool success = false;
+    bool needToClose = !isOpen();
+    int arg = 0;
+
+    usageLock();
+    if( open() ) {
+        if ( ::ioctl( d->deviceHandle, DIOCEJECT, &arg ) >= 0)
+            success = true;
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#elif defined(Q_OS_LINUX)
+    bool success = false;
+    bool needToClose = !isOpen();
+
+    usageLock();
+    if( open() ) {
+        if( ::ioctl( d->deviceHandle, CDROMEJECT ) >= 0 )
+            success = true;
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#endif
+
+    ScsiCommand cmd( this );
+    cmd[0] = MMC_PREVENT_ALLOW_MEDIUM_REMOVAL;
+    cmd[5] = 0; // Necessary to set the proper command length
+    cmd.transport( TR_DIR_WRITE );
+
+    cmd[0] = MMC_START_STOP_UNIT;
+    cmd[5] = 0; // Necessary to set the proper command length
+    cmd[4] = 0x2;      // eject medium LoEj = 1, Start = 0
+    return !cmd.transport( TR_DIR_WRITE );
+}
+
+
+bool K3b::Device::Device::load() const
+{
+#ifdef Q_OS_NETBSD
+    bool success = false;
+    bool needToClose = !isOpen();
+    int arg = 0;
+
+    usageLock();
+    if( open() ) {
+        if ( ::ioctl( d->deviceHandle, CDIOCCLOSE, &arg ) >= 0)
+            success = true;
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#elif defined(Q_OS_LINUX)
+    bool success = false;
+    bool needToClose = !isOpen();
+
+    usageLock();
+    if( open() ) {
+        if( ::ioctl( d->deviceHandle, CDROMCLOSETRAY ) >= 0 )
+            success = true;
+        if( needToClose )
+            close();
+    }
+    usageUnlock();
+    if ( success )
+        return success;
+#endif
+
+    ScsiCommand cmd( this );
+    cmd[0] = MMC_START_STOP_UNIT;
+    cmd[4] = 0x3;    // LoEj = 1, Start = 1
+    cmd[5] = 0;      // Necessary to set the proper command length
+    return !cmd.transport();
+}
+
+
+bool K3b::Device::Device::setAutoEjectEnabled( bool enabled ) const
+{
+    bool success = false;
+#ifdef Q_OS_LINUX
+
+    bool needToClose = !isOpen();
+    usageLock();
+    if ( open() ) {
+        success = ( ::ioctl( d->deviceHandle, CDROMEJECT_SW, enabled ? 1 : 0 ) == 0 );
+        if ( needToClose ) {
+            close();
+        }
+    }
+    usageUnlock();
+#endif
+    return success;
+}
+
+
+K3b::Device::Device::Handle K3b::Device::Device::handle() const
+{
+    return d->deviceHandle;
+}
+
+
+bool K3b::Device::Device::open( bool write ) const
+{
+    if( d->openedReadWrite != write )
+        close();
+
+    QMutexLocker ml( &d->openCloseMutex );
+
+    d->openedReadWrite = write;
+
+    if( d->deviceHandle == HANDLE_DEFAULT_VALUE)
+        d->deviceHandle = openDevice( QFile::encodeName(blockDeviceName()), write );
+
+    return ( d->deviceHandle != HANDLE_DEFAULT_VALUE);
+}
+
+
+void K3b::Device::Device::close() const
+{
+    QMutexLocker ml( &d->openCloseMutex );
+
+    if( d->deviceHandle == HANDLE_DEFAULT_VALUE)
+        return;
+
+#if defined(Q_OS_FREEBSD)
+    cam_close_device(d->deviceHandle);
+#elif defined(Q_OS_WIN32)
+    CloseHandle(d->deviceHandle);
+#else
+    ::close( d->deviceHandle );
+#endif
+    d->deviceHandle = HANDLE_DEFAULT_VALUE;
+}
+
+
+bool K3b::Device::Device::isOpen() const
+{
+    return ( d->deviceHandle != HANDLE_DEFAULT_VALUE);
+}
+
+
+int K3b::Device::Device::supportedProfiles() const
+{
+    return d->supportedProfiles;
+}
+
+
+int K3b::Device::Device::currentProfile() const
+{
+    unsigned char profileBuf[8];
+    ::memset( profileBuf, 0, 8 );
+
+    ScsiCommand cmd( this );
+    cmd[0] = MMC_GET_CONFIGURATION;
+    cmd[1] = 1;
+    cmd[8] = 8;
+    cmd[9] = 0;      // Necessary to set the proper command length
+
+    if( cmd.transport( TR_DIR_READ, profileBuf, 8 ) ) {
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                 << " GET_CONFIGURATION failed." << endl;
+        return MEDIA_UNKNOWN;
+    }
+    else {
+        short profile = from2Byte( &profileBuf[6] );
+
+        //
+        // Plextor drives might not set a current profile
+        // In that case we get the list of all current profiles
+        // and simply use the first one in that list.
+        //
+        if( profile == 0x00 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                     << " current profile 0. Checking current profile list instead." << endl;
+            unsigned char* data;
+            unsigned int len = 0;
+            if( getFeature( &data, len, FEATURE_PROFILE_LIST ) ) {
+                int featureLen( data[11] );
+                for( int j = 0; j < featureLen; j+=4 ) {
+                    // use the first current profile we encounter
+                    if( data[12+j+2] & 0x1 ) {
+                        profile = from2Byte( &data[12+j] );
+                        break;
+                    }
+                }
+
+                delete[] data;
+            }
+        }
+
+        switch (profile) {
+        case 0x00: return MEDIA_NONE;
+        case 0x08: return MEDIA_CD_ROM;
+        case 0x09: return MEDIA_CD_R;
+        case 0x0A: return MEDIA_CD_RW;
+        case 0x10: return MEDIA_DVD_ROM;
+        case 0x11: return MEDIA_DVD_R_SEQ;
+        case 0x12: return MEDIA_DVD_RAM;
+        case 0x13: return MEDIA_DVD_RW_OVWR;
+        case 0x14: return MEDIA_DVD_RW_SEQ;
+        case 0x15: return MEDIA_DVD_R_DL_SEQ;
+        case 0x16: return MEDIA_DVD_R_DL_JUMP;
+        case 0x1A: return MEDIA_DVD_PLUS_RW;
+        case 0x1B: return MEDIA_DVD_PLUS_R;
+        case 0x2B: return MEDIA_DVD_PLUS_R_DL;
+        case 0x40: return MEDIA_BD_ROM;
+        case 0x41: {
+            if( featureCurrent( FEATURE_BD_PSEUDO_OVERWRITE ) == 1 )
+                return MEDIA_BD_R_SRM_POW;
+            else
+                return MEDIA_BD_R_SRM;
+        }
+        case 0x42: return MEDIA_BD_R_RRM;
+        case 0x43: return MEDIA_BD_RE;
+        case 0x50: return MEDIA_HD_DVD_ROM;
+        case 0x51: return MEDIA_HD_DVD_R;
+        case 0x52: return MEDIA_HD_DVD_RAM;
+        default: return MEDIA_UNKNOWN;
+        }
+    }
+}
+
+
+K3b::Device::DiskInfo K3b::Device::Device::diskInfo() const
+{
+    DiskInfo inf;
+
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    if( open() ) {
+
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+
+        //
+        // The first thing to do should be: checking if a media is loaded
+        // We cannot rely on the profile here since at least some Plextor
+        // drives return the NO MEDIUM profile for CD media
+        //
+        if( !testUnitReady() ) {
+            // no disk or tray open
+            inf.d->diskState = STATE_NO_MEDIA;
+            inf.d->mediaType = MEDIA_NONE;
+            inf.d->currentProfile = MEDIA_NONE;
+        }
+        else
+            inf.d->currentProfile = currentProfile();
+
+        if( inf.diskState() != STATE_NO_MEDIA ) {
+
+            if( readDiscInformation( &data, dataLen ) ) {
+                disc_info_t* dInf = (disc_info_t*)data;
+                //
+                // Copy the needed values from the disk_info struct
+                //
+                switch( dInf->status ) {
+                case 0:
+                    inf.d->diskState = STATE_EMPTY;
+                    break;
+                case 1:
+                    inf.d->diskState = STATE_INCOMPLETE;
+                    break;
+                case 2:
+                    inf.d->diskState = STATE_COMPLETE;
+                    break;
+                default:
+                    inf.d->diskState = STATE_UNKNOWN;
+                    break;
+                }
+
+                switch( dInf->border ) {
+                case 0:
+                    inf.d->lastSessionState = STATE_EMPTY;
+                    break;
+                case 1:
+                    inf.d->lastSessionState = STATE_INCOMPLETE;
+                    break;
+                case 2:
+                    inf.d->lastSessionState = STATE_COMPLETE;
+                    break;
+                default:
+                    inf.d->lastSessionState = STATE_UNKNOWN;
+                    break;
+                }
+
+                switch( dInf->bg_f_status&0x3 ) {
+                case 0x0:
+                    inf.d->bgFormatState = BG_FORMAT_NONE;
+                    break;
+                case 0x1:
+                    inf.d->bgFormatState = BG_FORMAT_INCOMPLETE;
+                    break;
+                case 0x2:
+                    inf.d->bgFormatState = BG_FORMAT_IN_PROGRESS;
+                    break;
+                case 0x3:
+                    inf.d->bgFormatState = BG_FORMAT_COMPLETE;
+                    break;
+                }
+
+                inf.d->numTracks = (dInf->last_track_l & 0xff) | (dInf->last_track_m<<8 & 0xff00);
+                if( inf.diskState() == STATE_EMPTY )
+                    inf.d->numTracks = 0;
+
+                // FIXME: I am not sure if this is accurate. Better test the last track's RT field
+                else if( inf.diskState() == STATE_INCOMPLETE )
+                    inf.d->numTracks--;  // do not count the invisible track
+
+                inf.d->rewritable = dInf->erasable;
+
+                //
+                // This is the Last Possible Lead-Out Start Address in HMSF format
+                // This is only valid for CD-R(W) and DVD+R media.
+                // For complete media this shall be filled with 0xff
+                //
+                if( dInf->lead_out_m != 0xff &&
+                    dInf->lead_out_r != 0xff &&
+                    dInf->lead_out_s != 0xff &&
+                    dInf->lead_out_f != 0xff )
+                    inf.d->capacity = K3b::Msf( dInf->lead_out_m + dInf->lead_out_r*60,
+                                                dInf->lead_out_s,
+                                                dInf->lead_out_f ) - 150;
+
+                //
+                // This is the position where the next Session shall be recorded in HMSF format
+                // This is only valid for CD-R(W) and DVD+R media.
+                // For complete media this shall be filled with 0xff
+                //
+                if( dInf->lead_in_m != 0xff &&
+                    dInf->lead_in_r != 0xff &&
+                    dInf->lead_in_s != 0xff &&
+                    dInf->lead_in_f != 0xff )
+                    inf.d->usedCapacity = K3b::Msf( dInf->lead_in_m + dInf->lead_in_r*60,
+                                                    dInf->lead_in_s,
+                                                    dInf->lead_in_f ) - 4500;
+
+                delete [] data;
+            }
+            else {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                         << " fabricating disk information for a stupid device." << endl;
+                Toc toc = readToc();
+                if( !toc.isEmpty() ) {
+                    inf.d->diskState = STATE_COMPLETE;
+                    inf.d->lastSessionState = STATE_COMPLETE;
+                    inf.d->numTracks = toc.count();
+                    inf.d->capacity = inf.d->usedCapacity = toc.length();
+                }
+            }
+
+
+            //
+            // The mediatype needs to be set
+            //
+            inf.d->mediaType = mediaType();
+
+            // At least some Plextor drives return profile NONE for CD media
+            // or CD_ROM for writable media
+            if( inf.d->mediaType & (MEDIA_UNKNOWN|MEDIA_NONE|MEDIA_CD_ROM) ) {
+                // probably it is a CD
+                if( inf.rewritable() )
+                    inf.d->mediaType = MEDIA_CD_RW;
+                else if( inf.empty() || inf.appendable() )
+                    inf.d->mediaType = MEDIA_CD_R;
+                else
+                    inf.d->mediaType = MEDIA_CD_ROM;
+            }
+
+            if( inf.d->mediaType & MEDIA_DVD_ALL ) {
+                if( readDvdStructure( &data, dataLen ) ) {
+                    // some debugging stuff
+                    K3b::Msf sda, eda, ea0;
+                    sda = ( data[4+5]<<16 | data[4+6] << 8 | data[4+7] );
+                    eda = ( data[4+9]<<16 | data[4+10] << 8 | data[4+11] );
+                    ea0 = ( data[4+13]<<16 | data[4+14] << 8 | data[4+15] );
+
+                    kDebug() << "First sec data area: " << sda.toString()
+                             << " (LBA " << QString::number(sda.lba())
+                             << ") (" << QString::number(sda.mode1Bytes()) << endl;
+                    kDebug() << "Last sec data area: " << eda.toString()
+                             << " (LBA " << QString::number(eda.lba())
+                             << ") (" << QString::number(eda.mode1Bytes()) << " Bytes)" << endl;
+                    kDebug() << "Last sec layer 1: " << ea0.toString()
+                             << " (LBA " << QString::number(ea0.lba())
+                             << ") (" << QString::number(ea0.mode1Bytes()) << " Bytes)" << endl;
+
+
+                    K3b::Msf da0 = ea0 - sda + 1;
+                    K3b::Msf da1 = eda - ea0;
+                    kDebug() << "Layer 1 length: " << da0.toString()
+                             << " (LBA " << QString::number(da0.lba())
+                             << ") (" << QString::number(da0.mode1Bytes()) << " Bytes)" << endl;
+                    kDebug() << "Layer 2 length: " << da1.toString()
+                             << " (LBA " << QString::number(da1.lba())
+                             << ") (" << QString::number(da1.mode1Bytes()) << " Bytes)" << endl;
+
+                    inf.d->numLayers = ((data[6]&0x60) == 0 ? 1 : 2);
+
+                    bool otp = (data[4+2] & 0xF);
+
+                    // ea0 is 0 if the medium does not use Opposite track path
+                    if( otp && ea0 > 0 )
+                        inf.d->firstLayerSize = da0;
+                    else
+                        inf.d->firstLayerSize = 0;
+
+                    delete [] data;
+                }
+                else {
+                    kDebug() << "(K3b::Device::Device) Unable to read DVD structure for num of layers.";
+                    inf.d->numLayers = ( (inf.d->mediaType & MEDIA_WRITABLE_DVD_DL) ? 2 : 1 );
+                }
+            }
+
+
+            //
+            // Number of sessions for non-empty disks
+            //
+            if( inf.diskState() != STATE_EMPTY ) {
+                int sessions = numSessions();
+                if( sessions >= 0 )
+                    inf.d->numSessions = sessions;
+                else
+                    kDebug() << "(K3b::Device::Device) could not get session info via READ TOC/PMA/ATIP.";
+            }
+            else
+                inf.d->numSessions = 0;
+
+            inf.d->mediaId = mediaId( inf.mediaType() );
+
+            //
+            // Now we determine the size:
+
+            // for all empty and appendable media READ FORMAT CAPACITIES should return the proper unformatted size
+            // for complete disks we may use the READ_CAPACITY command or the start sector from the leadout
+            //
+            int media = inf.mediaType();
+            //
+            // Use the profile if available because DVD-ROM units need to treat DVD+-R(W) media as DVD-ROM
+            // if supported at all
+            //
+            if( inf.currentProfile() == MEDIA_DVD_ROM )
+                media = MEDIA_DVD_ROM;
+
+            switch( media ) {
+            case MEDIA_CD_R:
+            case MEDIA_CD_RW:
+                if( inf.d->capacity == 0 ) {
+                    if( readTocPmaAtip( &data, dataLen, 0x4, true, 0 ) ) {
+
+                        struct atip_descriptor* atip = (struct atip_descriptor*)data;
+
+                        if( dataLen >= 11 ) {
+                            inf.d->capacity = K3b::Msf( atip->lead_out_m, atip->lead_out_s, atip->lead_out_f ) - 150;
+                            debugBitfield( &atip->lead_out_m, 3 );
+                            kDebug() << blockDeviceName() << ": ATIP capacity: " << inf.d->capacity.toString();
+                        }
+
+                        delete [] data;
+                    }
+                }
+
+                //
+                // for empty and appendable media capacity and usedCapacity should be filled in from
+                // diskinfo above. If not they are both still 0
+                //
+                if( inf.d->capacity != 0 &&
+                    ( inf.diskState() == STATE_EMPTY || inf.d->usedCapacity != 0 ) ) {
+                    // done.
+                    break;
+                }
+
+            default:
+            case MEDIA_CD_ROM:
+                if( inf.d->capacity > 0 && inf.d->usedCapacity == 0 )
+                    inf.d->usedCapacity = inf.d->capacity;
+
+                if( inf.d->usedCapacity == 0 ) {
+                    K3b::Msf readCap;
+                    if( readCapacity( readCap ) ) {
+                        kDebug() << "(K3b::Device::Device) READ CAPACITY: " << readCap.toString()
+                                 << " other capacity: " << inf.d->capacity.toString() << endl;
+                        //
+                        // READ CAPACITY returns the last written sector
+                        // that means the size is actually readCap + 1
+                        //
+                        inf.d->usedCapacity = readCap + 1;
+                    }
+                    else {
+                        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                                 << " Falling back to readToc for capacity." << endl;
+                        inf.d->usedCapacity = readToc().length();
+                    }
+                }
+
+            case MEDIA_DVD_ROM: {
+                K3b::Msf readCap;
+                if( readCapacity( readCap ) ) {
+                    kDebug() << "(K3b::Device::Device) READ CAPACITY: " << readCap.toString()
+                             << " other capacity: " << inf.d->capacity.toString() << endl;
+                    //
+                    // READ CAPACITY returns the last written sector
+                    // that means the size is actually readCap + 1
+                    //
+                    inf.d->usedCapacity = readCap + 1;
+                }
+                else {
+                    //
+                    // Only one track, use it's size
+                    //
+                    if( readTrackInformation( &data, dataLen, 0x1, 0x1 ) ) {
+                        track_info_t* trackInfo = (track_info_t*)data;
+                        inf.d->usedCapacity = from4Byte( trackInfo->track_size );
+                        delete [] data;
+                    }
+                    else
+                        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                                 << "READ TRACK INFORMATION for DVD-ROM failed." << endl;
+                }
+
+                break;
+            }
+
+            case MEDIA_DVD_PLUS_R:
+            case MEDIA_DVD_PLUS_R_DL:
+                if( inf.appendable() || inf.empty() ) {
+                    //
+                    // get remaining space via the invisible track
+                    //
+                    if( readTrackInformation( &data, dataLen, 0x1, /*0xff*/ inf.numTracks()+1 ) ) {
+                        track_info_t* trackInfo = (track_info_t*)data;
+                        inf.d->usedCapacity = from4Byte( trackInfo->track_start );
+                        inf.d->capacity = from4Byte( trackInfo->track_start ) + from4Byte( trackInfo->track_size );
+                        delete [] data;
+                    }
+                }
+                else {
+                    if( readTrackInformation( &data, dataLen, 0x1, inf.numTracks() ) ) {
+                        track_info_t* trackInfo = (track_info_t*)data;
+                        inf.d->capacity = inf.d->usedCapacity
+                                        = from4Byte( trackInfo->track_start ) + from4Byte( trackInfo->track_size );
+                        delete [] data;
+                    }
+                }
+                break;
+
+            case MEDIA_DVD_R:
+            case MEDIA_DVD_R_SEQ:
+            case MEDIA_DVD_R_DL:
+            case MEDIA_DVD_R_DL_JUMP:
+            case MEDIA_DVD_R_DL_SEQ:
+                //
+                // get data from the incomplete track (which is NOT the invisible track 0xff)
+                // This will fail in case the media is complete!
+                //
+                if( readTrackInformation( &data, dataLen, 0x1, inf.numTracks()+1 ) ) {
+                    track_info_t* trackInfo = (track_info_t*)data;
+                    inf.d->usedCapacity = from4Byte( trackInfo->track_start );
+                    inf.d->capacity = from4Byte( trackInfo->free_blocks ) + from4Byte( trackInfo->track_start );
+                    delete [] data;
+                }
+
+                //
+                // Get the "really" used space without border-out
+                //
+                if( !inf.empty() ) {
+                    K3b::Msf readCap;
+                    if( readCapacity( readCap ) ) {
+                        //
+                        // READ CAPACITY returns the last written sector
+                        // that means the size is actually readCap + 1
+                        //
+                        inf.d->usedCapacity = readCap + 1;
+                    }
+                    else
+                        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                                 << " READ CAPACITY for DVD-R failed." << endl;
+                }
+
+                break;
+
+            case MEDIA_DVD_RW_OVWR:
+                inf.d->numSessions = 1;
+            case MEDIA_DVD_RW:
+            case MEDIA_DVD_RW_SEQ:
+                // only one track on a DVD-RW media
+                if( readTrackInformation( &data, dataLen, 0x1, 0x1 ) ) {
+                    track_info_t* trackInfo = (track_info_t*)data;
+                    inf.d->capacity = from4Byte( trackInfo->track_size );
+                    if( !inf.empty() ) {
+                        if( readFormatCapacity( 0x10, inf.d->capacity ) )
+                            kDebug() << blockDeviceName() << ": Format capacity 0x10: " << inf.d->capacity.toString();
+
+                        inf.d->usedCapacity = from4Byte( trackInfo->track_size );
+                    }
+
+                    delete [] data;
+                }
+                break;
+
+            case MEDIA_DVD_PLUS_RW: {
+                K3b::Msf currentMax;
+                int currentMaxFormat = 0;
+                if( readFormatCapacity( 0x26, inf.d->capacity, &currentMax, &currentMaxFormat ) ) {
+                    if( currentMaxFormat == 0x1 ) { // unformatted or blank media
+                        inf.d->usedCapacity = 0;
+                        inf.d->capacity = currentMax;
+                    }
+                    else {
+                        inf.d->usedCapacity = currentMax;
+                        // Plextor drives tend to screw things up and report invalid values
+                        // for the max format capacity of 1.4 GB DVD media
+                        if ( inf.bgFormatState() == BG_FORMAT_COMPLETE ) {
+                            inf.d->capacity = currentMax;
+                        }
+                    }
+                }
+                else
+                    kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                             << " READ FORMAT CAPACITIES for DVD+RW failed." << endl;
+
+                break;
+            }
+
+            case MEDIA_BD_R:
+            case MEDIA_BD_R_SRM:
+            case MEDIA_BD_R_SRM_POW:
+            case MEDIA_BD_R_RRM:
+                //
+                // get the invisible track's first sector
+                // or the next writable address of the last open track
+                //
+                if( readDiscInformation( &data, dataLen ) ) {
+                    int lastTrack = (int)( data[11]<<8 | data[6] );
+                    delete [] data;
+
+                    if( readTrackInformation( &data, dataLen, 1, lastTrack ) ) {
+
+                        // capacity: last track's start address + last track's size
+                        inf.d->capacity = from4Byte( data+8 ) + from4Byte( data+24 );
+
+                        if( data[6] & 0x80 )
+                            inf.d->usedCapacity = from4Byte( data+8 );
+                        else if( data[7] & 0x1 )
+                            inf.d->usedCapacity = from4Byte( data+12 );
+                        else
+                            inf.d->usedCapacity = inf.d->capacity;
+                        delete [] data;
+                    }
+                }
+                break;
+
+            case MEDIA_BD_RE: {
+                K3b::Msf currentMax;
+                int currentMaxFormat = 0;
+                if ( readFormatCapacity( 0x00, inf.d->capacity, &currentMax, &currentMaxFormat ) ) {
+                    if( currentMaxFormat == 0x1 ) { // unformatted or blank media
+                        inf.d->usedCapacity = 0;
+                        inf.d->capacity = currentMax;
+                    }
+                    else {
+                        inf.d->usedCapacity = currentMax;
+                    }
+                }
+                else
+                    kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                             << " READ FORMAT CAPACITIES for BD-RE failed." << endl;
+                break;
+            }
+
+            case MEDIA_BD_ROM: {
+                K3b::Msf readCap;
+                if( readCapacity( readCap ) ) {
+                    //
+                    // READ CAPACITY returns the last written sector
+                    // that means the size is actually readCap + 1
+                    //
+                    inf.d->usedCapacity = readCap + 1;
+                }
+
+                break;
+            }
+            }
+        }
+
+        if( needToClose )
+            close();
+    }
+
+    return inf;
+}
+
+
+K3b::Device::MediaType K3b::Device::Device::mediaType() const
+{
+    K3b::Device::MediaType m = MEDIA_UNKNOWN;
+
+    if( testUnitReady() ) {
+
+        int p = currentProfile();
+        if ( p != -1 )
+            m = ( MediaType )p;
+
+        if( m & (MEDIA_UNKNOWN|MEDIA_DVD_ROM|MEDIA_HD_DVD_ROM) ) {
+            //
+            // We prefere the mediatype as reported by the media since this way
+            // even ROM drives may report the correct type of writable media.
+            //
+
+            // 4 bytes header + 2048 bytes layer descriptor
+            unsigned char* data = 0;
+            unsigned int dataLen = 0;
+            if( readDvdStructure( &data, dataLen ) ) {
+                switch( data[4]&0xF0 ) {
+                case 0x00: m = MEDIA_DVD_ROM; break;
+                case 0x10: m = MEDIA_DVD_RAM; break;
+                case 0x20: m = MEDIA_DVD_R; break; // there seems to be no value for DVD-R DL, it reports DVD-R
+                case 0x30: m = MEDIA_DVD_RW; break;
+                case 0x40: m = MEDIA_HD_DVD_ROM; break;
+                case 0x50: m = MEDIA_HD_DVD_R; break;
+                case 0x60: m = MEDIA_HD_DVD_RAM; break;
+                case 0x90: m = MEDIA_DVD_PLUS_RW; break;
+                case 0xA0: m = MEDIA_DVD_PLUS_R; break;
+                case 0xE0: m = MEDIA_DVD_PLUS_R_DL; break;
+                default:
+                    kDebug() << "(K3b::Device::Device) unknown dvd media type: " << QString::number(data[4]&0xF0, 8);
+                    break; // unknown
+                }
+
+                delete [] data;
+            }
+        }
+
+        if( m & (MEDIA_UNKNOWN|MEDIA_BD_ROM) ) {
+            //
+            // We prefere the mediatype as reported by the media since this way
+            // even ROM drives may report the correct type of writable media.
+            //
+
+            unsigned char* data = 0;
+            unsigned int dataLen = 0;
+            if( readDiscStructure( &data, dataLen, 1, 0 ) ) {
+                if( dataLen > 4+12 &&
+                    data[4+8] == 'B' &&  data[4+9] == 'D' ) {
+                    switch( data[4+10] ) {
+                    case 'O': m = MEDIA_BD_ROM; break;
+                    case 'W': m = MEDIA_BD_RE; break;
+                    case 'R': m = MEDIA_BD_R; break;
+                    }
+                }
+
+                delete [] data;
+            }
+        }
+
+        //
+        // Only old CD or DVD devices do not report a current profile
+        // or report CD-ROM profile for all CD types
+        //
+        if( m & (MEDIA_UNKNOWN|MEDIA_CD_ROM) ) {
+            unsigned char* data = 0;
+            unsigned int dataLen = 0;
+            if( readTocPmaAtip( &data, dataLen, 4, false, 0 ) ) {
+                if( (data[6]>>6)&1 )
+                    m = MEDIA_CD_RW;
+                else
+                    m = MEDIA_CD_R;
+
+                delete [] data;
+            }
+            else
+                m = MEDIA_CD_ROM;
+        }
+    }
+
+    return m;
+}
+
+
+bool K3b::Device::Device::readSectorsRaw( unsigned char *buf, int start, int count ) const
+{
+    return readCd( buf, count*2352,
+                   0,      // all sector types
+                   false,  // no dap
+                   start,
+                   count,
+                   true, // SYNC
+                   true, // HEADER
+                   true, // SUBHEADER
+                   true, // USER DATA
+                   true, // EDC/ECC
+                   0,    // no c2 info
+                   0 );
+}
+
+
+
+void K3b::Device::Device::checkForJustLink()
+{
+    unsigned char* ricoh = 0;
+    unsigned int ricohLen = 0;
+    if( modeSense( &ricoh, ricohLen, 0x30 ) ) {
+
+        //
+        // 8 byte mode header + 6 byte page data
+        //
+
+        if( ricohLen >= 14 ) {
+            ricoh_mode_page_30* rp = (ricoh_mode_page_30*)(ricoh+8);
+            d->burnfree = rp->BUEFS;
+        }
+
+        delete [] ricoh;
+    }
+}
+
+
+void K3b::Device::Device::checkFeatures()
+{
+    unsigned char header[1024];
+    ::memset( header, 0, 1024 );
+
+    ScsiCommand cmd( this );
+    cmd[0] = MMC_GET_CONFIGURATION;
+    cmd[1] = 2;
+    cmd[9] = 0;      // Necessary to set the proper command length
+
+
+    //
+    // CD writing features
+    //
+    cmd[2] = FEATURE_CD_MASTERING>>8;
+    cmd[3] = FEATURE_CD_MASTERING;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "CD Mastering";
+#ifdef WORDS_BIGENDIAN
+            struct cd_mastering_feature {
+                unsigned char reserved1 : 1;
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char SAO       : 1;  // Session At Once writing
+                unsigned char raw_ms    : 1;  // Writing Multisession in Raw Writing Mode
+                unsigned char raw       : 1;  // Writing in WRITINGMODE_RAW mode
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char cd_rw     : 1;  // CD-RW support
+                unsigned char rw_sub    : 1;  // Write R-W sub channels with user data
+                unsigned char max_cue_length[3];
+            };
+#else
+            struct cd_mastering_feature {
+                unsigned char rw_sub    : 1;  // Write R-W sub channels with user data
+                unsigned char cd_rw     : 1;  // CD-RW support
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char raw       : 1;  // Writing in WRITINGMODE_RAW mode
+                unsigned char raw_ms    : 1;  // Writing Multisession in Raw Writing Mode
+                unsigned char SAO       : 1;  // Session At Once writing
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char reserved1 : 1;
+                unsigned char max_cue_length[3];
+            };
+#endif
+
+            struct cd_mastering_feature* p = (struct cd_mastering_feature*)&header[12];
+            if( p->BUF ) d->burnfree = true;
+            d->writeCapabilities |= MEDIA_CD_R;
+            if( p->cd_rw )
+                d->writeCapabilities |= MEDIA_CD_RW;
+//       if( p->WRITINGMODE_SAO ) d->writeModes |= WRITINGMODE_SAO;
+//       if( p->raw || p->raw_ms ) d->writeModes |= WRITINGMODE_RAW;  // WRITINGMODE_RAW16 always supported when raw is supported?
+        }
+    }
+
+    cmd[2] = FEATURE_CD_TRACK_AT_ONCE>>8;
+    cmd[3] = FEATURE_CD_TRACK_AT_ONCE;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "CD Track At Once";
+#ifdef WORDS_BIGENDIAN
+            struct cd_track_at_once_feature {
+                unsigned char reserved1 : 1;
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char reserved2 : 1;
+                unsigned char rw_raw    : 1;  // Writing R-W subcode in Raw mode
+                unsigned char rw_pack   : 1;  // Writing R-W subcode in Packet mode
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char cd_rw     : 1;  // CD-RW support
+                unsigned char rw_sub    : 1;  // Write R-W sub channels with user data
+                unsigned char reserved3;
+                unsigned char data_type[2];
+            };
+#else
+            struct cd_track_at_once_feature {
+                unsigned char rw_sub    : 1;  // Write R-W sub channels with user data
+                unsigned char cd_rw     : 1;  // CD-RW support
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char rw_pack   : 1;  // Writing R-W subcode in Packet mode
+                unsigned char rw_raw    : 1;  // Writing R-W subcode in Raw mode
+                unsigned char reserved2 : 1;
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char reserved1 : 1;
+                unsigned char reserved3;
+                unsigned char data_type[2];
+            };
+#endif
+
+            struct cd_track_at_once_feature* p = (struct cd_track_at_once_feature*)&header[12];
+            d->writeModes |= WRITINGMODE_TAO;
+            if( p->BUF ) d->burnfree = true;
+            d->writeCapabilities |= MEDIA_CD_R;
+            if( p->cd_rw )
+                d->writeCapabilities |= MEDIA_CD_RW;
+
+            // is the following correct? What exactly does rw_sub tell us?
+//       if( d->writeModes & WRITINGMODE_RAW ) {
+// 	if( p->rw_raw ) d->writeModes |= WRITINGMODE_RAW_R96R;
+// 	if( p->rw_pack ) d->writeModes |= WRITINGMODE_RAW_R96P;
+//       }
+
+//       // check the data types for 1, 2, and 3 (raw16, raw96p, and raw96r)
+//        debugBitfield( p->data_type, 2 );
+//       if( d->writeModes & WRITINGMODE_RAW ) {
+// 	if( p->data_type[1] & 0x20 ) d->writeModes |= WRITINGMODE_RAW_R16;
+// 	if( p->data_type[1] & 0x40 ) d->writeModes |= WRITINGMODE_RAW_R96P;
+// 	if( p->data_type[1] & 0x80 ) d->writeModes |= WRITINGMODE_RAW_R96R;
+//       }
+        }
+    }
+
+    cmd[2] = FEATURE_CD_RW_MEDIA_WRITE_SUPPORT>>8;
+    cmd[3] = FEATURE_CD_RW_MEDIA_WRITE_SUPPORT;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "CD-RW Media Write Support";
+            d->writeCapabilities |= (MEDIA_CD_R|MEDIA_CD_RW);
+        }
+    }
+
+
+    //
+    // DVD-ROM
+    //
+    // FIXME: since MMC5 the feature descr. is 8 bytes in length including a dvd dl read bit at byte 6
+    cmd[2] = FEATURE_DVD_READ>>8;
+    cmd[3] = FEATURE_DVD_READ;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD Read (MMC5)";
+            d->readCapabilities |= MEDIA_DVD_ROM;
+            if( header[8+6] & 0x1 )
+                d->readCapabilities |= MEDIA_WRITABLE_DVD_DL;
+        }
+    }
+    else {
+        // retry with pre-MMC5 length
+        cmd[8] = 8+4;
+        if( !cmd.transport( TR_DIR_READ, header, 12 ) ) {
+            unsigned int len = from4Byte( header );
+            if( len >= 8 ) {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD Read (pre-MMC5)";
+                d->readCapabilities |= MEDIA_DVD_ROM;
+            }
+        }
+    }
+
+    //
+    // DVD+R(W) writing features
+    //
+    cmd[2] = FEATURE_DVD_PLUS_R>>8;
+    cmd[3] = FEATURE_DVD_PLUS_R;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD+R";
+            d->readCapabilities |= MEDIA_DVD_PLUS_R;
+            if( header[12] & 0x1 )
+                d->writeCapabilities |= MEDIA_DVD_PLUS_R;
+        }
+    }
+
+    cmd[2] = FEATURE_DVD_PLUS_RW>>8;
+    cmd[3] = FEATURE_DVD_PLUS_RW;
+    cmd[8] = 8+8;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD+RW";
+#ifdef WORDS_BIGENDIAN
+            struct dvd_plus_rw_feature {
+                unsigned char reserved1   : 7;
+                unsigned char write       : 1;
+                unsigned char reserved2   : 6;
+                unsigned char quick_start : 1;
+                unsigned char close_only  : 1;
+                // and some stuff we do not use here...
+            };
+#else
+            struct dvd_plus_rw_feature {
+                unsigned char write       : 1;
+                unsigned char reserved1   : 7;
+                unsigned char close_only  : 1;
+                unsigned char quick_start : 1;
+                unsigned char reserved2   : 6;
+                // and some stuff we do not use here...
+            };
+#endif
+
+            struct dvd_plus_rw_feature* p = (struct dvd_plus_rw_feature*)&header[12];
+            d->readCapabilities |= MEDIA_DVD_PLUS_RW;
+            if( p->write )
+                d->writeCapabilities |= MEDIA_DVD_PLUS_RW;
+        }
+    }
+
+
+    // some older DVD-ROM drives claim to support DVD+R DL
+    if( d->writeCapabilities & MEDIA_DVD_PLUS_R ) {
+        cmd[2] = FEATURE_DVD_PLUS_RW_DUAL_LAYER>>8;
+        cmd[3] = FEATURE_DVD_PLUS_RW_DUAL_LAYER;
+        cmd[8] = 8+8;
+        if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+            unsigned int len = from4Byte( header );
+            if( len >= 12 ) {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD+RW Double Layer";
+                d->readCapabilities |= MEDIA_DVD_PLUS_RW_DL;
+                if( header[12] & 0x1 )
+                    d->writeCapabilities |= MEDIA_DVD_PLUS_RW_DL;
+            }
+        }
+
+        cmd[2] = FEATURE_DVD_PLUS_R_DUAL_LAYER>>8;
+        cmd[3] = FEATURE_DVD_PLUS_R_DUAL_LAYER;
+        cmd[8] = 8+8;
+        if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+            unsigned int len = from4Byte( header );
+            if( len >= 12 ) {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD+R Double Layer";
+                d->readCapabilities |= MEDIA_DVD_PLUS_R_DL;
+                if( header[12] & 0x1 )
+                    d->writeCapabilities |= MEDIA_DVD_PLUS_R_DL;
+            }
+        }
+    }
+
+
+    //
+    // Blue Ray
+    //
+    // We do not care for the different BD classes and versions here
+    //
+    cmd[2] = FEATURE_BD_READ>>8;
+    cmd[3] = FEATURE_BD_READ;
+    cmd[8] = 8+32;
+    if( !cmd.transport( TR_DIR_READ, header, 40 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 36 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "BD Read";
+            if( header[8+8] || header[8+9] || header[8+10] || header[8+11] || header[8+12] || header[8+13] || header[8+14] || header[8+15] )
+                d->readCapabilities |= MEDIA_BD_RE;
+            if( header[8+16] || header[8+17] || header[8+18] || header[8+19] || header[8+20] || header[8+21] || header[8+22] || header[8+23] )
+                d->readCapabilities |= MEDIA_BD_R;
+            if( header[8+24] || header[8+25] || header[8+26] || header[8+27] || header[8+28] || header[8+29] || header[8+30] || header[8+31] )
+                d->readCapabilities |= MEDIA_BD_ROM;
+        }
+    }
+
+    cmd[2] = FEATURE_BD_WRITE>>8;
+    cmd[3] = FEATURE_BD_WRITE;
+    cmd[8] = 8+24;
+    if( !cmd.transport( TR_DIR_READ, header, 32 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 28 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "BD Write";
+            if( header[8+8] || header[8+9] || header[8+10] || header[8+11] || header[8+12] || header[8+13] || header[8+14] || header[8+15] )
+                d->writeCapabilities |= MEDIA_BD_RE;
+            if( header[8+16] || header[8+17] || header[8+18] || header[8+19] || header[8+20] || header[8+21] || header[8+22] || header[8+23] ) {
+                d->writeCapabilities |= (MEDIA_BD_R|MEDIA_BD_R_SRM);
+                d->writeModes |= WRITINGMODE_SRM;
+
+                cmd[2] = FEATURE_BD_PSEUDO_OVERWRITE>>8;
+                cmd[3] = FEATURE_BD_PSEUDO_OVERWRITE;
+                cmd[8] = 8+8;
+                if( !cmd.transport( TR_DIR_READ, header, 8+8 ) ) {
+                    unsigned int len = from4Byte( header );
+                    if( len >= 4+8 ) {
+                        d->writeCapabilities |= MEDIA_BD_R_SRM_POW;
+                        d->writeModes |= WRITINGMODE_SRM_POW;
+                    }
+                }
+
+                cmd[2] = FEATURE_RANDOM_WRITABLE>>8;
+                cmd[3] = FEATURE_RANDOM_WRITABLE;
+                cmd[8] = 8+16;
+                if( !cmd.transport( TR_DIR_READ, header, 8+16 ) ) {
+                    unsigned int len = from4Byte( header );
+                    if( len >= 4+16 ) {
+                        d->writeCapabilities |= MEDIA_BD_R_RRM;
+                        d->writeModes |= WRITINGMODE_RRM;
+                    }
+                }
+            }
+        }
+    }
+
+
+
+    //
+    // DVD-R(W)
+    //
+    cmd[2] = FEATURE_DVD_R_RW_WRITE>>8;
+    cmd[3] = FEATURE_DVD_R_RW_WRITE;
+    cmd[8] = 16;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "DVD-R/-RW Write";
+#ifdef WORDS_BIGENDIAN
+            struct dvd_r_rw_write_feature {
+                unsigned char reserved1 : 1;
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char reserved2 : 2;
+                unsigned char RDL       : 1;
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char dvd_rw    : 1;  // DVD-RW Writing
+                unsigned char reserved3 : 1;
+                unsigned char reserved4[3];
+            };
+#else
+            struct dvd_r_rw_write_feature {
+                unsigned char reserved3 : 1;
+                unsigned char dvd_rw    : 1;  // DVD-RW Writing
+                unsigned char testwrite : 1;  // Simulation write support
+                unsigned char RDL       : 1;
+                unsigned char reserved2 : 2;
+                unsigned char BUF       : 1;  // Burnfree
+                unsigned char reserved1 : 1;
+                unsigned char reserved4[3];
+            };
+#endif
+
+            struct dvd_r_rw_write_feature* p = (struct dvd_r_rw_write_feature*)&header[12];
+            if( p->BUF ) d->burnfree = true;
+            d->writeCapabilities |= (MEDIA_DVD_R|MEDIA_DVD_R_SEQ);
+            if( p->dvd_rw )
+                d->writeCapabilities |= (MEDIA_DVD_RW|MEDIA_DVD_RW_SEQ);
+            if( p->RDL )
+                d->writeCapabilities |= (MEDIA_DVD_R_DL|MEDIA_DVD_R_DL_SEQ);
+
+            d->dvdMinusTestwrite = p->testwrite;
+        }
+    }
+
+
+    //
+    // DVD-RW restricted overwrite check
+    //
+    cmd[2] = FEATURE_RIGID_RESTRICTED_OVERWRITE>>8;
+    cmd[3] = FEATURE_RIGID_RESTRICTED_OVERWRITE;
+    cmd[8] = 16;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "Rigid Restricted Overwrite";
+            d->writeModes |= WRITINGMODE_RES_OVWR;
+            d->writeCapabilities |= (MEDIA_DVD_RW|MEDIA_DVD_RW_OVWR);
+        }
+    }
+
+
+    //
+    // DVD-R Dual Layer Layer
+    //
+    cmd[2] = FEATURE_LAYER_JUMP_RECORDING>>8;
+    cmd[3] = FEATURE_LAYER_JUMP_RECORDING;
+    cmd[8] = 12;
+    if( !cmd.transport( TR_DIR_READ, header, 12 ) ) {
+        // Now the jump feature is longer than 4 bytes but we don't need the link sizes.
+        unsigned int len = from4Byte( header );
+        if( len >= 8 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "Layer Jump Recording";
+            d->writeCapabilities |= (MEDIA_DVD_R_DL|MEDIA_DVD_R_DL_JUMP);
+            d->writeModes |= WRITINGMODE_LAYER_JUMP;
+        }
+    }
+
+
+    //
+    // HD-DVD-ROM
+    //
+    cmd[2] = FEATURE_HD_DVD_READ>>8;
+    cmd[3] = FEATURE_HD_DVD_READ;
+    cmd[8] = 16;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "HD-DVD Read";
+            d->readCapabilities |= MEDIA_HD_DVD_ROM;
+            if( header[8+4] & 0x1 )
+                d->readCapabilities |= MEDIA_HD_DVD_R;
+            if( header[8+6] & 0x1 )
+                d->readCapabilities |= MEDIA_HD_DVD_RAM;
+        }
+    }
+
+
+    //
+    // HD-DVD-R(AM)
+    //
+    cmd[2] = FEATURE_HD_DVD_WRITE>>8;
+    cmd[3] = FEATURE_HD_DVD_WRITE;
+    cmd[8] = 16;
+    if( !cmd.transport( TR_DIR_READ, header, 16 ) ) {
+        unsigned int len = from4Byte( header );
+        if( len >= 12 ) {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " feature: " << "HD-DVD Write";
+            if( header[8+4] & 0x1 )
+                d->writeCapabilities |= MEDIA_HD_DVD_R;
+            if( header[8+6] & 0x1 )
+                d->writeCapabilities |= MEDIA_HD_DVD_RAM;
+        }
+    }
+
+
+
+    //
+    // Get the profiles
+    //
+    // the max len of the returned data is 8 (header) + 4 (feature) + 255 (additional length)
+    //
+    cmd[2] = FEATURE_PROFILE_LIST>>8;
+    cmd[3] = FEATURE_PROFILE_LIST;
+    cmd[8] = 12; // get the number of returned profiles first
+    if( !cmd.transport( TR_DIR_READ, header, 12 ) ) {
+        unsigned int len = from4Byte( header ) + 4;
+        if( len >= 12 ) {
+            cmd[7] = len>>8;
+            cmd[8] = len;
+            if( !cmd.transport( TR_DIR_READ, header, len ) ) {
+                int featureLen( header[11] );
+                for( int j = 0; j < featureLen; j+=4 ) {
+                    short profile = from2Byte( &header[12+j] );
+
+                    switch (profile) {
+                    case 0x08:
+                        d->supportedProfiles |= MEDIA_CD_ROM;
+                        break;
+                    case 0x09:
+                        d->supportedProfiles |= MEDIA_CD_R;
+                        break;
+                    case 0x0A:
+                        d->supportedProfiles |= MEDIA_CD_RW;
+                        break;
+                    case 0x10:
+                        d->supportedProfiles |= MEDIA_DVD_ROM;
+                        // 	    d->readCapabilities |= MEDIA_DVD_ROM;
+                        break;
+                    case 0x11:
+                        d->supportedProfiles |= MEDIA_DVD_R_SEQ;
+                        // 	    d->writeCapabilities |= (MEDIA_DVD_R|MEDIA_DVD_R_SEQ);
+                        break;
+                    case 0x12:
+                        d->supportedProfiles |= MEDIA_DVD_RAM;
+//  	    d->readCapabilities |= (MEDIA_DVD_RAM|MEDIA_DVD_ROM);
+//  	    d->writeCapabilities |= MEDIA_DVD_RAM;
+                        break;
+                    case 0x13:
+                        d->supportedProfiles |= MEDIA_DVD_RW_OVWR;
+                        // 	    d->writeCapabilities |= (MEDIA_DVD_RW|MEDIA_DVD_RW_OVWR);
+                        break;
+                    case 0x14:
+                        d->supportedProfiles |= MEDIA_DVD_RW_SEQ;
+                        // 	    d->writeCapabilities |= (MEDIA_DVD_RW|MEDIA_DVD_R|MEDIA_DVD_RW_SEQ|MEDIA_DVD_R_SEQ);
+                        break;
+                    case 0x15:
+                        d->supportedProfiles |= MEDIA_DVD_R_DL_SEQ;
+                        // 	    d->writeCapabilities |= (MEDIA_DVD_R|MEDIA_DVD_R_DL|MEDIA_DVD_R_SEQ|MEDIA_DVD_R_DL_SEQ);
+                        break;
+                    case 0x16:
+                        d->supportedProfiles |= MEDIA_DVD_R_DL_JUMP;
+                        // 	    d->writeCapabilities |= (MEDIA_DVD_R|MEDIA_DVD_R_DL||MEDIA_DVD_R_DL_JUMP);
+                        break;
+                    case 0x1A:
+                        d->supportedProfiles |= MEDIA_DVD_PLUS_RW;
+                        // 	    d->writeCapabilities |= MEDIA_DVD_PLUS_RW;
+                        break;
+                    case 0x1B:
+                        d->supportedProfiles |= MEDIA_DVD_PLUS_R;
+                        // 	    d->writeCapabilities |= MEDIA_DVD_PLUS_R;
+                        break;
+                    case 0x2A:
+                        d->supportedProfiles |= MEDIA_DVD_PLUS_RW_DL;
+                        // 	    d->writeCapabilities |= MEDIA_DVD_PLUS_RW_DL;
+                        break;
+                    case 0x2B:
+                        d->supportedProfiles |= MEDIA_DVD_PLUS_R_DL;
+                        //	    d->writeCapabilities |= MEDIA_DVD_PLUS_R_DL;
+                        break;
+                    case 0x40:
+                        d->supportedProfiles |= MEDIA_BD_ROM;
+                        break;
+                    case 0x41:
+                        d->supportedProfiles |= MEDIA_BD_R_SRM;
+                        break;
+                    case 0x42:
+                        d->supportedProfiles |= MEDIA_BD_R_RRM;
+                        break;
+                    case 0x43:
+                        d->supportedProfiles |= MEDIA_BD_RE;
+                        break;
+                    case 0x50:
+                        d->supportedProfiles |= MEDIA_HD_DVD_ROM;
+                        break;
+                    case 0x51:
+                        d->supportedProfiles |= MEDIA_HD_DVD_R;
+                        break;
+                    case 0x52:
+                        d->supportedProfiles |= MEDIA_HD_DVD_RAM;
+                        break;
+                    default:
+                        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << " unknown profile: "
+                                 << profile << endl;
+                    }
+                }
+
+                // some older DVD-ROM drives claim to support DVD+R DL
+                if( !(d->supportedProfiles & MEDIA_DVD_PLUS_R) ) {
+                    // remove DVD+R DL capability
+                    //	  d->writeCapabilities &= ~MEDIA_DVD_PLUS_R_DL;
+                    d->supportedProfiles &= ~MEDIA_DVD_PLUS_R_DL;
+                }
+            }
+        }
+    }
+}
+
+
+void K3b::Device::Device::checkFor2AFeatures()
+{
+    unsigned char* mm_cap_buffer = 0;
+    unsigned int mm_cap_len = 0;
+
+    if( modeSense( &mm_cap_buffer, mm_cap_len, 0x2A ) ) {
+        mm_cap_page_2A* mm_p = (mm_cap_page_2A*)(mm_cap_buffer+8);
+        if( mm_p->BUF )
+            d->burnfree = true;
+
+        if( mm_p->cd_r_write )
+            d->writeCapabilities |= MEDIA_CD_R;
+        else
+            d->writeCapabilities &= ~MEDIA_CD_R;
+
+        if( mm_p->cd_rw_write )
+            d->writeCapabilities |= MEDIA_CD_RW;
+        else
+            d->writeCapabilities &= ~MEDIA_CD_RW;
+
+        if( mm_p->dvd_r_write )
+            d->writeCapabilities |= MEDIA_DVD_R;
+        else
+            d->writeCapabilities &= ~MEDIA_DVD_R;
+
+        if( mm_p->dvd_rom_read || mm_p->dvd_r_read )
+            d->readCapabilities |= MEDIA_DVD_ROM;
+
+        d->maxReadSpeed = from2Byte(mm_p->max_read_speed);
+        d->bufferSize = from2Byte( mm_p->buffer_size );
+
+        delete [] mm_cap_buffer;
+    }
+    else {
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": read mode page 2A failed!";
+    }
+}
+
+
+void K3b::Device::Device::checkWritingModes()
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    if( !open() )
+        return;
+
+    // header size is 8
+    unsigned char* buffer = 0;
+    unsigned int dataLen = 0;
+
+    if( !modeSense( &buffer, dataLen, 0x05 ) ) {
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": modeSense 0x05 failed!" << endl
+                 << "(K3b::Device::Device) " << blockDeviceName() << ": Cannot check write modes." << endl;
+    }
+    else if( dataLen < 18 ) { // 8 bytes header + 10 bytes used modepage
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": Missing modepage 0x05 data." << endl
+                 << "(K3b::Device::Device) " << blockDeviceName() << ": Cannot check write modes." << endl;
+    }
+    else {
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": dataLen: " << dataLen;
+
+        wr_param_page_05* mp = (struct wr_param_page_05*)(buffer+8);
+
+        // reset some stuff to be on the safe side
+        mp->PS = 0;
+        mp->BUFE = 0;
+        mp->multi_session = 0;
+        mp->test_write = 0;
+        mp->LS_V = 0;
+        mp->copy = 0;
+        mp->fp = 0;
+        mp->host_appl_code= 0;
+        mp->session_format = 0;
+        mp->audio_pause_len[0] = 0;
+        mp->audio_pause_len[1] = 150;
+
+        // WRITINGMODE_TAO
+        mp->write_type = 0x01;  // Track-at-once
+        mp->track_mode = 4;     // MMC-4 says: 5, cdrecord uses 4 ?
+        mp->dbtype = 8;         // Mode 1
+
+        //    kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": modeselect WRITINGMODE_TAO data: ";
+        //    debugBitfield( buffer, dataLen );
+
+
+        //
+        // if a writer does not support WRITINGMODE_TAO it surely does not support WRITINGMODE_SAO or WRITINGMODE_RAW writing since WRITINGMODE_TAO is the minimal
+        // requirement
+        //
+
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for TAO";
+        if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+            d->writeModes |= WRITINGMODE_TAO;
+            d->writeCapabilities |= MEDIA_CD_R;
+
+            // WRITINGMODE_SAO
+            mp->write_type = 0x02; // Session-at-once
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for SAO";
+            if( modeSelect( buffer, dataLen, 1, 0 ) )
+                d->writeModes |= WRITINGMODE_SAO;
+
+//       mp->dbtype = 1;        // Raw data with P and Q Sub-channel (2368 bytes)
+//       if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+// 	d->writeModes |= WRITINGMODE_RAW_R16;
+//       }
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for SAO_R96P";
+            mp->dbtype = 2;        // Raw data with P-W Sub-channel (2448 bytes)
+            if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+                d->writeModes |= WRITINGMODE_SAO_R96P;
+            }
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for SAO_R96R";
+            mp->dbtype = 3;        // Raw data with P-W raw Sub-channel (2448 bytes)
+            if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+                d->writeModes |= WRITINGMODE_SAO_R96R;
+            }
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for RAW_R16";
+            // WRITINGMODE_RAW
+            mp->write_type = 0x03; // WRITINGMODE_RAW
+            mp->dbtype = 1;        // Raw data with P and Q Sub-channel (2368 bytes)
+            if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+                d->writeModes |= WRITINGMODE_RAW;
+                d->writeModes |= WRITINGMODE_RAW_R16;
+            }
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for RAW_R96P";
+            mp->dbtype = 2;        // Raw data with P-W Sub-channel (2448 bytes)
+            if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+                d->writeModes |= WRITINGMODE_RAW;
+                d->writeModes |= WRITINGMODE_RAW_R96P;
+            }
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": checking for RAW_R96R";
+            mp->dbtype = 3;        // Raw data with P-W raw Sub-channel (2448 bytes)
+            if( modeSelect( buffer, dataLen, 1, 0 ) ) {
+                d->writeModes |= WRITINGMODE_RAW;
+                d->writeModes |= WRITINGMODE_RAW_R96R;
+            }
+        }
+        else {
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName() << ": modeSelect with WRITINGMODE_TAO failed. No writer";
+        }
+
+
+        delete [] buffer;
+    }
+
+    if( needToClose )
+        close();
+}
+
+
+int K3b::Device::Device::getMaxWriteSpeedVia2A() const
+{
+    int ret = 0;
+
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+
+    if( modeSense( &data, dataLen, 0x2A ) ) {
+        mm_cap_page_2A* mm = (mm_cap_page_2A*)&data[8];
+
+        // MMC1 used byte 18 and 19 for the max write speed
+        if( dataLen > 19 )
+            ret = from2Byte( mm->max_write_speed );
+
+        delete [] data;
+    }
+
+    return ret;
+}
+
+
+int K3b::Device::Device::determineMaximalWriteSpeed() const
+{
+    int ret = 0;
+
+    if( mediaType() & MEDIA_CD_ALL ) {
+        ret = getMaxWriteSpeedVia2A();
+        if ( ret > 0 )
+            return ret;
+    }
+
+    QList<int> list = determineSupportedWriteSpeeds();
+    if( !list.isEmpty() ) {
+        for( QList<int>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it )
+            ret = qMax( ret, *it );
+    }
+
+    if( ret > 0 )
+        return ret;
+    else
+        return d->maxWriteSpeed;
+}
+
+
+QList<int> K3b::Device::Device::determineSupportedWriteSpeeds() const
+{
+    QList<int> ret;
+
+    if( burner() ) {
+        //
+        // Tests with all my drives resulted in 2A for CD and GET PERFORMANCE for DVD media
+        // as the valid method of speed detection.
+        //
+        MediaType m = mediaType();
+        if( m & MEDIA_CD_ALL ) {
+            if( !getSupportedWriteSpeedsVia2A( ret, m ) )
+                getSupportedWriteSpeedsViaGP( ret, m );
+
+            // restrict to max speed, although deprecated in MMC3 is still used everywhere and
+            // cdrecord also uses it as the max writing speed.
+            int max = 0;
+            unsigned char* data = 0;
+            unsigned int dataLen = 0;
+            if( modeSense( &data, dataLen, 0x2A ) ) {
+                mm_cap_page_2A* mm = (mm_cap_page_2A*)&data[8];
+
+                // MMC1 used byte 18 and 19 for the max write speed
+                if( dataLen > 19 )
+                    max = from2Byte( mm->max_write_speed );
+
+                delete [] data;
+
+                if( max > 0 ) {
+                    while( !ret.isEmpty() && ret.last() > max ) {
+                        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                                 << " writing speed " << ret.last() << " higher than max " << max << endl;
+                        ret.pop_back();
+                    }
+                }
+            }
+        }
+        else {
+            if( !getSupportedWriteSpeedsViaGP( ret, m ) )
+                getSupportedWriteSpeedsVia2A( ret, m );
+        }
+
+        // construct writing speeds for old devices
+        if ( ret.isEmpty() && K3b::Device::isCdMedia( m ) ) {
+            int max = getMaxWriteSpeedVia2A();
+            for ( int i = 1; i <= max/SPEED_FACTOR_CD; i *= 2 ) {
+                ret.append( i * SPEED_FACTOR_CD );
+            }
+        }
+    }
+
+    return ret;
+}
+
+
+bool K3b::Device::Device::getSupportedWriteSpeedsVia2A( QList<int>& list, MediaType mediaType ) const
+{
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+    if( modeSense( &data, dataLen, 0x2A ) ) {
+        mm_cap_page_2A* mm = (mm_cap_page_2A*)&data[8];
+
+        if( dataLen > 32 ) {
+            // we have descriptors
+            unsigned int numDesc = from2Byte( mm->num_wr_speed_des );
+
+            // Some CDs writer returns the number of bytes that contain
+            // the descriptors rather than the number of descriptors
+            // Ensure number of descriptors claimed actually fits in the data
+            // returned by the mode sense command.
+            if( numDesc > ((dataLen - 32 - 8) / 4) )
+                numDesc = (dataLen - 32 - 8) / 4;
+
+            cd_wr_speed_performance* wr = (cd_wr_speed_performance*)mm->wr_speed_des;
+
+            kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                     << ":  Number of supported write speeds via 2A: "
+                     << numDesc << endl;
+
+
+            for( unsigned int i = 0; i < numDesc; ++i ) {
+                int s = (int)from2Byte( wr[i].wr_speed_supp );
+                //
+                // some DVD writers report CD writing speeds here
+                // If that is the case we cannot rely on the reported speeds
+                // and need to use the values gained from GET PERFORMANCE.
+                //
+                if( isDvdMedia( mediaType ) && s < 1352 ) {
+                    kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                             << " Invalid DVD speed: " << s << " KB/s" << endl;
+                    list.clear();
+                    break;
+                }
+                else {
+                    kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                             << " : " << s << " KB/s" << endl;
+
+                    if( isDvdMedia( mediaType ) )
+                        s = fixupDvdWritingSpeed( s );
+
+                    // sort the list
+                    QList<int>::iterator it = list.begin();
+                    while( it != list.end() && *it < s )
+                        ++it;
+                    list.insert( it, s );
+                }
+            }
+        }
+
+        delete [] data;
+    }
+
+    return !list.isEmpty();
+}
+
+
+bool K3b::Device::Device::getSupportedWriteSpeedsViaGP( QList<int>& list, MediaType mediaType ) const
+{
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+    if( getPerformance( &data, dataLen, 0x3, 0x0 ) && dataLen >= 8 ) {
+        int numDesc = (dataLen - 8)/16;
+        kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                 << ":  Number of supported write speeds via GET PERFORMANCE: "
+                 << numDesc << endl;
+
+        for( int i = 0; i < numDesc; ++i ) {
+            int s = from4Byte( &data[20+i*16] );
+
+            // Looks as if the code below does not make sense with most drives
+//       if( !( data[4+i*16] & 0x2 ) ) {
+// 	kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+// 		   << " No write speed: " << s << " KB/s" << endl;
+// 	continue;
+//       }
+
+            if( isDvdMedia( mediaType ) && s < 1352 ) {
+                //
+                // Does this ever happen?
+                //
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                         << " Invalid DVD speed: " << s << " KB/s" << endl;
+            }
+            else {
+                kDebug() << "(K3b::Device::Device) " << blockDeviceName()
+                         << " : " << s << " KB/s" << endl;
+
+                if( isDvdMedia( mediaType ) )
+                    s = fixupDvdWritingSpeed( s );
+
+                QList<int>::iterator it = list.begin();
+                while( it != list.end() && *it < s )
+                    ++it;
+                // the speed might already have been found in the 2a modepage
+                if( it == list.end() || *it != s )
+                    list.insert( it, s );
+            }
+        }
+
+        delete [] data;
+    }
+
+    return !list.isEmpty();
+}
+
+
+int K3b::Device::Device::getIndex( unsigned long lba ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    if( !open() )
+        return -1;
+
+    int ret = -1;
+
+    //
+    // first try readCd
+    //
+    unsigned char readData[16];
+    ::memset( readData, 0, 16 );
+
+    //
+    // The index is found in the Mode-1 Q which occupies at least 9 out of 10 successive CD frames
+    // It can be indentified by ADR == 1
+    //
+    // So if the current sector does not provide Mode-1 Q subchannel we try the previous.
+    //
+
+    if( readCd( readData,
+                16,
+                1, // CD-DA
+                0, // no DAP
+                lba,
+                1,
+                false,
+                false,
+                false,
+                false,
+                false,
+                0,
+                2 // Q-Subchannel
+            ) ) {
+        // byte 0: 4 bits CONTROL (MSB) + 4 bits ADR (LSB)
+        if( (readData[0]&0x0f) == 0x1 )
+            ret = readData[2];
+
+        // search previous sector for Mode1 Q Subchannel
+        else if( readCd( readData,
+                         16,
+                         1, // CD-DA
+                         0, // no DAP
+                         lba-1,
+                         1,
+                         false,
+                         false,
+                         false,
+                         false,
+                         false,
+                         0,
+                         2 // Q-Subchannel
+                     ) ) {
+            if( (readData[0]&0x0f) == 0x1 )
+                ret = readData[2];
+            else
+                ret = -2;
+        }
+    }
+
+    else {
+        kDebug() << "(K3b::Device::Device::getIndex) readCd failed. Trying seek.";
+
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+        if( seek( lba ) && readSubChannel( &data, dataLen, 1, 0 ) ) {
+            // byte 5: 4 bits ADR (MSB) + 4 bits CONTROL (LSB)
+            if( dataLen > 7 && (data[5]>>4 & 0x0F) == 0x1 ) {
+                ret = data[7];
+            }
+            else if( seek( lba-1 ) && readSubChannel( &data, dataLen, 1, 0 ) ) {
+                if( dataLen > 7 && (data[5]>>4 & 0x0F) == 0x1 )
+                    ret = data[7];
+                else
+                    ret = -2;
+            }
+
+            delete [] data;
+        }
+        else
+            kDebug() << "(K3b::Device::Device::getIndex) seek or readSubChannel failed.";
+    }
+
+    if( needToClose )
+        close();
+
+    return ret;
+}
+
+
+bool K3b::Device::Device::searchIndex0( unsigned long startSec,
+                                      unsigned long endSec,
+                                      long& pregapStart ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    if( !open() )
+        return false;
+
+    bool ret = false;
+
+    int lastIndex = getIndex( endSec );
+    if( lastIndex == 0 ) {
+        // there is a pregap
+        // let's find the position where the index turns to 0
+        // we jump in 1 sec steps backwards until we find an index > 0
+        unsigned long sector = endSec;
+        while( lastIndex == 0 && sector > startSec ) {
+            sector -= 75;
+            if( sector < startSec )
+                sector = startSec;
+            lastIndex = getIndex(sector);
+        }
+
+        if( lastIndex == 0 ) {
+            kDebug() << "(K3b::Device::Device) warning: no index != 0 found.";
+        }
+        else {
+            // search forward to the first index = 0
+            while( getIndex( sector ) != 0 && sector < endSec )
+                sector++;
+
+            pregapStart = sector;
+            ret = true;
+        }
+    }
+    else if( lastIndex > 0 ) {
+        // no pregap
+        pregapStart = -1;
+        ret = true;
+    }
+
+    if( needToClose )
+        close();
+
+    return ret;
+}
+
+
+bool K3b::Device::Device::indexScan( K3b::Device::Toc& toc ) const
+{
+    // if the device is already opened we do not close it
+    // to allow fast multiple method calls in a row
+    bool needToClose = !isOpen();
+
+    if( !open() )
+        return false;
+
+    bool ret = true;
+
+    for( Toc::iterator it = toc.begin(); it != toc.end(); ++it ) {
+        Track& track = *it;
+        if( track.type() == Track::TYPE_AUDIO ) {
+            track.setIndices( QList<K3b::Msf>() );
+            long index0 = -1;
+            if( searchIndex0( track.firstSector().lba(), track.lastSector().lba(), index0 ) ) {
+                kDebug() << "(K3b::Device::Device) found index 0: " << index0;
+            }
+            if( index0 > 0 )
+                track.setIndex0( K3b::Msf( index0 - track.firstSector().lba() ) );
+            else
+                track.setIndex0( 0 );
+
+            if( index0 > 0 )
+                searchIndexTransitions( track.firstSector().lba(), index0-1, track );
+            else
+                searchIndexTransitions( track.firstSector().lba(), track.lastSector().lba(), track );
+        }
+    }
+
+    if( needToClose )
+        close();
+
+    return ret;
+}
+
+
+void K3b::Device::Device::searchIndexTransitions( long start, long end, K3b::Device::Track& track ) const
+{
+    kDebug() << "(K3b::Device::Device) searching for index transitions between "
+             << start << " and " << end << endl;
+    int startIndex = getIndex( start );
+    int endIndex = getIndex( end );
+
+    if( startIndex < 0 || endIndex < 0 ) {
+        kDebug() << "(K3b::Device::Device) could not retrieve index values.";
+    }
+    else {
+        kDebug() << "(K3b::Device::Device) indices: " << start << " - " << startIndex
+                 << " and " << end << " - " << endIndex << endl;
+
+        if( startIndex != endIndex ) {
+            if( start+1 == end ) {
+                QList<K3b::Msf> indices = track.indices();
+                kDebug() << "(K3b::Device::Device) found index transition: " << endIndex << " " << end;
+                while ( indices.count() < endIndex )
+                    indices.append( K3b::Msf() );
+                // we save the index relative to the first sector
+                indices[endIndex-1] = K3b::Msf( end ) - track.firstSector();
+                track.setIndices( indices ); // FIXME: better API
+            }
+            else {
+                searchIndexTransitions( start, start+(end-start)/2, track );
+                searchIndexTransitions( start+(end-start)/2, end, track );
+            }
+        }
+    }
+}
+
+
+int K3b::Device::Device::copyrightProtectionSystemType() const
+{
+    unsigned char* dvdheader = 0;
+    unsigned int dataLen = 0;
+    if( readDvdStructure( &dvdheader, dataLen, 0x1 ) ) {
+        int ret = -1;
+        if( dataLen >= 6 )
+            ret = dvdheader[4];
+        delete [] dvdheader;
+        return ret;
+    }
+    else
+        return -1;
+}
+
+
+bool K3b::Device::Device::getNextWritableAdress( unsigned int& lastSessionStart, unsigned int& nextWritableAdress ) const
+{
+    bool success = false;
+
+    // FIXME: add CD media handling
+    int m = mediaType();
+    if( m & MEDIA_DVD_ALL ) {
+        // DVD+RW always returns complete
+        if( m & (K3b::Device::MEDIA_DVD_PLUS_RW|K3b::Device::MEDIA_DVD_RW_OVWR) )
+            return false;
+
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+
+        if( readDiscInformation( &data, dataLen ) ) {
+            disc_info_t* inf = (disc_info_t*)data;
+
+            //
+            // The state of the last session has to be "empty" (0x0) or "incomplete" (0x1)
+            // The procedure here is taken from the dvd+rw-tools
+            //
+            if( !(inf->border & 0x2) ) {
+                // the incomplete track number is the first track in the last session (the empty session)
+                int nextTrack = inf->first_track_l|inf->first_track_m<<8;
+
+                unsigned char* trackData = 0;
+                unsigned int trackDataLen = 0;
+
+                // Read start address of the incomplete track
+                if( readTrackInformation( &trackData, trackDataLen, 0x1, nextTrack ) ) {
+                    nextWritableAdress = from4Byte( &trackData[8] );
+                    delete [] trackData;
+
+                    // Read start address of the first track in the last session
+                    if( readTocPmaAtip( &trackData, trackDataLen, 0x1, false, 0x0  ) ) {
+                        lastSessionStart = from4Byte( &trackData[8] );
+                        delete [] trackData;
+                        success = true;
+                    }
+                }
+            }
+        }
+
+        delete [] data;
+    }
+
+    return success;
+}
+
+
+int K3b::Device::Device::nextWritableAddress() const
+{
+    unsigned char* data = 0;
+    unsigned int dataLen = 0;
+    int nwa = -1;
+
+    if( readDiscInformation( &data, dataLen ) ) {
+        disc_info_t* inf = (disc_info_t*)data;
+
+        //
+        // The state of the last session has to be "empty" (0x0) or "incomplete" (0x1)
+        // The procedure here is taken from the dvd+rw-tools and wodim
+        //
+        if( !(inf->border & 0x2) ) {
+            // the incomplete track number is the first track in the last session (the empty session)
+            int nextTrack = inf->first_track_l|inf->first_track_m<<8;
+
+            unsigned char* trackData = 0;
+            unsigned int trackDataLen = 0;
+
+            // Read start address of the incomplete track
+            if( readTrackInformation( &trackData, trackDataLen, 0x1, nextTrack ) ) {
+                nwa = from4Byte( &trackData[8] );
+                delete [] trackData;
+            }
+
+            // Read start address of the invisible track
+            else if ( readTrackInformation( &trackData, trackDataLen, 0x1, 0xff ) ) {
+                nwa = from4Byte( &trackData[8] );
+                delete [] trackData;
+            }
+        }
+
+        delete [] data;
+    }
+
+    return nwa;
+}
+
+
+QByteArray K3b::Device::Device::mediaId( int mediaType ) const
+{
+    QString id;
+
+    if( mediaType & MEDIA_CD_ALL ) {
+        // FIXME:
+    }
+
+    else if( mediaType & MEDIA_DVD_MINUS_ALL ) {
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+        if( readDvdStructure( &data, dataLen, 0x0E ) ) {
+            if( data[4+16] == 3 && data[4+24] == 4 ) {
+                id.sprintf( "%6.6s%-6.6s", data+4+17, data+4+25 );
+            }
+            delete [] data;
+        }
+    }
+
+    else if( mediaType & MEDIA_DVD_PLUS_ALL ) {
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+        if( readDvdStructure( &data, dataLen, 0x11 ) ||
+            readDvdStructure( &data, dataLen, 0x0 ) ) {
+            id.sprintf( "%8.8s/%3.3s", data+23, data+31 );
+            delete [] data;
+        }
+    }
+
+    else if( mediaType & MEDIA_BD_ALL ) {
+        unsigned char* data = 0;
+        unsigned int dataLen = 0;
+        if( readDiscStructure( &data, dataLen, 1, 0 ) ) {
+            if( data[4+0] == 'D' && data[4+1] == 'I' )
+                id.sprintf ("%6.6s/%-3.3s", data+4+100, data+4+106 );
+            delete [] data;
+        }
+    }
+
+    return id.toLatin1();
+}
+
+
+// int K3b::Device::Device::ioctl( int request, ... ) const
+// {
+//     int r = -1;
+// #if defined(Q_OS_LINUX) || defined(Q_OS_NETBSD)
+//     d->mutex.lock();
+
+//     va_list ap;
+//     va_start( ap, request );
+//     r = ::ioctl( d->deviceFd, request, ap );
+//     va_end( ap );
+
+//     d->mutex.unlock();
+// #endif
+//     return r;
+// }
+
+
+void K3b::Device::Device::usageLock() const
+{
+    d->mutex.lock();
+}
+
+
+void K3b::Device::Device::usageUnlock() const
+{
+    d->mutex.unlock();
+}
diff -rupN k3b-2.0.2/libk3bdevice/k3bdevice.h k3b-2.0.2-patched/libk3bdevice/k3bdevice.h
--- k3b-2.0.2/libk3bdevice/k3bdevice.h	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bdevice.h	2013-09-16 01:29:49.000000000 +0300
@@ -222,6 +222,11 @@ namespace K3b {
              */
             QString blockDeviceName() const;
 
+            /**
+             * SCSI device path (bus_id:target_id:lun_id)
+             */
+            QString genericDeviceName() const;
+
             int maxWriteSpeed() const;
 
             /**
diff -rupN k3b-2.0.2/libk3bdevice/k3bdevice.h.orig k3b-2.0.2-patched/libk3bdevice/k3bdevice.h.orig
--- k3b-2.0.2/libk3bdevice/k3bdevice.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bdevice.h.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,772 @@
+/*
+ *
+ * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+
+#ifndef K3BDEVICE_H
+#define K3BDEVICE_H
+
+#include <qstringlist.h>
+#include <qglobal.h>
+
+#include "k3bdevicetypes.h"
+#include "k3bdiskinfo.h"
+#include "k3bcdtext.h"
+#include "k3bmsf.h"
+#include "k3bdevice_export.h"
+
+#if defined(__FreeBSD_kernel__)
+#undef Q_OS_LINUX
+#define Q_OS_FREEBSD 1
+#endif
+
+#ifdef Q_OS_FREEBSD
+struct cam_device;
+#endif
+
+#ifdef Q_OS_WIN32
+#include <windows.h>
+#endif
+
+namespace Solid {
+    class Device;
+    class StorageAccess;
+}
+
+namespace K3b {
+    namespace Device
+    {
+        class Toc;
+
+        /**
+         * \brief The main class representing a device.
+         *
+         * Devices are constructed by the DeviceManager.
+         *
+         * All methods except for open and close in Device are thread-safe which basicaly means that
+         * no two commands are sent to the device at the same time.
+         */
+        // FIXME: all methods are const which makes no sense at all!
+        class LIBK3BDEVICE_EXPORT Device
+        {
+        public:
+#if defined(Q_OS_FREEBSD)
+            typedef struct cam_device* Handle;
+#elif defined(Q_OS_WIN32)
+            // file handle
+            typedef HANDLE Handle;
+#else
+            // file descriptor
+            typedef int Handle;
+#endif
+
+            ~Device();
+
+            Solid::Device solidDevice() const;
+
+            /**
+             *  Gives interface for dics volume.
+             *  Keep in mind that it can return empty pointer when no disc is inserted.
+             *
+             *  @return Interface for disc volume.
+             */
+            Solid::StorageAccess* solidStorage() const;
+
+            /**
+             * \deprecated use readCapabilities() and writeCapabilities()
+             * The device type.
+             *
+             * @return A bitwise or of K3b::Device::DeviceType.
+             */
+            DeviceTypes type() const;
+
+            /**
+             * The mediatypes this device is able to read.
+             *
+             * \return A bitwise or of K3b::Device::MediaType
+             */
+            MediaTypes readCapabilities() const;
+
+            /**
+             * The media types this device is able to write.
+             *
+             * \return A bitwise or of K3b::Device::MediaType
+             */
+            MediaTypes writeCapabilities() const;
+
+            /**
+             * \return Vendor string as reported by the device's firmware.
+             */
+            QString vendor() const;
+
+            /**
+             * \return Description string as reported by the device's firmware.
+             */
+            QString description() const;
+
+            /**
+             * \return Version string as reported by the device's firmware.
+             */
+            QString version() const;
+
+            /**
+             * Shortcut for \code writesCd() || writesDvd() \endcode
+             *
+             * \return true if the device is able to burn media.
+             */
+            bool burner() const;
+
+            /**
+             * Shortcut for \code type() & DEVICE_CD_R \endcode
+             *
+             * \return true if the device is able to burn CD-R media.
+             */
+            bool writesCd() const;
+
+            /**
+             * Shortcut for \code type() & DEVICE_CD_RW \endcode
+             *
+             * \return true if the device is able to burn CD-RW media.
+             */
+            bool writesCdrw() const;
+
+            /**
+             * Shortcut for \code writesDvdMinus() || writesDvdPlus() \endcode
+             *
+             * \return true if the device is able to burn DVD media.
+             */
+            bool writesDvd() const;
+
+
+            /**
+             * Shortcut for \code type() & (DEVICE_DVD_PLUS_R|DEVICE_DVD_PLUS_RW) \endcode
+             *
+             * \return true if the device is able to burn DVD+R or DVD+RW media.
+             */
+            bool writesDvdPlus() const;
+
+            /**
+             * Shortcut for \code type() & (DEVICE_DVD_R|DEVICE_DVD_RW) \endcode
+             *
+             * \return true if the device is able to burn DVD-R or DVD-RW media.
+             */
+            bool writesDvdMinus() const;
+
+            /**
+             * Shortcut for \code type() & DEVICE_DVD_ROM \endcode
+             *
+             * \return true if the device is able to read DVD media.
+             */
+            bool readsDvd() const;
+
+            /**
+             * @deprecated Use burnfree()
+             */
+            bool burnproof() const;
+
+            /**
+             * @return true is the device is a writer and supports buffer underrun free recording (BURNFREE)
+             */
+            bool burnfree() const;
+
+            /**
+             * Shortcut for \code writingModes() & WRITINGMODE_SAO \endcode
+             *
+             * \deprecated use supportsWritingMode()
+             */
+            bool dao() const;
+
+            /**
+             * Check if the device supports a certain writing mode.
+             *
+             * \return true if the device supports the requested writing mode or false otherwise.
+             */
+            bool supportsWritingMode( WritingMode mode ) const { return (writingModes() & mode); }
+
+            /**
+             * Shortcut for
+             * \code
+             *  writingModes() & (WRITINGMODE_RAW|WRITINGMODE_RAW_R16|WRITINGMODE_RAW_R96P|WRITINGMODE_RAW_R96R)
+             * \endcode
+             */
+            bool supportsRawWriting() const;
+
+            /**
+             * @return true if the device is a DVD-R(W) writer which supports test writing.
+             */
+            bool dvdMinusTestwrite() const;
+
+            int maxReadSpeed() const;
+            int currentWriteSpeed() const;
+
+            /**
+             * Size of the device's internal writing buffer.
+             *
+             * \return The size of the buffer in KB.
+             */
+            int bufferSize() const;
+
+            /**
+             * for SCSI devices this should be something like /dev/scd0 or /dev/sr0
+             * for IDE device this should be something like /dev/hdb1
+             */
+            QString blockDeviceName() const;
+
+            int maxWriteSpeed() const;
+
+            /**
+             * internal K3b value.
+             * \deprecated This should not be handled here.
+             */
+            void setCurrentWriteSpeed( int s );
+
+            /**
+             * Use this if the speed was not detected correctly.
+             */
+            void setMaxReadSpeed( int s );
+
+            /**
+             * Use this if the speed was not detected correctly.
+             */
+            void setMaxWriteSpeed( int s );
+
+            /**
+             * checks if unit is ready (medium inserted and ready for command)
+             *
+             * Refers to the MMC command: TEST UNIT READY
+             */
+            bool testUnitReady() const;
+
+            /**
+             * checks if disk is empty, returns @p K3b::Device::State
+             */
+            int isEmpty() const;
+
+            /**
+             * @return true if inserted media is rewritable.
+             */
+            bool rewritable() const;
+
+            /**
+             * Check if the inserted media is a DVD.
+             *
+             * \return true if the inserted media is a DVD.
+             */
+            bool isDVD() const;
+
+            /**
+             * @return The number of sessions on the media.
+             */
+            int numSessions() const;
+
+            /**
+             * @return The toc of the media or an empty (invalid) K3b::Device::Toc if
+             *         no or an empty media is inserted.
+             */
+            Toc readToc() const;
+
+            /**
+             * Append ISRC and MCN to the TOC if found
+             * This has been moved to a separate method since it can take a very long time
+             * to scan for all ISRCs.
+             */
+            void readIsrcMcn( Toc& toc ) const;
+
+            /**
+             * Read the raw CD-Text data without decoding it.
+             * \return An array of bytes as read from the device, suitable to be used in
+             * CdText( const QByteArray& )
+             *
+             * \sa readCdText
+             */
+            QByteArray readRawCdText( bool* success = 0 ) const;
+
+            /**
+             * Read the CD-TEXT of an audio or mixed-mode CD.
+             *
+             * \return A CdText object filled with the CD-TEXT values or an empty one in case of
+             *         pure data media or if the CD does not contain CD-TEXT.
+             *
+             * \sa readRawCdText
+             */
+            CdText readCdText() const;
+
+            /**
+             * @return The K3b::Device::Track::DataMode of the track.
+             * @see K3b::Device::Track
+             */
+            Track::DataMode getTrackDataMode( const Track& track ) const;
+
+            /**
+             * @return the mode of a data track. K3b::Device::Track::MODE1, K3b::Device::Track::MODE2,
+             *         K3b::Device::Track::XA_FORM1, or K3b::Device::Track::XA_FORM2.
+             */
+            Track::DataMode getDataMode( const K3b::Msf& sector ) const;
+
+            /**
+             * block or unblock the drive's tray
+             * \return true on success and false on error.
+             * \see eject()
+             */
+            bool block( bool ) const;
+
+            /**
+             * Eject the media.
+             * \return true on success and false on error.
+             * \see load()
+             */
+            bool eject() const;
+
+            /**
+             * Load the media.
+             * @return true on success and false on error.
+             */
+            bool load() const;
+
+            /**
+             * Enable or disable auto-ejecting. For now this is a no-op on non-Linux systems.
+             * \param enabled if true auto-ejecting will be enabled, otherwise disabled.
+             * \return true if the operation was successful, false otherwise
+             */
+            bool setAutoEjectEnabled( bool enabled ) const;
+
+            /**
+             * The supported writing modes.
+             *
+             * \return A bitwise or of K3b::Device::WritingMode or 0 in case of a read-only device.
+             */
+            WritingModes writingModes() const;
+
+            bool readSectorsRaw(unsigned char *buf, int start, int count) const;
+
+            /**
+             * Get a list of supported profiles. See enumeration MediaType.
+             */
+            int supportedProfiles() const;
+
+            /**
+             * Tries to get the current profile from the drive.
+             * @returns -1 on error (command failed or unknown profile)
+             *          MediaType otherwise (MEDIA_NONE means: no current profile)
+             */
+            int currentProfile() const;
+
+            /**
+             * Check if a certain feature is current.
+             * \see k3bdevicetypes.h for feature constants.
+             * \return 1 if the feature is current, 0 if not, -1 on error
+             */
+            int featureCurrent( unsigned int feature ) const;
+
+            /**
+             * This is the method to use!
+             */
+            DiskInfo diskInfo() const;
+
+            /**
+             * Refers to MMC command READ CAPACITY
+             */
+            bool readCapacity( K3b::Msf& ) const;
+
+            /**
+             * Refers to MMC command READ FORMAT CAPACITY
+             *
+             * @param wantedFormat The requested format type.
+             * @param result If true is returned this contains the requested value.
+             * @param currentMax If not 0 this will be filled with the Current/Maximum Descriptor value.
+             * @param currentMax If not 0 this will be filled with the Current/Maximum Format Type.
+             */
+            bool readFormatCapacity( int wantedFormat, K3b::Msf& result,
+                                     K3b::Msf* currentMax = 0, int* currentMaxFormat = 0 ) const;
+
+            /**
+             * Determine the type of the currently mounted medium
+             *
+             * @returns K3b::Device::MediaType
+             */
+            MediaType mediaType() const;
+
+            /**
+             * Returnes the list of supported writing speeds as reported by
+             * mode page 2Ah.
+             *
+             * This only works with MMC3 compliant drives.
+             */
+            QList<int> determineSupportedWriteSpeeds() const;
+
+            /**
+             * @returnes the speed in kb/s or 0 on failure.
+             */
+            int determineMaximalWriteSpeed() const;
+
+            /**
+             * Open the device for access via a file descriptor.
+             * @return true on success or if the device is already open.
+             * @see close()
+             *
+             * Be aware that this method is not thread-safe.
+             */
+            bool open( bool write = false ) const;
+
+            /**
+             * Close the files descriptor.
+             * @see open()
+             *
+             * Be aware that this method is not thread-safe.
+             */
+            void close() const;
+
+            /**
+             * @return true if the device was successfully opened via @p open()
+             */
+            bool isOpen() const;
+
+            /**
+             * fd on linux, cam on bsd
+             */
+            Handle handle() const;
+
+            /**
+             * \return \li -1 on error (no DVD)
+             *         \li 1 (CSS/CPPM)
+             *         \li 2 (CPRM) if scrambled
+             *         \li 0 otherwise
+             */
+            int copyrightProtectionSystemType() const;
+
+            // MMC commands
+
+            /**
+             * SET SPEED command
+             *
+             * @param readingSpeed The preferred reading speed (0x0000-0xFFFE). 0xFFFF requests
+             *                     fot the logical unit to select the optimal speed.
+             * @param writingSpeed The preferred writing speed (0x0000-0xFFFE). 0xFFFF requests
+             *                     fot the logical unit to select the optimal speed.
+             * @param cav Is the speed pure CAV?
+             */
+            bool setSpeed( unsigned int readingSpeed,
+                           unsigned int writingSpeed,
+                           bool cav = false ) const;
+
+            /**
+             * if true is returned dataLen specifies the actual length of *data which needs to be
+             * deleted after using.
+             */
+            bool readDiscInformation( unsigned char** data, unsigned int& dataLen ) const;
+
+            /**
+             * @param pf If false all fields in the descriptor data is vendor specific. Default should be true.
+             */
+            bool modeSelect( unsigned char* page, unsigned int pageLen, bool pf, bool sp ) const;
+
+            /**
+             * if true is returned pageLen specifies the actual length of *pageData which needs to be
+             * deleted after using.
+             */
+            bool modeSense( unsigned char** pageData, unsigned int& pageLen, int page ) const;
+
+            /**
+             * if true is returned dataLen specifies the actual length of *data which needs to be
+             * deleted after using.
+             */
+            bool readTocPmaAtip( unsigned char** data, unsigned int& dataLen, int format, bool msf, int track ) const;
+
+            /**
+             * @param type specifies what value means:
+             *        \li 00b - value refers to a logical block address
+             *        \li 01b - value refers to a track number where 0 will treat the lead-in as if it
+             *                  were a logical track and ffh will read the invisible or incomplete track.
+             *        \li 10b - value refers to a session number
+             *
+             */
+            bool readTrackInformation( unsigned char** data, unsigned int& dataLen, int type, int value ) const;
+
+            /**
+             * if true is returned dataLen specifies the actual length of *data which needs to be
+             * deleted after using.
+             */
+            bool readDiscStructure( unsigned char** data, unsigned int& dataLen,
+                                    unsigned int mediaType = 0x0,
+                                    unsigned int format = 0x0,
+                                    unsigned int layer = 0x0,
+                                    unsigned long address = 0,
+                                    unsigned int agid = 0x0 ) const;
+
+            /**
+             * In MMC5 readDvdStructure was renamed to readDiscStructure. This method does the same
+             * like the above.
+             */
+            bool readDvdStructure( unsigned char** data, unsigned int& dataLen,
+                                   unsigned int format = 0x0,
+                                   unsigned int layer = 0x0,
+                                   unsigned long address = 0,
+                                   unsigned int agid = 0x0 ) const;
+
+            /**
+             * if true is returned dataLen specifies the actual length of *data which needs to be
+             * deleted after using.
+             */
+            bool mechanismStatus( unsigned char** data, unsigned int& dataLen ) const;
+
+            /**
+             * Read a single feature.
+             * data will be filled with the feature header and the descriptor
+             */
+            bool getFeature( unsigned char** data, unsigned int& dataLen, unsigned int feature ) const;
+
+
+            /**
+             * if true is returned dataLen specifies the actual length of *data which needs to be
+             * deleted after using.
+             */
+            bool getPerformance( unsigned char** data, unsigned int& dataLen,
+                                 unsigned int type,
+                                 unsigned int dataType,
+                                 unsigned int lba = 0 ) const;
+
+            /**
+             * @param sectorType: \li 000b - all types
+             *                    \li 001b - CD-DA
+             *                    \li 010b - Mode 1
+             *                    \li 011b - Mode 2 formless
+             *                    \li 100b - Mode 2 form 1
+             *                    \li 101b - Mode 2 form 2
+             *
+             * @param startAdress Lba 0 is mapped to msf 00:00:00 so this method uses
+             *                    startAdress+150 as the starting msf.
+             *
+             * @param endAdress This is the ending address which is NOT included in the read operation.
+             *                  Lba 0 is mapped to msf 00:00:00 so this method uses
+             *                  endAdress+150 as the ending msf.
+             *
+             * @param c2:         \li 00b  - No error info
+             *                    \li 01b  - 294 bytes, one bit for every byte of the 2352 bytes
+             *                    \li 10b  - 296 bytes, xor of all c2 bits, zero pad bit, 294 c2 bits
+             *
+             * @param subChannel: \li 000b - No Sub-channel data
+             *                    \li 001b - RAW P-W Sub-channel (96 bytes)
+             *                    \li 010b - Formatted Q Sub-channel (16 bytes)
+             *                    \li 100b - Corrected and de-interleaved R-W Sub-channel (96 bytes)
+             */
+            bool readCdMsf( unsigned char* data,
+                            unsigned int dataLen,
+                            int sectorType,
+                            bool dap,
+                            const K3b::Msf& startAdress,
+                            const K3b::Msf& endAdress,
+                            bool sync,
+                            bool header,
+                            bool subHeader,
+                            bool userData,
+                            bool edcEcc,
+                            int c2,
+                            int subChannel ) const;
+
+            /**
+             * @param sectorType: \li 000b - all types
+             *                    \li 001b - CD-DA
+             *                    \li 010b - Mode 1
+             *                    \li 011b - Mode 2 formless
+             *                    \li 100b - Mode 2 form 1
+             *                    \li 101b - Mode 2 form 2
+             *
+             * @param c2:         \li 00b  - No error info
+             *                    \li 01b  - 294 bytes, one bit for every byte of the 2352 bytes
+             *                    \li 10b  - 296 bytes, xor of all c2 bits, zero pad bit, 294 c2 bits
+             *
+             * @param subChannel: \li 000b - No Sub-channel data
+             *                    \li 001b - RAW P-W Sub-channel (96 bytes)
+             *                    \li 010b - Formatted Q Sub-channel (16 bytes)
+             *                    \li 100b - Corrected and de-interleaved R-W Sub-channel (96 bytes)
+             */
+            bool readCd( unsigned char* data,
+                         unsigned int dataLen,
+                         int sectorType,
+                         bool dap,
+                         unsigned long startAdress,
+                         unsigned long length,
+                         bool sync,
+                         bool header,
+                         bool subHeader,
+                         bool userData,
+                         bool edcEcc,
+                         int c2,
+                         int subChannel ) const;
+
+            bool read10( unsigned char* data,
+                         unsigned int dataLen,
+                         unsigned long startAdress,
+                         unsigned int length,
+                         bool fua = false ) const;
+
+            bool read12( unsigned char* data,
+                         unsigned int dataLen,
+                         unsigned long startAdress,
+                         unsigned long length,
+                         bool streaming = false,
+                         bool fua = false ) const;
+
+            /**
+             * @param subchannelParam: 01h - CD current position
+             *                         02h - Media Catalog number (UPC/bar code)
+             *                         03h - ISRC
+             * @param trackNumber only valid if subchannelParam == 03h
+             */
+            bool readSubChannel( unsigned char** data,
+                                 unsigned int& dataLen,
+                                 unsigned int subchannelParam,
+                                 unsigned int trackNumber ) const;
+
+            bool readIsrc( unsigned int track, QByteArray& isrc ) const;
+
+            bool readMcn( QByteArray& mcn ) const;
+
+            /**
+             * MMC command Read Buffer Capacity
+             *
+             * \return \see ScsiCommand::transport()
+             */
+            int readBufferCapacity( long long& bufferLength, long long& bufferAvail ) const;
+
+            /**
+             * @returns the index number on success
+             *          -1 on general error
+             *          and -2 if there is no index info in that frame
+             */
+            int getIndex( unsigned long lba ) const;
+
+            bool searchIndex0( unsigned long startSec, unsigned long endSec, long& pregapStart ) const;
+
+            /**
+             * For now this just searches index 0 for all tracks and sets
+             * the value in the tracks.
+             * In the future this should scan for all indices.
+             */
+            bool indexScan( Toc& toc ) const;
+
+            /**
+             * Seek to the specified sector.
+             */
+            bool seek( unsigned long lba ) const;
+
+            bool getNextWritableAdress( unsigned int& lastSessionStart, unsigned int& nextWritableAdress ) const;
+
+            /**
+             * Retrieve the next writable address from the currently mounted writable medium.
+             * \return The next writable address if the medium is empty or appendable or -1
+             * if an error occurred.
+             */
+            int nextWritableAddress() const;
+
+            /**
+             * Locks the device for usage. This means that no MMC command can be performed
+             * until usageUnlock is called.
+             *
+             * Locking a device is useful when an external application or library is called
+             * that opens the device itself.
+             *
+             * \sa usageUnlock
+             */
+            void usageLock() const;
+
+            /**
+             * Unlock the device after a call to usageLock.
+             */
+            void usageUnlock() const;
+
+            /**
+             * Thread-safe ioctl call for this device for Linux and Net-BSD systems.
+             * Be aware that so far this does not include opening the device
+             */
+//      int ioctl( int request, ... ) const;
+
+        protected:
+            bool furtherInit();
+
+#ifdef Q_OS_LINUX
+            /**
+             * Fallback method that uses the evil cdrom.h stuff
+             */
+            bool readTocLinux( Toc& ) const;
+#endif
+
+            /**
+             * The preferred toc reading method for all CDs. Also reads session info.
+             * undefined for DVDs.
+             */
+            bool readRawToc( Toc& ) const;
+            bool readFormattedToc( Toc&, int mediaType ) const;
+
+            /**
+             * Fixes the last block on CD-Extra disks. This is needed if the readRawToc failed since
+             * in that case the first sector of the last session's first track is used as the previous
+             * session's last track's last sector which is wrong. There is a 11400 block session lead-in
+             * between them. This method fixes this only for the last session and only on linux.
+             */
+            bool fixupToc( Toc& ) const;
+
+        private:
+            /**
+             * A Device can only be constructed the the DeviceManager.
+             */
+            Device( const Solid::Device& dev );
+
+            /**
+             * Determines the device's capabilities. This needs to be called once before
+             * using the device.
+             *
+             * Should only be used by the DeviceManager.
+             *
+             * @param checkWritingModes if true the CD writing modes will be checked using
+             *                          MMC_MODE_SELECT.
+             */
+            bool init( bool checkWritingModes = true );
+
+            void searchIndexTransitions( long start, long end, K3b::Device::Track& track ) const;
+            void checkWritingModes();
+            void checkFeatures();
+            void checkForJustLink();
+            void checkFor2AFeatures();
+            void checkForAncientWriters();
+
+            /**
+             * Internal method which checks if the raw toc data has bcd values or hex.
+             * @return 0 if hex, 1 if bcd, -1 if none
+             */
+            int rawTocDataWithBcdValues( unsigned char* data, unsigned int dataLen ) const;
+
+            bool getSupportedWriteSpeedsVia2A( QList<int>& list, MediaType type ) const;
+            bool getSupportedWriteSpeedsViaGP( QList<int>& list, MediaType type ) const;
+
+            int getMaxWriteSpeedVia2A() const;
+
+            QByteArray mediaId( int mediaType ) const;
+
+            class Private;
+            Private* d;
+
+            friend class DeviceManager;
+        };
+
+        /**
+         * This should always be used to open a device since it
+         * uses the resmgr
+         *
+         * @internal
+         */
+        K3b::Device::Device::Handle openDevice( const char* name, bool write = false );
+    }
+}
+
+#endif
diff -rupN k3b-2.0.2/libk3bdevice/k3bscsicommand_bsd.cpp k3b-2.0.2-patched/libk3bdevice/k3bscsicommand_bsd.cpp
--- k3b-2.0.2/libk3bdevice/k3bscsicommand_bsd.cpp	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bscsicommand_bsd.cpp	2013-09-16 01:30:12.000000000 +0300
@@ -1,6 +1,7 @@
 /*
  *
  * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ * Copyright (C) 2011 Andriy Gapon <avg@FreeBSD.org>
  *
  * This file is part of the K3b project.
  * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
@@ -23,41 +24,43 @@
 #include <cam/scsi/scsi_message.h>
 #include <cam/scsi/scsi_pass.h>
 
-#define ERRCODE(s)	((((s)[2]&0x0F)<<16)|((s)[12]<<8)|((s)[13]))
-#define EMEDIUMTYPE	EINVAL
-#define	ENOMEDIUM	ENODEV
-#define CREAM_ON_ERRNO(s)	do {                    \
-        switch ((s)[12])                            \
-        {	case 0x04:	errno=EAGAIN;	break;		\
-        case 0x20:	errno=ENODEV;	break;          \
-        case 0x21:	if ((s)[13]==0)	errno=ENOSPC;	\
-			else		errno=EINVAL;               \
-			break;                                  \
-        case 0x30:	errno=EMEDIUMTYPE;  break;      \
-        case 0x3A:	errno=ENOMEDIUM;    break;      \
-        }                                           \
-    } while(0)
-
+namespace /*anonymous*/
+{
+    inline int sense_to_err( const struct scsi_sense_data& s )
+    {
+        int errorCode, senseKey, addSenseCode, addSenseCodeQual;
+        scsi_extract_sense( (struct scsi_sense_data*) &s, &errorCode,
+                            &senseKey, &addSenseCode, &addSenseCodeQual );
+        return (errorCode << 24) | (senseKey << 16) |
+	       (addSenseCode << 8) | addSenseCodeQual;
+    }
+}
 
 
 class K3b::Device::ScsiCommand::Private
 {
+    typedef union ccb CCB;
+
 public:
-    union ccb ccb;
+    Private();
+    int transport( const Device* device, TransportDirection dir, void* data, size_t len );
+    unsigned char& operator[]( size_t i );
+    void clear();
+    const CCB& get_ccb() { return ccb; }
+
+private:
+    CCB ccb;
 };
 
 
 void K3b::Device::ScsiCommand::clear()
 {
-    memset (&d->ccb,0,sizeof(ccb));
+    d->clear();
 }
 
-
 unsigned char& K3b::Device::ScsiCommand::operator[]( size_t i )
 {
-    if( d->ccb.csio.cdb_len < i+1 )
-        d->ccb.csio.cdb_len = i+1;
-    return d->ccb.csio.cdb_io.cdb_bytes[i];
+    return (*d)[i];
 }
 
 int K3b::Device::ScsiCommand::transport( TransportDirection dir,
@@ -78,130 +81,102 @@ int K3b::Device::ScsiCommand::transport(
         m_device->usageUnlock();
         return -1;
     }
-    d->ccb.ccb_h.path_id    = m_device->handle()->path_id;
-    d->ccb.ccb_h.target_id  = m_device->handle()->target_id;
-    d->ccb.ccb_h.target_lun = m_device->handle()->target_lun;
 
-    kDebug() << "(K3b::Device::ScsiCommand) transport command " << QString::number((int)d->ccb.csio.cdb_io.cdb_bytes[0], 16) << ", length: " << (int)d->ccb.csio.cdb_len;
-    int ret=0;
-    int direction = CAM_DEV_QFRZDIS;
-    if (!len)
-        direction |= CAM_DIR_NONE;
-    else
-        direction |= (dir & TR_DIR_READ)?CAM_DIR_IN : CAM_DIR_OUT;
-    cam_fill_csio (&(d->ccb.csio), 1, 0 /* NULL */, direction, MSG_SIMPLE_Q_TAG, (u_int8_t *)data, len, sizeof(d->ccb.csio.sense_data), d->ccb.csio.cdb_len, 30*1000);
-    unsigned char * sense = (unsigned char *)&d->ccb.csio.sense_data;
+    int ret = d->transport( m_device, dir, data, len );
+    if( ret != 0 ) {
+        const struct scsi_sense_data& s = d->get_ccb().csio.sense_data;
+        int errorCode, senseKey, addSenseCode, addSenseCodeQual;
+        scsi_extract_sense( (struct scsi_sense_data*) &s, &errorCode, &senseKey,
+                            &addSenseCode, &addSenseCodeQual );
+        debugError( d->get_ccb().csio.cdb_io.cdb_bytes[0],
+                    errorCode,
+                    senseKey,
+                    addSenseCode,
+                    addSenseCodeQual );
+    }
 
-    ret = cam_send_ccb(m_device->handle(), &d->ccb);
+    if( needToClose )
+        m_device->close();
+    m_device->usageUnlock();
 
-    if (ret < 0) {
-        kDebug() << "(K3b::Device::ScsiCommand) transport failed: " << ret;
+    return ret;
+}
 
-        if( needToClose )
-            m_device->close();
+K3b::Device::ScsiCommand::Private::Private()
+{
+    clear();
+}
 
-        m_device->usageUnlock();
+void K3b::Device::ScsiCommand::Private::clear()
+{
+    memset( &ccb, 0, sizeof(ccb) );
+}
 
-        struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
-        debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
-                    senset->error_code & SSD_ERRCODE,
-                    senset->flags & SSD_KEY,
-                    senset->add_sense_code,
-                    senset->add_sense_code_qual );
-
-        int result = (((senset->error_code & SSD_ERRCODE)<<24) & 0xF000 |
-                      ((senset->flags & SSD_KEY)<<16)          & 0x0F00 |
-                      (senset->add_sense_code<<8)              & 0x00F0 |
-                      (senset->add_sense_code_qual)            & 0x000F );
-
-        return result ? result : ret;
-    }
-
-    else if ((d->ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP) {
-        if( needToClose )
-            m_device->close();
-        m_device->usageUnlock();
-        return 0;
-    }
+unsigned char& K3b::Device::ScsiCommand::Private::operator[]( size_t i )
+{
+    if( ccb.csio.cdb_len < i + 1 )
+        ccb.csio.cdb_len = i + 1;
+    return ccb.csio.cdb_io.cdb_bytes[i];
+}
 
-    errno = EIO;
-    // FreeBSD 5-CURRENT since 2003-08-24, including 5.2 fails to
-    // pull sense data automatically, at least for ATAPI transport,
-    // so I reach for it myself...
-    if ((d->ccb.csio.scsi_status==SCSI_STATUS_CHECK_COND) &&
-        !(d->ccb.ccb_h.status&CAM_AUTOSNS_VALID))
-    {
-        u_int8_t  _sense[18];
-        u_int32_t resid=d->ccb.csio.resid;
+int K3b::Device::ScsiCommand::Private::transport( const Device* device, TransportDirection dir, void* data, size_t len )
+{
+    ccb.ccb_h.path_id    = device->handle()->path_id;
+    ccb.ccb_h.target_id  = device->handle()->target_id;
+    ccb.ccb_h.target_lun = device->handle()->target_lun;
 
-        memset(_sense,0,sizeof(_sense));
+    kDebug() << "(K3b::Device::ScsiCommand) transport command " << commandString(ccb.csio.cdb_io.cdb_bytes[0])
+             << " (" << QString::number((int)ccb.csio.cdb_io.cdb_bytes[0], 16) << "), length: " << (int)ccb.csio.cdb_len;
+    int direction = CAM_DEV_QFRZDIS;
+    if (!len)
+        direction |= CAM_DIR_NONE;
+    else
+        direction |= (dir & TR_DIR_READ) ? CAM_DIR_IN : CAM_DIR_OUT;
 
-        operator[](0)      = 0x03;	// REQUEST SENSE
-        d->ccb.csio.cdb_io.cdb_bytes[4] = sizeof(_sense);
-        d->ccb.csio.cdb_len   = 6;
-        d->ccb.csio.ccb_h.flags |= CAM_DIR_IN|CAM_DIS_AUTOSENSE;
-        d->ccb.csio.data_ptr  = _sense;
-        d->ccb.csio.dxfer_len = sizeof(_sense);
-        d->ccb.csio.sense_len = 0;
+    cam_fill_csio( &(ccb.csio), 1, NULL, direction, MSG_SIMPLE_Q_TAG, (uint8_t*)data, len, sizeof(ccb.csio.sense_data), ccb.csio.cdb_len, 30*1000 );
+    int ret = cam_send_ccb( device->handle(), &ccb );
+    if( ret < 0 ) {
+        kError() << "(K3b::Device::ScsiCommand) transport cam_send_ccb failed: ret = " << ret
+                 << ", errno = " << errno << ", cam_errbuf = " << cam_errbuf;
+        return 1;
+    }
+    else if( (ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP ) {
+        kDebug() << "(K3b::Device::ScsiCommand) transport succeeded";
+        return 0;
+    }
 
-        ret = cam_send_ccb(m_device->handle(), &d->ccb);
+    kDebug() << "(K3b::Device::ScsiCommand) transport command failed: scsi_status = " << QString::number(ccb.csio.scsi_status, 16);
 
-        d->ccb.csio.resid = resid;
-        if (ret<0)
-        {
-            kDebug() << "(K3b::Device::ScsiCommand) transport failed (2): " << ret;
-            ret = -1;
-            struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
-            debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
-                        senset->error_code & SSD_ERRCODE,
-                        senset->flags & SSD_KEY,
-                        senset->add_sense_code,
-                        senset->add_sense_code_qual );
-
-            if( needToClose )
-                m_device->close();
-            m_device->usageUnlock();
+    if( ccb.csio.scsi_status == SCSI_STATUS_CHECK_COND &&
+        !(ccb.ccb_h.status & CAM_AUTOSNS_VALID) &&
+        ccb.csio.cdb_io.cdb_bytes[0] != MMC_REQUEST_SENSE )
+    {
+        kDebug() << "(K3b::Device::ScsiCommand) transport requesting sense data";
 
-            return -1;
-        }
-        if ((d->ccb.ccb_h.status&CAM_STATUS_MASK) != CAM_REQ_CMP)
+        struct scsi_sense_data sense;
+        ScsiCommand::Private cmd;
+        cmd[0] = MMC_REQUEST_SENSE;
+        cmd[4] = SSD_MIN_SIZE;
+        cmd[5] = 0; // Necessary to set the proper command length
+
+        memset( &sense, 0, sizeof(sense) );
+        ret = cmd.transport( device, TR_DIR_READ, &sense, SSD_MIN_SIZE );
+        if( ret < 0 )
         {
-            kDebug() << "(K3b::Device::ScsiCommand) transport failed (3): " << ret;
-            errno=EIO,-1;
-            ret = -1;
-            struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
-            debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
-                        senset->error_code & SSD_ERRCODE,
-                        senset->flags & SSD_KEY,
-                        senset->add_sense_code,
-                        senset->add_sense_code_qual );
-
-            if( needToClose )
-                m_device->close();
-            m_device->usageUnlock();
-
-            return -1;
+            kWarning() << "(K3b::Device::ScsiCommand) transport getting sense data failed: " << ret;
+            return 1;
         }
 
-        memcpy(sense,_sense,sizeof(_sense));
+        ccb.csio.sense_data = sense;
+        ccb.ccb_h.status |= CAM_AUTOSNS_VALID;
     }
 
-    ret = ERRCODE(sense);
-    kDebug() << "(K3b::Device::ScsiCommand) transport failed (4): " << ret;
-    if (ret == 0)
-        ret = -1;
-    else
-        CREAM_ON_ERRNO(((unsigned char *)&d->ccb.csio.sense_data));
-    struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
-    debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
-                senset->error_code & SSD_ERRCODE,
-                senset->flags & SSD_KEY,
-                senset->add_sense_code,
-                senset->add_sense_code_qual );
-
-    if( needToClose )
-        m_device->close();
-    m_device->usageUnlock();
+    if( !(ccb.ccb_h.status & CAM_AUTOSNS_VALID) )
+        kDebug() << "(K3b::Device::ScsiCommand) sense data is not available";
 
+    ret = sense_to_err(ccb.csio.sense_data);
+    if( ret == 0 )
+        ret = 1;
+    kDebug() << "(K3b::Device::ScsiCommand) transport failed: " << ret;
     return ret;
 }
diff -rupN k3b-2.0.2/libk3bdevice/k3bscsicommand_bsd.cpp.orig k3b-2.0.2-patched/libk3bdevice/k3bscsicommand_bsd.cpp.orig
--- k3b-2.0.2/libk3bdevice/k3bscsicommand_bsd.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/libk3bdevice/k3bscsicommand_bsd.cpp.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,207 @@
+/*
+ *
+ * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include "k3bscsicommand.h"
+#include "k3bdevice.h"
+
+#include <kdebug.h>
+
+#include <stdio.h>
+#include <errno.h>
+#include <camlib.h>
+#include <cam/scsi/scsi_message.h>
+#include <cam/scsi/scsi_pass.h>
+
+#define ERRCODE(s)	((((s)[2]&0x0F)<<16)|((s)[12]<<8)|((s)[13]))
+#define EMEDIUMTYPE	EINVAL
+#define	ENOMEDIUM	ENODEV
+#define CREAM_ON_ERRNO(s)	do {                    \
+        switch ((s)[12])                            \
+        {	case 0x04:	errno=EAGAIN;	break;		\
+        case 0x20:	errno=ENODEV;	break;          \
+        case 0x21:	if ((s)[13]==0)	errno=ENOSPC;	\
+			else		errno=EINVAL;               \
+			break;                                  \
+        case 0x30:	errno=EMEDIUMTYPE;  break;      \
+        case 0x3A:	errno=ENOMEDIUM;    break;      \
+        }                                           \
+    } while(0)
+
+
+
+class K3b::Device::ScsiCommand::Private
+{
+public:
+    union ccb ccb;
+};
+
+
+void K3b::Device::ScsiCommand::clear()
+{
+    memset (&d->ccb,0,sizeof(ccb));
+}
+
+
+unsigned char& K3b::Device::ScsiCommand::operator[]( size_t i )
+{
+    if( d->ccb.csio.cdb_len < i+1 )
+        d->ccb.csio.cdb_len = i+1;
+    return d->ccb.csio.cdb_io.cdb_bytes[i];
+}
+
+int K3b::Device::ScsiCommand::transport( TransportDirection dir,
+                                         void* data,
+                                         size_t len )
+{
+    if( !m_device )
+        return -1;
+
+    m_device->usageLock();
+
+    bool needToClose = false;
+    if( !m_device->isOpen() ) {
+        needToClose = true;
+    }
+
+    if( !m_device->open( true ) ) {
+        m_device->usageUnlock();
+        return -1;
+    }
+    d->ccb.ccb_h.path_id    = m_device->handle()->path_id;
+    d->ccb.ccb_h.target_id  = m_device->handle()->target_id;
+    d->ccb.ccb_h.target_lun = m_device->handle()->target_lun;
+
+    kDebug() << "(K3b::Device::ScsiCommand) transport command " << QString::number((int)d->ccb.csio.cdb_io.cdb_bytes[0], 16) << ", length: " << (int)d->ccb.csio.cdb_len;
+    int ret=0;
+    int direction = CAM_DEV_QFRZDIS;
+    if (!len)
+        direction |= CAM_DIR_NONE;
+    else
+        direction |= (dir & TR_DIR_READ)?CAM_DIR_IN : CAM_DIR_OUT;
+    cam_fill_csio (&(d->ccb.csio), 1, 0 /* NULL */, direction, MSG_SIMPLE_Q_TAG, (u_int8_t *)data, len, sizeof(d->ccb.csio.sense_data), d->ccb.csio.cdb_len, 30*1000);
+    unsigned char * sense = (unsigned char *)&d->ccb.csio.sense_data;
+
+    ret = cam_send_ccb(m_device->handle(), &d->ccb);
+
+    if (ret < 0) {
+        kDebug() << "(K3b::Device::ScsiCommand) transport failed: " << ret;
+
+        if( needToClose )
+            m_device->close();
+
+        m_device->usageUnlock();
+
+        struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
+        debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
+                    senset->error_code & SSD_ERRCODE,
+                    senset->flags & SSD_KEY,
+                    senset->add_sense_code,
+                    senset->add_sense_code_qual );
+
+        int result = (((senset->error_code & SSD_ERRCODE)<<24) & 0xF000 |
+                      ((senset->flags & SSD_KEY)<<16)          & 0x0F00 |
+                      (senset->add_sense_code<<8)              & 0x00F0 |
+                      (senset->add_sense_code_qual)            & 0x000F );
+
+        return result ? result : ret;
+    }
+
+    else if ((d->ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP) {
+        if( needToClose )
+            m_device->close();
+        m_device->usageUnlock();
+        return 0;
+    }
+
+    errno = EIO;
+    // FreeBSD 5-CURRENT since 2003-08-24, including 5.2 fails to
+    // pull sense data automatically, at least for ATAPI transport,
+    // so I reach for it myself...
+    if ((d->ccb.csio.scsi_status==SCSI_STATUS_CHECK_COND) &&
+        !(d->ccb.ccb_h.status&CAM_AUTOSNS_VALID))
+    {
+        u_int8_t  _sense[18];
+        u_int32_t resid=d->ccb.csio.resid;
+
+        memset(_sense,0,sizeof(_sense));
+
+        operator[](0)      = 0x03;	// REQUEST SENSE
+        d->ccb.csio.cdb_io.cdb_bytes[4] = sizeof(_sense);
+        d->ccb.csio.cdb_len   = 6;
+        d->ccb.csio.ccb_h.flags |= CAM_DIR_IN|CAM_DIS_AUTOSENSE;
+        d->ccb.csio.data_ptr  = _sense;
+        d->ccb.csio.dxfer_len = sizeof(_sense);
+        d->ccb.csio.sense_len = 0;
+
+        ret = cam_send_ccb(m_device->handle(), &d->ccb);
+
+        d->ccb.csio.resid = resid;
+        if (ret<0)
+        {
+            kDebug() << "(K3b::Device::ScsiCommand) transport failed (2): " << ret;
+            ret = -1;
+            struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
+            debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
+                        senset->error_code & SSD_ERRCODE,
+                        senset->flags & SSD_KEY,
+                        senset->add_sense_code,
+                        senset->add_sense_code_qual );
+
+            if( needToClose )
+                m_device->close();
+            m_device->usageUnlock();
+
+            return -1;
+        }
+        if ((d->ccb.ccb_h.status&CAM_STATUS_MASK) != CAM_REQ_CMP)
+        {
+            kDebug() << "(K3b::Device::ScsiCommand) transport failed (3): " << ret;
+            errno=EIO,-1;
+            ret = -1;
+            struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
+            debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
+                        senset->error_code & SSD_ERRCODE,
+                        senset->flags & SSD_KEY,
+                        senset->add_sense_code,
+                        senset->add_sense_code_qual );
+
+            if( needToClose )
+                m_device->close();
+            m_device->usageUnlock();
+
+            return -1;
+        }
+
+        memcpy(sense,_sense,sizeof(_sense));
+    }
+
+    ret = ERRCODE(sense);
+    kDebug() << "(K3b::Device::ScsiCommand) transport failed (4): " << ret;
+    if (ret == 0)
+        ret = -1;
+    else
+        CREAM_ON_ERRNO(((unsigned char *)&d->ccb.csio.sense_data));
+    struct scsi_sense_data* senset = (struct scsi_sense_data*)sense;
+    debugError( d->ccb.csio.cdb_io.cdb_bytes[0],
+                senset->error_code & SSD_ERRCODE,
+                senset->flags & SSD_KEY,
+                senset->add_sense_code,
+                senset->add_sense_code_qual );
+
+    if( needToClose )
+        m_device->close();
+    m_device->usageUnlock();
+
+    return ret;
+}
diff -rupN k3b-2.0.2/plugins/CMakeLists.txt.orig k3b-2.0.2-patched/plugins/CMakeLists.txt.orig
--- k3b-2.0.2/plugins/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/CMakeLists.txt.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,3 @@
+add_subdirectory( decoder )
+add_subdirectory( encoder )
+add_subdirectory( project )
diff -rupN k3b-2.0.2/plugins/CMakeLists.txt.rej k3b-2.0.2-patched/plugins/CMakeLists.txt.rej
--- k3b-2.0.2/plugins/CMakeLists.txt.rej	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/CMakeLists.txt.rej	2013-09-16 01:30:57.000000000 +0300
@@ -0,0 +1,17 @@
+***************
+*** 26,32 ****
+  target_link_libraries(k3blameencoder
+    ${KDE4_KDECORE_LIBS}
+    k3b k3bdevice
+-   mp3lame)
+  
+  install(TARGETS
+    k3blameencoder kcm_k3blameencoder
+--- 26,32 ----
+  target_link_libraries(k3blameencoder
+    ${KDE4_KDECORE_LIBS}
+    k3b k3bdevice
++   ${LAME_LIBRARIES})
+  
+  install(TARGETS
+    k3blameencoder kcm_k3blameencoder
diff -rupN k3b-2.0.2/plugins/decoder/ffmpeg/CMakeLists.txt k3b-2.0.2-patched/plugins/decoder/ffmpeg/CMakeLists.txt
--- k3b-2.0.2/plugins/decoder/ffmpeg/CMakeLists.txt	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/plugins/decoder/ffmpeg/CMakeLists.txt	2013-09-16 01:25:52.000000000 +0300
@@ -9,7 +9,7 @@ if(FFMPEG_INCLUDE_DIR_OLD_STYLE)
 else(FFMPEG_INCLUDE_DIR_OLD_STYLE)
     message(STATUS "found new ffmpegcodecpath")
     add_definitions(-DNEWFFMPEGAVCODECPATH)
-    include_directories (${FFMPEG_INCLUDE_DIR})
+    include_directories (${FFMPEG_INCLUDE_DIR} ${FFMPEG_INCLUDE_DIRS})
 endif(FFMPEG_INCLUDE_DIR_OLD_STYLE)
 
 set(k3bffmpegdecoder_PART_SRCS k3bffmpegdecoder.cpp k3bffmpegwrapper.cpp )
diff -rupN k3b-2.0.2/plugins/decoder/ffmpeg/CMakeLists.txt.orig k3b-2.0.2-patched/plugins/decoder/ffmpeg/CMakeLists.txt.orig
--- k3b-2.0.2/plugins/decoder/ffmpeg/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/decoder/ffmpeg/CMakeLists.txt.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,27 @@
+
+
+
+########### next target ###############
+
+if(FFMPEG_INCLUDE_DIR_OLD_STYLE)
+    message(STATUS "didn't find new ffmpegcodecpath")
+    include_directories (${FFMPEG_INCLUDE_DIR_OLD_STYLE})
+else(FFMPEG_INCLUDE_DIR_OLD_STYLE)
+    message(STATUS "found new ffmpegcodecpath")
+    add_definitions(-DNEWFFMPEGAVCODECPATH)
+    include_directories (${FFMPEG_INCLUDE_DIR})
+endif(FFMPEG_INCLUDE_DIR_OLD_STYLE)
+
+set(k3bffmpegdecoder_PART_SRCS k3bffmpegdecoder.cpp k3bffmpegwrapper.cpp )
+
+kde4_add_plugin(k3bffmpegdecoder ${k3bffmpegdecoder_PART_SRCS})
+
+target_link_libraries(k3bffmpegdecoder k3bdevice  ${KDE4_KDEUI_LIBS} k3b ${FFMPEG_LIBRARIES} )
+
+install(TARGETS k3bffmpegdecoder DESTINATION ${PLUGIN_INSTALL_DIR} )
+
+
+########### install files ###############
+
+install( FILES  k3bffmpegdecoder.desktop DESTINATION ${SERVICES_INSTALL_DIR} )
+
diff -rupN k3b-2.0.2/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp k3b-2.0.2-patched/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp
--- k3b-2.0.2/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp	2011-01-15 22:47:29.000000000 +0200
+++ k3b-2.0.2-patched/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp	2013-09-16 01:25:38.000000000 +0300
@@ -88,7 +88,11 @@ bool K3bFFMpegFile::open()
     close();
 
     // open the file
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,2,0)
+    int err = ::avformat_open_input( &d->formatContext, m_filename.toLocal8Bit(), 0, 0 );
+#else
     int err = ::av_open_input_file( &d->formatContext, m_filename.toLocal8Bit(), 0, 0, 0 );
+#endif
     if( err < 0 ) {
         kDebug() << "(K3bFFMpegFile) unable to open " << m_filename << " with error " << err;
         return false;
@@ -109,7 +113,13 @@ bool K3bFFMpegFile::open()
 #else
     ::AVCodecContext* codecContext =  d->formatContext->streams[0]->codec;
 #endif
-    if( codecContext->codec_type != CODEC_TYPE_AUDIO ) {
+    if( codecContext->codec_type != 
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+        AVMEDIA_TYPE_AUDIO)
+#else
+        CODEC_TYPE_AUDIO)
+#endif
+    {
         kDebug() << "(K3bFFMpegFile) not a simple audio stream: " << m_filename;
         return false;
     }
@@ -137,7 +147,11 @@ bool K3bFFMpegFile::open()
     }
 
     // dump some debugging info
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,2,0)
+    ::av_dump_format( d->formatContext, 0, m_filename.toLocal8Bit(), 0 );
+#else
     ::dump_format( d->formatContext, 0, m_filename.toLocal8Bit(), 0 );
+#endif
 
     return true;
 }
@@ -225,8 +239,11 @@ QString K3bFFMpegFile::typeComment() con
 QString K3bFFMpegFile::title() const
 {
     // FIXME: is this UTF8 or something??
-    if( d->formatContext->title[0] != '\0' )
-        return QString::fromLocal8Bit( d->formatContext->title );
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "TITLE", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
     else
         return QString();
 }
@@ -235,8 +252,11 @@ QString K3bFFMpegFile::title() const
 QString K3bFFMpegFile::author() const
 {
     // FIXME: is this UTF8 or something??
-    if( d->formatContext->author[0] != '\0' )
-        return QString::fromLocal8Bit( d->formatContext->author );
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "ARTIST", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
     else
         return QString();
 }
@@ -245,8 +265,11 @@ QString K3bFFMpegFile::author() const
 QString K3bFFMpegFile::comment() const
 {
     // FIXME: is this UTF8 or something??
-    if( d->formatContext->comment[0] != '\0' )
-        return QString::fromLocal8Bit( d->formatContext->comment );
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "COMMENT", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
     else
         return QString();
 }
@@ -309,8 +332,13 @@ int K3bFFMpegFile::fillOutputBuffer()
 #if LIBAVCODEC_VERSION_MAJOR < 52
         int len = ::avcodec_decode_audio(
 #else
+   #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+        int len = ::avcodec_decode_audio3(
+   #else
         int len = ::avcodec_decode_audio2(
+   #endif
 #endif
+
 #ifdef FFMPEG_BUILD_PRE_4629
             &d->formatContext->streams[0]->codec,
 #else
@@ -318,7 +346,11 @@ int K3bFFMpegFile::fillOutputBuffer()
 #endif
             (short*)d->alignedOutputBuffer,
             &d->outputBufferSize,
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+            &d->packet );
+#else
             d->packetData, d->packetSize );
+#endif
 
         if( d->packetSize <= 0 || len < 0 )
             ::av_free_packet( &d->packet );
diff -rupN k3b-2.0.2/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp.orig k3b-2.0.2-patched/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp.orig
--- k3b-2.0.2/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/decoder/ffmpeg/k3bffmpegwrapper.cpp.orig	2013-09-16 01:25:27.000000000 +0300
@@ -0,0 +1,428 @@
+/*
+ *
+ *
+ * Copyright (C) 2004-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2008 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+#include "k3bffmpegwrapper.h"
+
+#include <config-k3b.h>
+
+extern "C" {
+/*
+ Recent versions of FFmepg uses C99 constant macros which are not presebt in C++ standard.
+ The macro __STDC_CONSTANT_MACROS allow C++ to use these macros. Altough it's not defined by C++ standard
+ it's supported by many implementations.
+ See bug 236036 and discussion: http://lists.mplayerhq.hu/pipermail/ffmpeg-devel/2010-May/088074.html
+ */
+#define __STDC_CONSTANT_MACROS
+#ifdef NEWFFMPEGAVCODECPATH
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#else
+#include <ffmpeg/avcodec.h>
+#include <ffmpeg/avformat.h>
+#endif
+}
+
+#include <string.h>
+
+#include <klocale.h>
+
+
+#if LIBAVFORMAT_BUILD < 4629
+#define FFMPEG_BUILD_PRE_4629
+#endif
+
+
+K3bFFMpegWrapper* K3bFFMpegWrapper::s_instance = 0;
+
+
+class K3bFFMpegFile::Private
+{
+public:
+    ::AVFormatContext* formatContext;
+    ::AVCodec* codec;
+
+    K3b::Msf length;
+
+    // for decoding. ffmpeg requires 16-byte alignment.
+    char outputBuffer[AVCODEC_MAX_AUDIO_FRAME_SIZE + 15];
+    char* alignedOutputBuffer;
+    char* outputBufferPos;
+    int outputBufferSize;
+    ::AVPacket packet;
+    quint8* packetData;
+    int packetSize;
+};
+
+
+K3bFFMpegFile::K3bFFMpegFile( const QString& filename )
+    : m_filename(filename)
+{
+    d = new Private;
+    d->formatContext = 0;
+    d->codec = 0;
+    int offset = 0x10 - (reinterpret_cast<intptr_t>(&d->outputBuffer) & 0xf);
+    d->alignedOutputBuffer = &d->outputBuffer[offset];
+}
+
+
+K3bFFMpegFile::~K3bFFMpegFile()
+{
+    close();
+    delete d;
+}
+
+
+bool K3bFFMpegFile::open()
+{
+    close();
+
+    // open the file
+    int err = ::av_open_input_file( &d->formatContext, m_filename.toLocal8Bit(), 0, 0, 0 );
+    if( err < 0 ) {
+        kDebug() << "(K3bFFMpegFile) unable to open " << m_filename << " with error " << err;
+        return false;
+    }
+
+    // analyze the streams
+    ::av_find_stream_info( d->formatContext );
+
+    // we only handle files containing one audio stream
+    if( d->formatContext->nb_streams != 1 ) {
+        kDebug() << "(K3bFFMpegFile) more than one stream in " << m_filename;
+        return false;
+    }
+
+    // urgh... ugly
+#ifdef FFMPEG_BUILD_PRE_4629
+    ::AVCodecContext* codecContext =  &d->formatContext->streams[0]->codec;
+#else
+    ::AVCodecContext* codecContext =  d->formatContext->streams[0]->codec;
+#endif
+    if( codecContext->codec_type != 
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+        AVMEDIA_TYPE_AUDIO)
+#else
+        CODEC_TYPE_AUDIO)
+#endif
+    {
+        kDebug() << "(K3bFFMpegFile) not a simple audio stream: " << m_filename;
+        return false;
+    }
+
+    // get the codec
+    d->codec = ::avcodec_find_decoder(codecContext->codec_id);
+    if( !d->codec ) {
+        kDebug() << "(K3bFFMpegFile) no codec found for " << m_filename;
+        return false;
+    }
+
+    // open the codec on our context
+    kDebug() << "(K3bFFMpegFile) found codec for " << m_filename;
+    if( ::avcodec_open( codecContext, d->codec ) < 0 ) {
+        kDebug() << "(K3bFFMpegDecoderFactory) could not open codec.";
+        return false;
+    }
+
+    // determine the length of the stream
+    d->length = K3b::Msf::fromSeconds( (double)d->formatContext->duration / (double)AV_TIME_BASE );
+
+    if( d->length == 0 ) {
+        kDebug() << "(K3bFFMpegDecoderFactory) invalid length.";
+        return false;
+    }
+
+    // dump some debugging info
+    ::dump_format( d->formatContext, 0, m_filename.toLocal8Bit(), 0 );
+
+    return true;
+}
+
+
+void K3bFFMpegFile::close()
+{
+    d->outputBufferSize = 0;
+    d->packetSize = 0;
+    d->packetData = 0;
+
+    if( d->codec ) {
+#ifdef FFMPEG_BUILD_PRE_4629
+        ::avcodec_close( &d->formatContext->streams[0]->codec );
+#else
+        ::avcodec_close( d->formatContext->streams[0]->codec );
+#endif
+        d->codec = 0;
+    }
+
+    if( d->formatContext ) {
+        ::av_close_input_file( d->formatContext );
+        d->formatContext = 0;
+    }
+}
+
+
+K3b::Msf K3bFFMpegFile::length() const
+{
+    return d->length;
+}
+
+
+int K3bFFMpegFile::sampleRate() const
+{
+#ifdef FFMPEG_BUILD_PRE_4629
+    return d->formatContext->streams[0]->codec.sample_rate;
+#else
+    return d->formatContext->streams[0]->codec->sample_rate;
+#endif
+}
+
+
+int K3bFFMpegFile::channels() const
+{
+#ifdef FFMPEG_BUILD_PRE_4629
+    return d->formatContext->streams[0]->codec.channels;
+#else
+    return d->formatContext->streams[0]->codec->channels;
+#endif
+}
+
+
+int K3bFFMpegFile::type() const
+{
+#ifdef FFMPEG_BUILD_PRE_4629
+    return d->formatContext->streams[0]->codec.codec_id;
+#else
+    return d->formatContext->streams[0]->codec->codec_id;
+#endif
+}
+
+
+QString K3bFFMpegFile::typeComment() const
+{
+    switch( type() ) {
+    case CODEC_ID_WMAV1:
+        return i18n("Windows Media v1");
+    case CODEC_ID_WMAV2:
+        return i18n("Windows Media v2");
+#if LIBAVCODEC_VERSION_MAJOR < 52
+    case CODEC_ID_MP3LAME:
+#else
+    case CODEC_ID_MP3:
+#endif
+        return i18n("MPEG 1 Layer III");
+    case CODEC_ID_AAC:
+        return i18n("Advanced Audio Coding (AAC)");
+    default:
+        return QString::fromLocal8Bit( d->codec->name );
+    }
+}
+
+
+QString K3bFFMpegFile::title() const
+{
+    // FIXME: is this UTF8 or something??
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "TITLE", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
+    else
+        return QString();
+}
+
+
+QString K3bFFMpegFile::author() const
+{
+    // FIXME: is this UTF8 or something??
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "ARTIST", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
+    else
+        return QString();
+}
+
+
+QString K3bFFMpegFile::comment() const
+{
+    // FIXME: is this UTF8 or something??
+    AVDictionaryEntry *ade = av_dict_get( d->formatContext->metadata, "COMMENT", NULL, 0 );
+    if( ade == NULL )
+        return QString();
+    if( ade->value != '\0' )
+        return QString::fromLocal8Bit( ade->value );
+    else
+        return QString();
+}
+
+
+int K3bFFMpegFile::read( char* buf, int bufLen )
+{
+    int ret = fillOutputBuffer();
+    if (ret <= 0) {
+        return ret;
+    }
+
+    int len = qMin(bufLen, d->outputBufferSize);
+    ::memcpy( buf, d->outputBufferPos, len );
+
+    // TODO: only swap if needed
+    for( int i = 0; i < len-1; i+=2 ) {
+        char a = buf[i];
+        buf[i] = buf[i+1];
+        buf[i+1] = a;
+    }
+
+    d->outputBufferPos += len;
+    d->outputBufferSize -= len;
+    return len;
+}
+
+
+// fill d->packetData with data to decode
+int K3bFFMpegFile::readPacket()
+{
+    if( d->packetSize <= 0 ) {
+        ::av_init_packet( &d->packet );
+
+        if( ::av_read_frame( d->formatContext, &d->packet ) < 0 ) {
+            return 0;
+        }
+        d->packetSize = d->packet.size;
+        d->packetData = d->packet.data;
+    }
+
+    return d->packetSize;
+}
+
+
+// decode data in d->packetData and fill d->outputBuffer
+int K3bFFMpegFile::fillOutputBuffer()
+{
+    // decode if the output buffer is empty
+    if( d->outputBufferSize <= 0 ) {
+
+        // make sure we have data to decode
+        if( readPacket() == 0 ) {
+            return 0;
+        }
+
+        d->outputBufferPos = d->alignedOutputBuffer;
+        d->outputBufferSize = AVCODEC_MAX_AUDIO_FRAME_SIZE;
+
+#if LIBAVCODEC_VERSION_MAJOR < 52
+        int len = ::avcodec_decode_audio(
+#else
+   #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+        int len = ::avcodec_decode_audio3(
+   #else
+        int len = ::avcodec_decode_audio2(
+   #endif
+#endif
+
+#ifdef FFMPEG_BUILD_PRE_4629
+            &d->formatContext->streams[0]->codec,
+#else
+            d->formatContext->streams[0]->codec,
+#endif
+            (short*)d->alignedOutputBuffer,
+            &d->outputBufferSize,
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
+            &d->packet );
+#else
+            d->packetData, d->packetSize );
+#endif
+
+        if( d->packetSize <= 0 || len < 0 )
+            ::av_free_packet( &d->packet );
+        if( len < 0 ) {
+            kDebug() << "(K3bFFMpegFile) decoding failed for " << m_filename;
+            return -1;
+        }
+
+        d->packetSize -= len;
+        d->packetData += len;
+    }
+
+    // if it is still empty try again
+    if( d->outputBufferSize <= 0 )
+        return fillOutputBuffer();
+    else
+        return d->outputBufferSize;
+}
+
+
+bool K3bFFMpegFile::seek( const K3b::Msf& msf )
+{
+    d->outputBufferSize = 0;
+    d->packetSize = 0;
+
+    double seconds = (double)msf.totalFrames()/75.0;
+    quint64 timestamp = (quint64)(seconds * (double)AV_TIME_BASE);
+
+    // FIXME: do we really need the start_time and why?
+#if LIBAVFORMAT_BUILD >= 4619
+    return ( ::av_seek_frame( d->formatContext, -1, timestamp + d->formatContext->start_time, 0 ) >= 0 );
+#else
+    return ( ::av_seek_frame( d->formatContext, -1, timestamp + d->formatContext->start_time ) >= 0 );
+#endif
+}
+
+
+
+
+
+
+K3bFFMpegWrapper::K3bFFMpegWrapper()
+{
+    ::av_register_all();
+}
+
+
+K3bFFMpegWrapper::~K3bFFMpegWrapper()
+{
+    s_instance = 0;
+}
+
+
+K3bFFMpegWrapper* K3bFFMpegWrapper::instance()
+{
+    if( !s_instance ) {
+        s_instance = new K3bFFMpegWrapper();
+    }
+
+    return s_instance;
+}
+
+
+K3bFFMpegFile* K3bFFMpegWrapper::open( const QString& filename ) const
+{
+    K3bFFMpegFile* file = new K3bFFMpegFile( filename );
+    if( file->open() ) {
+#ifndef K3B_FFMPEG_ALL_CODECS
+        //
+        // only allow tested formats. ffmpeg seems not to be too reliable with every format.
+        // mp3 being one of them sadly. Most importantly: allow the libsndfile decoder to do
+        // its thing.
+        //
+        if( file->type() == CODEC_ID_WMAV1 ||
+            file->type() == CODEC_ID_WMAV2 ||
+            file->type() == CODEC_ID_AAC )
+#endif
+            return file;
+    }
+
+    delete file;
+    return 0;
+}
diff -rupN k3b-2.0.2/plugins/encoder/CMakeLists.txt.orig k3b-2.0.2-patched/plugins/encoder/CMakeLists.txt.orig
--- k3b-2.0.2/plugins/encoder/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/CMakeLists.txt.orig	2011-01-15 22:47:29.000000000 +0200
@@ -0,0 +1,15 @@
+if(BUILD_SOX_ENCODER_PLUGIN)
+  add_subdirectory( sox )
+endif(BUILD_SOX_ENCODER_PLUGIN)
+
+if(BUILD_EXTERNAL_ENCODER_PLUGIN)
+  add_subdirectory( external )
+endif(BUILD_EXTERNAL_ENCODER_PLUGIN)
+
+if(BUILD_OGGVORBIS_ENCODER_PLUGIN)
+   add_subdirectory(ogg)
+endif(BUILD_OGGVORBIS_ENCODER_PLUGIN)
+
+if(BUILD_LAME_ENCODER_PLUGIN)
+   add_subdirectory(lame)
+endif(BUILD_LAME_ENCODER_PLUGIN)
diff -rupN k3b-2.0.2/plugins/encoder/CMakeLists.txt.rej k3b-2.0.2-patched/plugins/encoder/CMakeLists.txt.rej
--- k3b-2.0.2/plugins/encoder/CMakeLists.txt.rej	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/CMakeLists.txt.rej	2013-09-16 01:31:35.000000000 +0300
@@ -0,0 +1,17 @@
+***************
+*** 26,32 ****
+  target_link_libraries(k3blameencoder
+    ${KDE4_KDECORE_LIBS}
+    k3b k3bdevice
+-   mp3lame)
+  
+  install(TARGETS
+    k3blameencoder kcm_k3blameencoder
+--- 26,32 ----
+  target_link_libraries(k3blameencoder
+    ${KDE4_KDECORE_LIBS}
+    k3b k3bdevice
++   ${LAME_LIBRARIES})
+  
+  install(TARGETS
+    k3blameencoder kcm_k3blameencoder
diff -rupN k3b-2.0.2/plugins/encoder/lame/CMakeLists.txt k3b-2.0.2-patched/plugins/encoder/lame/CMakeLists.txt
--- k3b-2.0.2/plugins/encoder/lame/CMakeLists.txt	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/lame/CMakeLists.txt	2013-09-16 01:32:07.000000000 +0300
@@ -26,7 +26,7 @@ kde4_add_plugin(k3blameencoder
 target_link_libraries(k3blameencoder
   ${KDE4_KDECORE_LIBS}
   k3b k3bdevice
-  mp3lame)
+  ${LAME_LIBRARIES})
 
 install(TARGETS
   k3blameencoder kcm_k3blameencoder
diff -rupN k3b-2.0.2/plugins/encoder/lame/CMakeLists.txt.orig k3b-2.0.2-patched/plugins/encoder/lame/CMakeLists.txt.orig
--- k3b-2.0.2/plugins/encoder/lame/CMakeLists.txt.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/lame/CMakeLists.txt.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,37 @@
+# KCM
+set(k3blameencoderconfig_PART_SRCS
+  k3blameencoderconfigwidget.cpp
+  k3blamemanualsettingsdialog.cpp)
+
+kde4_add_ui_files(k3blameencoderconfig_PART_SRCS
+  base_k3blameencodersettingswidget.ui
+  base_k3bmanualbitratesettingswidget.ui )
+
+kde4_add_plugin(kcm_k3blameencoder
+  ${k3blameencoderconfig_PART_SRCS})
+
+target_link_libraries(kcm_k3blameencoder
+  k3bdevice
+  k3b
+  ${KDE4_KDECORE_LIBS}
+  ${KDE4_KDEUI_LIBS}
+  ${QT_QTGUI_LIBRARY}
+  ${QT_QT3SUPPORT_LIBRARY})
+
+
+# Plugin
+kde4_add_plugin(k3blameencoder
+  k3blameencoder.cpp)
+
+target_link_libraries(k3blameencoder
+  ${KDE4_KDECORE_LIBS}
+  k3b k3bdevice
+  mp3lame)
+
+install(TARGETS
+  k3blameencoder kcm_k3blameencoder
+  DESTINATION ${PLUGIN_INSTALL_DIR} )
+install(FILES
+  k3blameencoder.desktop kcm_k3blameencoder.desktop
+  DESTINATION ${SERVICES_INSTALL_DIR} )
+
diff -rupN k3b-2.0.2/plugins/encoder/sox/k3bsoxencoder.cpp k3b-2.0.2-patched/plugins/encoder/sox/k3bsoxencoder.cpp
--- k3b-2.0.2/plugins/encoder/sox/k3bsoxencoder.cpp	2011-01-15 22:47:30.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/sox/k3bsoxencoder.cpp	2013-09-16 01:25:45.000000000 +0300
@@ -69,6 +69,9 @@ public:
             if ( pos >= 0 ) {
                 pos += 17;
             }
+            else if ( ( pos = out.indexOf( "sox:      SoX v" ) ) >= 0 ) {
+                pos += 15;
+            }
             else if ( ( pos = out.indexOf( "sox: SoX v" ) ) >= 0 ) {
                 pos += 10;
             }
diff -rupN k3b-2.0.2/plugins/encoder/sox/k3bsoxencoder.cpp.orig k3b-2.0.2-patched/plugins/encoder/sox/k3bsoxencoder.cpp.orig
--- k3b-2.0.2/plugins/encoder/sox/k3bsoxencoder.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ k3b-2.0.2-patched/plugins/encoder/sox/k3bsoxencoder.cpp.orig	2011-01-15 22:47:30.000000000 +0200
@@ -0,0 +1,342 @@
+/*
+ *
+ * Copyright (C) 2003-2009 Sebastian Trueg <trueg@k3b.org>
+ * Copyright (C) 2010 Michal Malek <michalm@jabster.pl>
+ *
+ * This file is part of the K3b project.
+ * Copyright (C) 1998-2009 Sebastian Trueg <trueg@k3b.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * See the file "COPYING" for the exact licensing terms.
+ */
+
+#include "k3bsoxencoder.h"
+#include "k3bsoxencoderdefaults.h"
+
+#include <config-k3b.h>
+
+#include "k3bprocess.h"
+#include "k3bcore.h"
+#include "k3bexternalbinmanager.h"
+
+#include <KConfig>
+#include <KDebug>
+#include <KLocale>
+
+#include <QFile>
+#include <QFileInfo>
+
+#include <sys/types.h>
+
+
+namespace {
+
+// the sox external program
+class SoxProgram : public K3b::ExternalProgram
+{
+public:
+    SoxProgram()
+        : K3b::ExternalProgram( "sox" ) {
+    }
+
+    bool scan( const QString& p ) {
+        if( p.isEmpty() )
+            return false;
+
+        QString path = p;
+        QFileInfo fi( path );
+        if( fi.isDir() ) {
+            path = buildProgramPath( path, "sox" );
+        }
+
+        if( !QFile::exists( path ) )
+            return false;
+
+        K3b::ExternalBin* bin = 0;
+
+        // probe version
+        KProcess vp;
+        vp.setOutputChannelMode( KProcess::MergedChannels );
+
+        vp << path << "--version";
+        vp.start();
+        if( vp.waitForFinished( -1 ) ) {
+            QByteArray out = vp.readAll();
+            int pos = out.indexOf( "sox: SoX Version" );
+            if ( pos >= 0 ) {
+                pos += 17;
+            }
+            else if ( ( pos = out.indexOf( "sox: SoX v" ) ) >= 0 ) {
+                pos += 10;
+            }
+            else if ( ( pos = out.indexOf( "sox: Version" ) ) >= 0 ) {
+                pos += 13;
+            }
+            int endPos = out.indexOf( '\n', pos );
+            if( pos > 0 && endPos > 0 ) {
+                bin = new K3b::ExternalBin( this );
+                bin->path = path;
+                bin->version = out.mid( pos, endPos-pos );
+
+                addBin( bin );
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+};
+
+} // namespace
+
+class K3bSoxEncoder::Private
+{
+public:
+    K3b::Process* process;
+    QString fileName;
+};
+
+
+K3bSoxEncoder::K3bSoxEncoder( QObject* parent, const QVariantList& )
+    : K3b::AudioEncoder( parent )
+{
+    if( k3bcore->externalBinManager()->program( "sox" ) == 0 )
+        k3bcore->externalBinManager()->addProgram( new SoxProgram() );
+
+    d = new Private();
+    d->process = 0;
+}
+
+
+K3bSoxEncoder::~K3bSoxEncoder()
+{
+    delete d->process;
+    delete d;
+}
+
+
+void K3bSoxEncoder::finishEncoderInternal()
+{
+    if( d->process && d->process->isRunning() ) {
+        d->process->closeWriteChannel();
+
+        // this is kind of evil...
+        // but we need to be sure the process exited when this method returnes
+        d->process->waitForFinished(-1);
+    }
+}
+
+
+void K3bSoxEncoder::slotSoxFinished( int exitCode, QProcess::ExitStatus exitStatus )
+{
+    if( (exitStatus != QProcess::NormalExit) || (exitCode != 0) )
+        kDebug() << "(K3bSoxEncoder) sox exited with error.";
+}
+
+
+bool K3bSoxEncoder::openFile( const QString& extension, const QString& filename, const K3b::Msf& length, const MetaData& metaData )
+{
+    d->fileName = filename;
+    return initEncoderInternal( extension, length, metaData );
+}
+
+
+bool K3bSoxEncoder::isOpen() const
+{
+    return d->process && d->process->isRunning();
+}
+
+
+void K3bSoxEncoder::closeFile()
+{
+    finishEncoderInternal();
+}
+
+
+bool K3bSoxEncoder::initEncoderInternal( const QString& extension, const K3b::Msf& /*length*/, const MetaData& /*metaData*/ )
+{
+    const K3b::ExternalBin* soxBin = k3bcore->externalBinManager()->binObject( "sox" );
+    if( soxBin ) {
+        // we want to be thread-safe
+        delete d->process;
+        d->process = new K3b::Process();
+        d->process->setSplitStdout(true);
+
+        connect( d->process, SIGNAL(finished(int, QProcess::ExitStatus)),
+                 this, SLOT(slotSoxFinished(int, QProcess::ExitStatus)) );
+        connect( d->process, SIGNAL(stdoutLine(QString)),
+                 this, SLOT(slotSoxOutputLine(QString)) );
+
+        // input settings
+        *d->process << soxBin->path
+                    << "-t" << "raw"    // raw samples
+                    << "-r" << "44100"  // samplerate
+                    << "-s";            // signed linear
+        if ( soxBin->version >= K3b::Version( 13, 0, 0 ) )
+            *d->process << "-2";
+        else
+            *d->process << "-w";        // 16-bit words
+        *d->process << "-c" << "2"      // stereo
+                    << "-";             // read from stdin
+
+        // output settings
+        *d->process << "-t" << extension;
+
+        KSharedConfig::Ptr c = KGlobal::config();
+        KConfigGroup grp(c,"K3bSoxEncoderPlugin" );
+        if( grp.readEntry( "manual settings", DEFAULT_MANUAL_SETTINGS ) ) {
+            *d->process << "-r" << QString::number( grp.readEntry( "samplerate", DEFAULT_SAMPLE_RATE ) )
+                        << "-c" << QString::number( grp.readEntry( "channels", DEFAULT_CHANNELS ) );
+
+            int size = grp.readEntry( "data size", DEFAULT_DATA_SIZE );
+            *d->process << ( size == 8 ? QString("-b") : ( size == 32 ? QString("-l") : QString("-w") ) );
+
+            QString encoding = grp.readEntry( "data encoding", DEFAULT_DATA_ENCODING );
+            if( encoding == "unsigned" )
+                *d->process << "-u";
+            else if( encoding == "u-law" )
+                *d->process << "-U";
+            else if( encoding == "A-law" )
+                *d->process << "-A";
+            else if( encoding == "ADPCM" )
+                *d->process << "-a";
+            else if( encoding == "IMA_ADPCM" )
+                *d->process << "-i";
+            else if( encoding == "GSM" )
+                *d->process << "-g";
+            else if( encoding == "Floating-point" )
+                *d->process << "-f";
+            else
+                *d->process << "-s";
+        }
+
+        *d->process << d->fileName;
+
+        kDebug() << "***** sox parameters:";
+        QString s = d->process->joinedArgs();
+        kDebug() << s << flush;
+
+        return d->process->start( KProcess::MergedChannels );
+    }
+    else {
+        kDebug() << "(K3bSoxEncoder) could not find sox bin.";
+        return false;
+    }
+}
+
+
+long K3bSoxEncoder::encodeInternal( const char* data, Q_ULONG len )
+{
+    if( d->process && d->process->isRunning() )
+        return d->process->write( data, len );
+    else
+        return -1;
+}
+
+
+void K3bSoxEncoder::slotSoxOutputLine( const QString& line )
+{
+    kDebug() << "(sox) " << line;
+}
+
+
+QStringList K3bSoxEncoder::extensions() const
+{
+    static QStringList s_extensions;
+    if( s_extensions.isEmpty() ) {
+        s_extensions << "au"
+                     << "8svx"
+                     << "aiff"
+                     << "avr"
+                     << "cdr"
+                     << "cvs"
+                     << "dat"
+                     << "gsm"
+                     << "hcom"
+                     << "maud"
+                     << "sf"
+                     << "sph"
+                     << "smp"
+                     << "txw"
+                     << "vms"
+                     << "voc"
+                     << "wav"
+                     << "wve"
+                     << "raw";
+    }
+
+    if( k3bcore->externalBinManager()->foundBin( "sox" ) )
+        return s_extensions;
+    else
+        return QStringList(); // no sox -> no encoding
+}
+
+
+QString K3bSoxEncoder::fileTypeComment( const QString& ext ) const
+{
+    if( ext == "au" )
+        return i18n("Sun AU");
+    else if( ext == "8svx" )
+        return i18n("Amiga 8SVX");
+    else if( ext == "aiff" )
+        return i18n("AIFF");
+    else if( ext == "avr" )
+        return i18n("Audio Visual Research");
+    else if( ext == "cdr" )
+        return i18n("CD-R");
+    else if( ext == "cvs" )
+        return i18n("CVS");
+    else if( ext == "dat" )
+        return i18n("Text Data");
+    else if( ext == "gsm" )
+        return i18n("GSM Speech");
+    else if( ext == "hcom" )
+        return i18n("Macintosh HCOM");
+    else if( ext == "maud" )
+        return i18n("Maud (Amiga)");
+    else if( ext == "sf" )
+        return i18n("IRCAM");
+    else if( ext == "sph" )
+        return i18n("SPHERE");
+    else if( ext == "smp" )
+        return i18n("Turtle Beach SampleVision");
+    else if( ext == "txw" )
+        return i18n("Yamaha TX-16W");
+    else if( ext == "vms" )
+        return i18n("VMS");
+    else if( ext == "voc" )
+        return i18n("Sound Blaster VOC");
+    else if( ext == "wav" )
+        return i18n("Wave (Sox)");
+    else if( ext == "wve" )
+        return i18n("Psion 8-bit A-law");
+    else if( ext == "raw" )
+        return i18n("Raw");
+    else
+        return i18n("Error");
+}
+
+
+long long K3bSoxEncoder::fileSize( const QString&, const K3b::Msf& msf ) const
+{
+    // for now we make a rough assumption based on the settings
+    KSharedConfig::Ptr c = KGlobal::config();
+    KConfigGroup grp(c, "K3bSoxEncoderPlugin" );
+    if( grp.readEntry( "manual settings", DEFAULT_MANUAL_SETTINGS ) ) {
+        int sr =  grp.readEntry( "samplerate", DEFAULT_SAMPLE_RATE );
+        int ch = grp.readEntry( "channels", DEFAULT_CHANNELS );
+        int wsize = grp.readEntry( "data size", DEFAULT_DATA_SIZE );
+
+        return msf.totalFrames()*sr*ch*wsize/75;
+    }
+    else {
+        // fallback to raw
+        return msf.audioBytes();
+    }
+}
+
+#include "k3bsoxencoder.moc"

--- doc/rdsrc.pl.org	2017-08-16 21:42:33.747131000 -0400
+++ doc/rdsrc.pl	2017-08-16 22:55:54.526038000 -0400
@@ -1,7 +1,7 @@
 #!/usr/bin/perl
 ## --------------------------------------------------------------------------
-##   
-##   Copyright 1996-2009 The NASM Authors - All Rights Reserved
+##
+##   Copyright 1996-2017 The NASM Authors - All Rights Reserved
 ##   See the file AUTHORS included with the NASM distribution for
 ##   the specific copyright holders.
 ##
@@ -15,7 +15,7 @@
 ##     copyright notice, this list of conditions and the following
 ##     disclaimer in the documentation and/or other materials provided
 ##     with the distribution.
-##     
+##
 ##     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 ##     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 ##     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
@@ -48,6 +48,14 @@
 #   HTML, consecutive groups of bulleted paragraphs become unordered
 #   lists.
 #
+# Indent \>
+#   Indents the paragraph equvalently to a bulleted paragraph.  In HTML,
+#   an indented paragraph following a bulleted paragraph is included in the
+#   same list item.
+#
+# Blockquote \q
+#   Marks the paragraph as a block quote.
+#
 # Emphasis \e{foobar}
 #   produces `_foobar_' in text and italics in HTML, PS, RTF
 #
@@ -116,12 +124,26 @@
 # \&{filename}
 #  Includes filename. Recursion is allowed.
 #
- 
-use IO::File;
 
-$diag = 1, shift @ARGV if $ARGV[0] eq "-d";
+use File::Spec;
+
+@include_path = ();
+$out_path = File::Spec->curdir();
+
+while ($ARGV[0] =~ /^-/) {
+    my $opt = shift @ARGV;
+    if ($opt eq '-d') {
+	$diag = 1;
+    } elsif ($opt =~ /^\-[Ii](.*)$/) {
+	push(@include_path, $1);
+    } elsif ($opt =~ /^\-[Oo](.*)$/) {
+	$out_path = $1;
+    }
+}
 
-($out_format) = @ARGV;
+$out_format = shift(@ARGV);
+@files = @ARGV;
+@files = ('-') unless(scalar(@files));
 
 $| = 1;
 
@@ -136,9 +158,8 @@
 $pname = "para000000";
 @pnames = @pflags = ();
 $para = undef;
-while (defined($_ = <STDIN>)) {
-  $_ = &untabify($_);
-  &check_include($_);
+foreach $file (@files) {
+  &include($file);
 }
 &got_para($para);
 print "done.\n";
@@ -154,6 +175,9 @@
 &indexsort;
 print "done.\n";
 
+# Make output directory if necessary
+mkdir($out_path);
+
 if ($diag) {
   print "Writing index-diagnostic file...";
   &indexdiag;
@@ -205,8 +229,9 @@
   }
   return $o;
 }
-sub check_include {
+sub read_line {
   local $_ = shift;
+  $_ = &untabify($_);
   if (/\\& (\S+)/) {
      &include($1);
   } else {
@@ -226,11 +251,25 @@
 }
 sub include {
   my $name = shift;
-  my $F = IO::File->new($name)
-     or die "Cannot open $name: $!";
-  while (<$F>) {
-     &check_include($_);
+  my $F;
+
+  if ($name eq '-') {
+    open($F, '<-');		# stdin
+  } else {
+    my $found = 0;
+    foreach my $idir ( File::Spec->curdir, @include_path ) {
+	my $fpath = File::Spec->catfile($idir, $name);
+      if (open($F, '<', $fpath)) {
+	$found = 1;
+	last;
+      }
+    }
+    die "Cannot open $name: $!\n" unless ($found);
+  }
+  while (defined($_ = <$F>)) {
+     &read_line($_);
   }
+  close($F);
 }
 sub got_para {
   local ($_) = @_;
@@ -249,8 +288,8 @@
     while (/^\\c (([^\\]|\\[^c])*)(.*)$/) {
       $l = $1;
       $_ = $3;
-      $l =~ s/\\{/{/g;
-      $l =~ s/\\}/}/g;
+      $l =~ s/\\\{/\{/g;
+      $l =~ s/\\\}/}/g;
       $l =~ s/\\\\/\\/g;
       push @$pname, $l;
     }
@@ -263,7 +302,7 @@
     $snum = 0;
     $xref = "chapter-$cnum";
     $pflags = "chap $cnum :$xref";
-    die "badly formatted chapter heading: $_\n" if !/^\\C{([^}]*)}\s*(.*)$/;
+    die "badly formatted chapter heading: $_\n" if !/^\\C\{([^\}]*)\}\s*(.*)$/;
     $refs{$1} = "chapter $cnum";
     $node = "Chapter $cnum";
     &add_item($node, 1);
@@ -280,7 +319,7 @@
     $snum = 0;
     $xref = "appendix-$cnum";
     $pflags = "appn $cnum :$xref";
-    die "badly formatted appendix heading: $_\n" if !/^\\A{([^}]*)}\s*(.*)$/;
+    die "badly formatted appendix heading: $_\n" if !/^\\A\{([^\}]*)}\s*(.*)$/;
     $refs{$1} = "appendix $cnum";
     $node = "Appendix $cnum";
     &add_item($node, 1);
@@ -294,7 +333,7 @@
     $snum = 0;
     $xref = "section-$cnum.$hnum";
     $pflags = "head $cnum.$hnum :$xref";
-    die "badly formatted heading: $_\n" if !/^\\[HP]{([^}]*)}\s*(.*)$/;
+    die "badly formatted heading: $_\n" if !/^\\[HP]{([^\}]*)}\s*(.*)$/;
     $refs{$1} = "section $cnum.$hnum";
     $node = "Section $cnum.$hnum";
     &add_item($node, 2);
@@ -307,7 +346,7 @@
     $snum++;
     $xref = "section-$cnum.$hnum.$snum";
     $pflags = "subh $cnum.$hnum.$snum :$xref";
-    die "badly formatted subheading: $_\n" if !/^\\S{([^}]*)}\s*(.*)$/;
+    die "badly formatted subheading: $_\n" if !/^\\S\{([^\}]*)\}\s*(.*)$/;
     $refs{$1} = "section $cnum.$hnum.$snum";
     $node = "Section $cnum.$hnum.$snum";
     &add_item($node, 3);
@@ -317,25 +356,30 @@
     # the standard word-by-word code will happen next
   } elsif (/^\\IR/) {
     # An index-rewrite.
-    die "badly formatted index rewrite: $_\n" if !/^\\IR{([^}]*)}\s*(.*)$/;
+    die "badly formatted index rewrite: $_\n" if !/^\\IR\{([^\}]*)\}\s*(.*)$/;
     $irewrite = $1;
     $_ = $2;
     # the standard word-by-word code will happen next
   } elsif (/^\\IA/) {
     # An index-alias.
-    die "badly formatted index alias: $_\n" if !/^\\IA{([^}]*)}{([^}]*)}\s*$/;
+    die "badly formatted index alias: $_\n" if !/^\\IA\{([^\}]*)}\{([^\}]*)\}\s*$/;
     $idxalias{$1} = $2;
     return; # avoid word-by-word code
   } elsif (/^\\M/) {
     # Metadata
-    die "badly formed metadata: $_\n" if !/^\\M{([^}]*)}{([^}]*)}\s*$/;
+    die "badly formed metadata: $_\n" if !/^\\M\{([^\}]*)}\{([^\}]*)\}\s*$/;
     $metadata{$1} = $2;
     return; # avoid word-by-word code
-  } elsif (/^\\b/) {
-    # A bulleted paragraph. Strip off the initial \b and let the
-    # word-by-word code take care of the rest.
-    $pflags = "bull";
-    s/^\\b\s*//;
+  } elsif (/^\\([b\>q])/) {
+    # An indented paragraph of some sort. Strip off the initial \b and let the
+      # word-by-word code take care of the rest.
+      my %ipar = (
+	  'b' => 'bull',
+	  '>' => 'indt',
+	  'q' => 'bquo',
+	  );
+    $pflags = $ipar{$1};
+    s/^\\[b\>q]\s*//;
   } else {
     # A normal paragraph. Just set $pflags: the word-by-word code does
     # the rest.
@@ -351,7 +395,8 @@
   #
   # Type codes are:
   # "n " for normal
-  # "da" for a dash
+  # "da" for an en dash
+  # "dm" for an em desh
   # "es" for first emphasised word in emphasised bit
   # "e " for emphasised in mid-emphasised-bit
   # "ee" for last emphasised word in emphasised bit
@@ -374,11 +419,11 @@
       $qindex = 1 if $1 eq "\\I";
       $indexing = 1, s/^\\[iI]// if $1;
       s/^\\c//;
-      die "badly formatted \\c: \\c$_\n" if !/{(([^\\}]|\\.)*)}(.*)$/;
+      die "badly formatted \\c: \\c$_\n" if !/\{(([^\\}]|\\.)*)\}(.*)$/;
       $w = $1;
       $_ = $3;
-      $w =~ s/\\{/{/g;
-      $w =~ s/\\}/}/g;
+      $w =~ s/\\\{/\{/g;
+      $w =~ s/\\\}/\}/g;
       $w =~ s/\\-/-/g;
       $w =~ s/\\\\/\\/g;
       (push @$pname,"i"),$lastp = $#$pname if $indexing;
@@ -391,11 +436,11 @@
       $indexing = 1, $type = "\\i" if $1;
       $emph = 1, $type = "\\e" if $2;
       s/^(\\[iI])?(\\e?)//;
-      die "badly formatted $type: $type$_\n" if !/{(([^\\}]|\\.)*)}(.*)$/;
+      die "badly formatted $type: $type$_\n" if !/\{(([^\\}]|\\.)*)\}(.*)$/;
       $w = $1;
       $_ = $3;
-      $w =~ s/\\{/{/g;
-      $w =~ s/\\}/}/g;
+      $w =~ s/\\\{/\{/g;
+      $w =~ s/\\\}/\}/g;
       $w =~ s/\\-/-/g;
       $w =~ s/\\\\/\\/g;
       $t = $emph ? "es" : "n ";
@@ -418,21 +463,21 @@
       $t = "k ";
       $t = "kK" if /^\\K/;
       s/^\\[kK]//;
-      die "badly formatted \\k: \\c$_\n" if !/{([^}]*)}(.*)$/;
+      die "badly formatted \\k: \\k$_\n" if !/\{([^\}]*)\}(.*)$/;
       $_ = $2;
       push @$pname,"$t$1";
     } elsif (/^\\W/) {
       s/^\\W//;
       die "badly formatted \\W: \\W$_\n"
-          if !/{([^}]*)}(\\i)?(\\c)?{(([^\\}]|\\.)*)}(.*)$/;
+          if !/\{([^\}]*)\}(\\i)?(\\c)?\{(([^\\}]|\\.)*)\}(.*)$/;
       $l = $1;
       $w = $4;
       $_ = $6;
       $t = "w ";
       $t = "wc" if $3 eq "\\c";
       $indexing = 1 if $2;
-      $w =~ s/\\{/{/g;
-      $w =~ s/\\}/}/g;
+      $w =~ s/\\\{/\{/g;
+      $w =~ s/\\\}/\}/g;
       $w =~ s/\\-/-/g;
       $w =~ s/\\\\/\\/g;
       (push @$pname,"i"),$lastp = $#$pname if $indexing;
@@ -443,12 +488,14 @@
       die "painful death! $_\n" if !length $1;
       $w = $1;
       $_ = $3;
-      $w =~ s/\\{/{/g;
-      $w =~ s/\\}/}/g;
+      $w =~ s/\\\{/\{/g;
+      $w =~ s/\\\}/\}/g;
       $w =~ s/\\-/-/g;
       $w =~ s/\\\\/\\/g;
-      if ($w eq "-") {
-        push @$pname,"da";
+      if ($w eq '--') {
+	  push @$pname, 'dm';
+      } elsif ($w eq '-') {
+        push @$pname, 'da';
       } else {
         push @$pname,"n $w";
       }
@@ -519,7 +566,7 @@
 
 sub indexdiag {
   my $iitem,$ientry,$w,$ww,$foo,$node;
-  open INDEXDIAG,">index.diag";
+  open INDEXDIAG, '>', File::Spec->catfile($out_path, 'index.diag');
   foreach $iitem (@itags) {
     $ientry = $idxmap{$iitem};
     print INDEXDIAG "<$iitem> ";
@@ -571,11 +618,11 @@
 
   # Open file.
   print "writing file...";
-  open TEXT,">nasmdoc.txt";
+  open TEXT, '>', File::Spec->catfile($out_path, 'nasmdoc.txt');
   select TEXT;
 
   # Preamble.
-  $title = "The Netwide Assembler: NASM";
+  $title = $metadata{'title'};
   $spaces = ' ' x ((75-(length $title))/2);
   ($underscore = $title) =~ s/./=/g;
   print "$spaces$title\n$spaces$underscore\n";
@@ -626,13 +673,13 @@
         warn "code line longer than 68 chars: $i\n" if length $i > 68;
         print ' 'x7, $i, "\n";
       }
-    } elsif ($ptype eq "bull" || $ptype eq "norm") {
-      # Ordinary paragraph, optionally bulleted. We wrap, with ragged
+    } elsif ($ptype =~ /^(norm|bull|indt|bquo)$/) {
+      # Ordinary paragraph, optionally indented. We wrap, with ragged
       # 75-char right margin and either 7 or 11 char left margin
       # depending on bullets.
-      if ($ptype eq "bull") {
-        $line = ' 'x7 . '(*) ';
-	$next = ' 'x11;
+      if ($ptype ne 'norm') {
+	  $line = ' 'x7 . (($ptype eq 'bull') ? '(*) ' : '    ');
+	  $next = ' 'x11;
       } else {
         $line = $next = ' 'x7;
       }
@@ -678,7 +725,7 @@
     return $w;
   } elsif ($wtype eq "sp") {
     return ' ';
-  } elsif ($wtype eq "da") {
+  } elsif ($wtype eq 'da' || $wtype eq 'dm') {
     return '-';
   } elsif ($wmajt eq "c" || $wtype eq "wc") {
     return "`${w}'";
@@ -702,84 +749,113 @@
   # Write contents file. Just the preamble, then a menu of links to the
   # separate chapter files and the nodes therein.
   print "writing contents file...";
-  open TEXT,">nasmdoc0.html";
+  open TEXT, '>', File::Spec->catfile($out_path, 'nasmdoc0.html');
   select TEXT;
   &html_preamble(0);
   print "<p>This manual documents NASM, the Netwide Assembler: an assembler\n";
-  print "targetting the Intel x86 series of processors, with portable source.\n";
-  print "<p>";
+  print "targetting the Intel x86 series of processors, with portable source.\n</p>";
+  print "<div class=\"toc\">\n";
+  $level = 0;
   for ($node = $tstruct_next{'Top'}; $node; $node = $tstruct_next{$node}) {
-    if ($tstruct_level{$node} == 1) {
+      my $lastlevel = $level;
+      while ($tstruct_level{$node} < $level) {
+	  print "</li>\n</ol>\n";
+	  $level--;
+      }
+      while ($tstruct_level{$node} > $level) {
+	  print "<ol class=\"toc", ++$level, "\">\n";
+      }
+      if ($lastlevel >= $level) {
+	  print "</li>\n";
+      }
+      $level = $tstruct_level{$node};
+      if ($level == 1) {
       # Invent a file name.
-      ($number = lc($xrefnodes{$node})) =~ s/.*-//;
-      $fname="nasmdocx.html";
-      substr($fname,8 - length $number, length $number) = $number;
-      $html_fnames{$node} = $fname;
-      $link = $fname;
-      print "<p>";
-    } else {
-      # Use the preceding filename plus a marker point.
-      $link = $fname . "#$xrefnodes{$node}";
-    }
-    $title = "$node: ";
-    $pname = $tstruct_pname{$node};
-    foreach $i (@$pname) {
-      $ww = &word_html($i);
-      $title .= $ww unless $ww eq "\001";
-    }
-    print "<a href=\"$link\">$title</a><br>\n";
+	  ($number = lc($xrefnodes{$node})) =~ s/.*-//;
+	  $fname="nasmdocx.html";
+	  substr($fname,8 - length $number, length $number) = $number;
+	  $html_fnames{$node} = $fname;
+	  $link = $fname;
+      } else {
+	  # Use the preceding filename plus a marker point.
+	  $link = $fname . "#$xrefnodes{$node}";
+      }
+      $title = '';
+      $pname = $tstruct_pname{$node};
+      foreach $i (@$pname) {
+	  $ww = &word_html($i);
+	  $title .= $ww unless $ww eq "\001";
+      }
+      print "<li class=\"toc${level}\">\n";
+      print "<span class=\"node\">$node: </span><a href=\"$link\">$title</a>\n";
+  }
+  while ($level--) {
+      print "</li>\n</ol>\n";
   }
-  print "<p><a href=\"nasmdoci.html\">Index</a>\n";
-  print "</body></html>\n";
+  print "</div>\n";
+  print "</body>\n";
+  print "</html>\n";
   select STDOUT;
   close TEXT;
 
   # Open a null file, to ensure output (eg random &html_jumppoints calls)
   # goes _somewhere_.
   print "writing chapter files...";
-  open TEXT,">/dev/null";
+  open TEXT, '>', File::Spec->devnull();
   select TEXT;
-  $html_lastf = '';
+  undef $html_nav_last;
+  undef $html_nav_next;
 
   $in_list = 0;
+  $in_bquo = 0;
+  $in_code = 0;
 
   for ($para = 0; $para <= $#pnames; $para++) {
     $pname = $pnames[$para];
     $pflags = $pflags[$para];
     $ptype = substr($pflags,0,4);
 
-    $in_list = 0, print "</ul>\n" if $in_list && $ptype ne "bull";
+    $in_code = 0, print "</pre>\n" if ($in_code && $ptype ne 'code');
+    $in_list = 0, print "</li>\n</ul>\n" if ($in_list && $ptype !~ /^(bull|indt|code)$/);
+    $in_bquo = 0, print "</blockquote>\n" if ($in_bquo && $ptype ne 'bquo');
+
+    $endtag = '';
+
     if ($ptype eq "chap") {
       # Chapter heading. Begin a new file.
       $pflags =~ /chap (.*) :(.*)/;
       $title = "Chapter $1: ";
       $xref = $2;
-      &html_jumppoints; print "</body></html>\n"; select STDOUT; close TEXT;
-      $html_lastf = $html_fnames{$chapternode};
+      &html_postamble; select STDOUT; close TEXT;
+      $html_nav_last = $chapternode;
       $chapternode = $nodexrefs{$xref};
-      $html_nextf = $html_fnames{$tstruct_mnext{$chapternode}};
-      open TEXT,">$html_fnames{$chapternode}"; select TEXT; &html_preamble(1);
+      $html_nav_next = $tstruct_mnext{$chapternode};
+      open(TEXT, '>', File::Spec->catfile($out_path, $html_fnames{$chapternode}));
+      select TEXT;
+      &html_preamble(1);
       foreach $i (@$pname) {
         $ww = &word_html($i);
         $title .= $ww unless $ww eq "\001";
       }
-      $h = "<h2><a name=\"$xref\">$title</a></h2>\n";
+      $h = "<h2 id=\"$xref\">$title</h2>\n";
       print $h; print FULL $h;
     } elsif ($ptype eq "appn") {
       # Appendix heading. Begin a new file.
       $pflags =~ /appn (.*) :(.*)/;
       $title = "Appendix $1: ";
       $xref = $2;
-      &html_jumppoints; print "</body></html>\n"; select STDOUT; close TEXT;
-      $html_lastf = $html_fnames{$chapternode};
+      &html_postamble; select STDOUT; close TEXT;
+      $html_nav_last = $chapternode;
       $chapternode = $nodexrefs{$xref};
-      $html_nextf = $html_fnames{$tstruct_mnext{$chapternode}};
-      open TEXT,">$html_fnames{$chapternode}"; select TEXT; &html_preamble(1);
+      $html_nav_next = $tstruct_mnext{$chapternode};
+      open(TEXT, '>', File::Spec->catfile($out_path, $html_fnames{$chapternode}));
+      select TEXT;
+      &html_preamble(1);
       foreach $i (@$pname) {
         $ww = &word_html($i);
         $title .= $ww unless $ww eq "\001";
       }
-      print "<h2><a name=\"$xref\">$title</a></h2>\n";
+      print "<h2 id=\"$xref\">$title</h2>\n";
     } elsif ($ptype eq "head" || $ptype eq "subh") {
       # Heading or subheading.
       $pflags =~ /.... (.*) :(.*)/;
@@ -790,27 +866,45 @@
         $ww = &word_html($i);
         $title .= $ww unless $ww eq "\001";
       }
-      print "<$hdr><a name=\"$xref\">$title</a></$hdr>\n";
+      print "<$hdr id=\"$xref\">$title</$hdr>\n";
     } elsif ($ptype eq "code") {
-      # Code paragraph.
-      print "<p><pre>\n";
-      foreach $i (@$pname) {
-	$w = $i;
-	$w =~ s/&/&amp;/g;
-	$w =~ s/</&lt;/g;
-	$w =~ s/>/&gt;/g;
-        print $w, "\n";
-      }
-      print "</pre>\n";
-    } elsif ($ptype eq "bull" || $ptype eq "norm") {
-      # Ordinary paragraph, optionally bulleted. We wrap, with ragged
-      # 75-char right margin and either 7 or 11 char left margin
-      # depending on bullets.
-      if ($ptype eq "bull") {
-        $in_list = 1, print "<ul>\n" unless $in_list;
-        $line = '<li>';
+	# Code paragraph.
+	$in_code = 1, print "<pre>" unless $in_code;
+	print "\n";
+	foreach $i (@$pname) {
+	    $w = $i;
+	    $w =~ s/&/&amp;/g;
+	    $w =~ s/</&lt;/g;
+	    $w =~ s/>/&gt;/g;
+	    print $w, "\n";
+	}
+    } elsif ($ptype =~ /^(norm|bull|indt|bquo)$/) {
+      # Ordinary paragraph, optionally indented.
+	if ($ptype eq 'bull') {
+	    if (!$in_list) {
+		$in_list = 1;
+		print "<ul>\n";
+	    } else {
+		print "</li>\n";
+	    }
+	    print "<li>\n";
+	    $line = '<p>';
+	    $endtag = '</p>';
+      } elsif ($ptype eq 'indt') {
+	  if (!$in_list) {
+	      $in_list = 1;
+	      print "<ul>\n";
+	      print "<li class=\"indt\">\n"; # This is such a hack
+	  }
+	  $line = '<p>';
+	  $endtag = '</p>';
+      } elsif ($ptype eq 'bquo') {
+	  $in_bquo = 1, print "<blockquote>\n" unless $in_bquo;
+	  $line = '<p>';
+	  $endtag = '</p>';
       } else {
         $line = '<p>';
+        $endtag = '</p>';
       }
       @a = @$pname;
       $wd = $wprev = '';
@@ -831,42 +925,66 @@
       } while ($w ne '' && $w ne undef);
       if ($line =~ /\S/) {
 	$line =~ s/\s*$//; # trim trailing spaces
-	print "$line\n";
+	print $line;
       }
+      print $endtag, "\n";
     }
   }
 
   # Close whichever file was open.
-  &html_jumppoints;
-  print "</body></html>\n";
-  select STDOUT;
-  close TEXT;
+  print "</pre>\n" if ($in_code);
+  print "</li>\n</ul>\n" if ($in_list);
+  print "</blockquote>\n" if ($in_bquo);
+  &html_postamble; select STDOUT; close TEXT;
 
   print "\n   writing index file...";
-  open TEXT,">nasmdoci.html";
+  open TEXT, '>', File::Spec->catfile($out_path, 'nasmdoci.html');
   select TEXT;
   &html_preamble(0);
-  print "<p align=center><a href=\"nasmdoc0.html\">Contents</a>\n";
-  print "<p>";
+  print "<h2 class=\"index\">Index</h2>\n";
+  print "<ul class=\"index\">\n";
   &html_index;
-  print "<p align=center><a href=\"nasmdoc0.html\">Contents</a>\n";
-  print "</body></html>\n";
+  print "</ul>\n</body>\n</html>\n";
   select STDOUT;
   close TEXT;
 }
 
 sub html_preamble {
-  print "<html><head><title>NASM Manual</title></head>\n";
-  print "<body><h1 align=center>The Netwide Assembler: NASM</h1>\n\n";
-  &html_jumppoints if $_[0];
+    print "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n";
+    print "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" ";
+    print "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n";
+    print "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n";
+    print "<head>\n";
+    print "<title>", $metadata{'title'}, "</title>\n";
+    print "<link href=\"nasmdoc.css\" rel=\"stylesheet\" type=\"text/css\" />\n";
+    print "<link href=\"local.css\" rel=\"stylesheet\" type=\"text/css\" />\n";
+    print "</head>\n";
+    print "<body>\n";
+
+    # Navigation bar
+    print "<ul class=\"navbar\">\n";
+    if (defined($html_nav_last)) {
+	my $lastf = $html_fnames{$html_nav_last};
+	print "<li class=\"first\"><a class=\"prev\" href=\"$lastf\">$html_nav_last</a></li>\n";
+    }
+    if (defined($html_nav_next)) {
+	my $nextf = $html_fnames{$html_nav_next};
+	print "<li><a class=\"next\" href=\"$nextf\">$html_nav_next</a></li>\n";
+    }
+    print "<li><a class=\"toc\" href=\"nasmdoc0.html\">Contents</a></li>\n";
+    print "<li class=\"last\"><a class=\"index\" href=\"nasmdoci.html\">Index</a></li>\n";
+    print "</ul>\n";
+
+    print "<div class=\"title\">\n";
+    print "<h1>", $metadata{'title'}, "</h1>\n";
+    print '<span class="subtitle">', $metadata{'subtitle'}, "</span>\n";
+    print "</div>\n";
+    print "<div class=\"contents\"\n>\n";
 }
 
-sub html_jumppoints {
-  print "<p align=center>";
-  print "<a href=\"$html_nextf\">Next Chapter</a> |\n" if $html_nextf;
-  print "<a href=\"$html_lastf\">Previous Chapter</a> |\n" if $html_lastf;
-  print "<a href=\"nasmdoc0.html\">Contents</a> |\n";
-  print "<a href=\"nasmdoci.html\">Index</a>\n";
+sub html_postamble {
+    # Common closing tags
+    print "</div>\n</body>\n</html>\n";
 }
 
 sub html_index {
@@ -884,6 +1002,7 @@
       push @a, "sp", "x $xrefnodes{$node}", "n $node", "xe$xrefnodes{$node}";
       $sep = 1;
     }
+    print "<li class=\"index\">\n";
     $line = '';
     do {
       do { $w = &word_html(shift @a) } while $w eq "\001"; # nasty hack
@@ -902,9 +1021,9 @@
     } while ($w ne '' && $w ne undef);
     if ($line =~ /\S/) {
       $line =~ s/\s*$//; # trim trailing spaces
-      print "$line\n";
+      print $line, "\n";
     }
-    print "<br>\n";
+    print "</li>\n";
   }
 }
 
@@ -928,9 +1047,11 @@
   } elsif ($wtype eq "sp") {
     return ' ';
   } elsif ($wtype eq "da") {
-    return '-'; # sadly, en-dashes are non-standard in HTML
+    return '&ndash;';
+  } elsif ($wtype eq "dm") {
+    return '&mdash;';
   } elsif ($wmajt eq "c" || $wtype eq "wc") {
-    return $pfx . "<code><nobr>${w}</nobr></code>" . $sfx;
+    return $pfx . "<code>${w}</code>" . $sfx;
   } elsif ($wtype eq "es") {
     return "<em>${w}";
   } elsif ($wtype eq "ee") {
@@ -958,6 +1079,45 @@
   }
 }
 
+# Make tree structures. $tstruct_* is top-level and global.
+sub add_item {
+  my ($item, $level) = @_;
+  my $i;
+
+  $tstruct_pname{$item} = $pname;
+  $tstruct_next{$tstruct_previtem} = $item;
+  $tstruct_prev{$item} = $tstruct_previtem;
+  $tstruct_level{$item} = $level;
+  $tstruct_up{$item} = $tstruct_last[$level-1];
+  $tstruct_mnext{$tstruct_last[$level]} = $item;
+  $tstruct_last[$level] = $item;
+  for ($i=$level+1; $i<$MAXLEVEL; $i++) { $tstruct_last[$i] = undef; }
+  $tstruct_previtem = $item;
+  push @nodes, $item;
+}
+
+#
+# This produces documentation intermediate paragraph format; this is
+# basically the digested output of the front end.  Intended for use
+# by future backends, instead of putting it all in the same script.
+#
+sub write_dip {
+  open(PARAS, '>', File::Spec->catfile($out_path, 'nasmdoc.dip'));
+  foreach $k (sort(keys(%metadata))) {
+      print PARAS 'meta :', $k, "\n";
+      print PARAS $metadata{$k},"\n";
+  }
+  for ($para = 0; $para <= $#pnames; $para++) {
+      print PARAS $pflags[$para], "\n";
+      print PARAS join("\037", @{$pnames[$para]}, "\n");
+  }
+  foreach $k (@itags) {
+      print PARAS 'indx :', $k, "\n";
+      print PARAS join("\037", @{$idxmap{$k}}), "\n";
+  }
+  close(PARAS);
+}
+
 sub write_texi {
   # This is called from the top level, so I won't bother using
   # my or local.
@@ -1468,42 +1628,3 @@
   }
   print "}\n" if $done;
 }
-
-# Make tree structures. $tstruct_* is top-level and global.
-sub add_item {
-  my ($item, $level) = @_;
-  my $i;
-
-  $tstruct_pname{$item} = $pname;
-  $tstruct_next{$tstruct_previtem} = $item;
-  $tstruct_prev{$item} = $tstruct_previtem;
-  $tstruct_level{$item} = $level;
-  $tstruct_up{$item} = $tstruct_last[$level-1];
-  $tstruct_mnext{$tstruct_last[$level]} = $item;
-  $tstruct_last[$level] = $item;
-  for ($i=$level+1; $i<$MAXLEVEL; $i++) { $tstruct_last[$i] = undef; }
-  $tstruct_previtem = $item;
-  push @nodes, $item;
-}
-
-#
-# This produces documentation intermediate paragraph format; this is
-# basically the digested output of the front end.  Intended for use
-# by future backends, instead of putting it all in the same script.
-#
-sub write_dip {
-  open(PARAS, "> nasmdoc.dip");
-  foreach $k (keys(%metadata)) {
-      print PARAS 'meta :', $k, "\n";
-      print PARAS $metadata{$k},"\n";
-  }
-  for ($para = 0; $para <= $#pnames; $para++) {
-      print PARAS $pflags[$para], "\n";
-      print PARAS join("\037", @{$pnames[$para]}, "\n");
-  }
-  foreach $k (@itags) {
-      print PARAS 'indx :', $k, "\n";
-      print PARAS join("\037", @{$idxmap{$k}}), "\n";
-  }
-  close(PARAS);
-}
